<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="博客,技术,分享,记录">
<meta name="description" content="记录与分享~">
<meta name="theme-color" content="#000">
<title>Stone的万事屋</title>
<link rel="shortcut icon" href="/favicon.ico?v=1653468821118">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/velocity/1.5.0/velocity.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/velocity/1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.11.1/katex.min.js" 
integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous">

<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ["\\(", "\\)"]],
      displayMath: [['$$', '$$'], ["\\[", "\\]"]]
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'a', 'annotation', 'annotation-xml'],
      ignoreHtmlClass: 'tex2jax_ignore|crayon-.*', // 'crayon-' 开头的类，属于Wordpress代码高亮库，这部分不需要处理，否则会导致显示不正确,这部分是正则式，多条之间用'|'分割
      processHtmlClass: 'tex2jax_process'
    },
    //禁用右键菜单	
    renderActions: {
      addMenu: [0, '', '']
    }
  };
</script>
<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>




<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?6060c10a27186bc3facae54a55d25e7f";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>



</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Stone的万事屋</span>
            </a>  
          
        </div>
        
          <p class="subtitle">博客|技术|记录|分享~</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> 归档
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> 标签
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/post/about" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout  pisces">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Stone</p>
    
    <div class="site-description right-motion">
      
        <p id="binft">喜欢就关注我~</p>
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">28</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">10</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  

  



  <div style="width: 100%; position: relative;">
    <canvas id="canvasDiyBlock" style="width:100%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
    <script src="/media/js/magic/clock.js"></script>
  </div>

</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'pisces';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box tag-line box-shadow-wrapper">
          <section class="section tags-section posts-expand bg-color">
            <div class="padding-wrapper">
  <div class="tag-timeline-box">
    <div class="tag-timeline-wrapper">
      <div class="tag-timeline-title">
        <h2>
          Spring Cloud
          <small class="language" data-lan="tag">标签</small>
        </h2>
      </div>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="https://blog9527.github.io/post/bi-ji-pian-zhi-wei-fu-wu/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              05-21
              <small>笔记篇之微服务</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </div>
  </div>
</div>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('05/20/2022');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
       <a href="" target="_blank"></a>
    </div>
  </footer>
  
    
        <div class="pisces back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "快回来哦~";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/aop-de-shi-xian-bu-zou/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;AOP&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-aop&#34;&gt;1 AOP&lt;/h3&gt;
&lt;p&gt;在软件业，AOP为Aspect Oriented Programming的缩写，意为：&lt;strong&gt;面向切面编程&lt;/strong&gt;，通过预编译方式和运行期间&lt;strong&gt;动态代理&lt;/strong&gt;实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，&lt;strong&gt;从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-aop实现步骤&#34;&gt;2 AOP实现步骤&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;公式: AOP(切面) = 通知方法(5种) + 切入点表达式(4种)&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
2.1 通知方法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.before通知 在执行目标方法之前执行&lt;br&gt;
2.afterReturning通知 在目标方法执行之后执行&lt;br&gt;
3.afterThrowing通知 在目标方法执行之后报错时执行&lt;br&gt;
4.after通知 无论什么时候程序执行完成都要执行的通知&lt;br&gt;
上述的4大通知类型,不能控制目标方法是否执行.一般用来记录程序的执行的状态.&lt;br&gt;
一般应用与监控的操作.&lt;br&gt;
5.around通知(功能最为强大的) 在目标方法执行前后执行.&lt;br&gt;
因为环绕通知可以控制目标方法是否执行.控制程序的执行的轨迹.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.2切入点表达式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.bean(“bean的ID”) 粒度: 粗粒度 按bean匹配 当前bean中的方法都会执行通知.&lt;br&gt;
2.within(“包名.类名”) 粒度: 粗粒度 可以匹配多个类&lt;br&gt;
3.execution(“返回值类型 包名.类名.方法名(参数列表)”) 粒度: 细粒度 方法参数级别&lt;br&gt;
4.@annotation(“包名.类名”) 粒度:细粒度 按照注解匹配&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//例：
package com.jt.aop;
import lombok.extern.apachecommons.CommonsLog;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Controller;
import org.springframework.stereotype.Service;

import java.util.Arrays;

@Aspect //标识我是一个切面
@Component  //交给Spring容器管理
public class CacheAOP {

    //切面 = 切入点表达式 + 通知方法
    //@Pointcut(&amp;quot;bean(itemCatServiceImpl)&amp;quot;)
    //@Pointcut(&amp;quot;within(com.jt.service.ItemCatServiceImpl)&amp;quot;)
    //@Pointcut(&amp;quot;within(com.jt.service.*)&amp;quot;)   // .* 一级包路径   ..* 所有子孙后代包
    //@Pointcut(&amp;quot;execution(返回值类型 包名.类名.方法名(参数列表))&amp;quot;)
    @Pointcut(&amp;quot;execution(* com.jt.service..*.*(..))&amp;quot;)
    //注释: 返回值类型任意类型   在com.jt.service下的所有子孙类   以add开头的方法,任意参数类型
    public void pointCut(){

    }

    /**
     * 需求:
     *      1.获取目标方法的路径
     *      2.获取目标方法的参数.
     *      3.获取目标方法的名称
     */
    @Before(&amp;quot;pointCut()&amp;quot;)
    public void before(JoinPoint joinPoint){
        String classNamePath = joinPoint.getSignature().getDeclaringTypeName();
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        System.out.println(&amp;quot;方法路径:&amp;quot;+classNamePath);
        System.out.println(&amp;quot;方法参数:&amp;quot;+ Arrays.toString(args));
        System.out.println(&amp;quot;方法名称:&amp;quot;+methodName);
    }

    @Around(&amp;quot;pointCut()&amp;quot;)
    public Object around(ProceedingJoinPoint joinPoint){
        try {
            System.out.println(&amp;quot;环绕通知开始&amp;quot;);
            Object obj = joinPoint.proceed();
            //如果有下一个通知,就执行下一个通知,如果没有就执行目标方法(业务方法)
            System.out.println(&amp;quot;环绕通知结束&amp;quot;);
            return null;
        } catch (Throwable throwable) {
            throwable.printStackTrace();
            throw new RuntimeException(throwable);
        }

    }
}
&lt;/code&gt;&lt;/pre&gt;
">AOP的实现步骤</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/chong-shi-zhi-shi-dian/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;合抱之木始于毫末,万丈高楼起于垒土&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-3554510&#34;&gt; &lt;em&gt;记录点点滴滴·持续更新&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-3554510&#34;&gt; *记录点点滴滴·持续更新*&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;java中获取类对象的几种方式&#34;&gt;Java中获取类对象的几种方式&lt;/h2&gt;
&lt;p&gt;1.通过类名.class获取&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Class class=Student.class;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.通过具体对象获取&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Student student=new Student();
Class class=student.getClass();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.通过Class类的forName()方法获取，括号中的内容是类的全名；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Class class=Class.forName(&amp;quot;com.demo.Student&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;同步与异步&#34;&gt;同步与异步&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;同步：&lt;br&gt;
同一时刻，有钥匙的是独占资源，共享资源无人抢，没钥匙的等待；&lt;br&gt;
&lt;s&gt;一定要等任务执行完了，得到结果，才执行下一个任务；&lt;/s&gt;&lt;br&gt;
异步：&lt;br&gt;
同一时刻，无人排队，抢着占用共享资源；&lt;br&gt;
&lt;s&gt;不等任务执行完，直接执行下一个任务。&lt;/s&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;并行与并发&#34;&gt;并行与并发&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;并行：&lt;br&gt;
多个CPU，每个CPU执行自己的任务，不抢占，慢慢干；&lt;br&gt;
&lt;s&gt;在同一时刻，有多条指令在多个处理器上同时执行；&lt;/s&gt;&lt;br&gt;
并发：&lt;br&gt;
单个CPU，被多个资源去抢占了，抢着干；&lt;br&gt;
&lt;s&gt;同一时刻，只能有一条指令执行，但多个进程指令被快熟轮换地执行，使得在宏观上具有多个进程同时执行的效果；&lt;/s&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">重拾知识点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/java-he-xin-zhuan-ti-1-bing-fa-bian-cheng/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;【面试篇·持续更新】多多阅读，吸取精华&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-3766306&#34;&gt; &lt;em&gt;持续更新&lt;/em&gt;&lt;br&gt;
&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80-%E5%9C%A8java-%E4%B8%AD%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%9C%AC%E5%9C%B0%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB&#34;&gt;一、 在java 中守护线程和本地线程区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;二、 线程与进程的区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2&#34;&gt;三、 什么是多线程中的上下文切换？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B-%E6%AD%BB%E9%94%81%E4%B8%8E%E6%B4%BB%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;四、 死锁与活锁的区别，死锁与饥饿的区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94-java-%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88&#34;&gt;五、 Java 中用到的线程调度算法是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AD-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E7%BB%84%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8java-%E4%B8%AD%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8&#34;&gt;六、 什么是线程组，为什么在Java 中不推荐使用？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%83-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8executor-%E6%A1%86%E6%9E%B6&#34;&gt;七、 为什么使用Executor 框架？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-3766306&#34;&gt; *持续更新*
@[TOC](并发)&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一-在java-中守护线程和本地线程区别&#34;&gt;一、 在java 中守护线程和本地线程区别？&lt;/h2&gt;
&lt;p&gt;java 中的线程分为两种： &lt;strong&gt;守护线程&lt;/strong&gt;（ Daemon） 和&lt;strong&gt;用户线程&lt;/strong&gt;（ User）。&lt;br&gt;
任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(bool on)；true 则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon() 必须在 Thread.start()之前调用， 否则运行时会抛出异常。&lt;/p&gt;
&lt;p&gt;两者的区别：&lt;br&gt;
唯一的区别是判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离， Daemon 没有可服务的线程， JVM 撤离。也可以理解为守护线程是 JVM 自动创建的线程（ 但不一定）， 用户线程是程序创建的线程； 比如 JVM 的垃圾回收线程是一个守护线程， 当所有线程已经撤离， 不再产生垃圾， 守护线程自然就没事可干了， 当垃圾回收线程是 Java 虚拟机上仅剩的线程时， Java 虚拟机会自动离开。&lt;/p&gt;
&lt;p&gt;扩展： Thread Dump 打印出来的线程信息， 含有 daemon 字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break 的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。&lt;/p&gt;
&lt;h2 id=&#34;二-线程与进程的区别&#34;&gt;二、 线程与进程的区别？&lt;/h2&gt;
&lt;p&gt;进程是操作系统&lt;strong&gt;分配资源&lt;/strong&gt;的最小单元，  线程是操作系统&lt;strong&gt;调度&lt;/strong&gt;的最小单元。一个程序至少有一个进程,一个进程至少有一个线程。&lt;/p&gt;
&lt;h2 id=&#34;三-什么是多线程中的上下文切换&#34;&gt;三、 什么是多线程中的上下文切换？&lt;/h2&gt;
&lt;p&gt;多线程会共同使用一组计算机上的 CPU，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU。不同的线程切换使用 CPU 发生的切换数据等就是上下文切换。&lt;/p&gt;
&lt;h2 id=&#34;四-死锁与活锁的区别死锁与饥饿的区别&#34;&gt;四、 死锁与活锁的区别，死锁与饥饿的区别？&lt;/h2&gt;
&lt;p&gt;死锁： 是指两个或两个以上的进程（ 或线程） 在执行过程中， 因争夺资源而造成的一种互相等待的现象， 若无外力作用， 它们都将无法推进下去。&lt;br&gt;
产生死锁的&lt;strong&gt;必要条件&lt;/strong&gt;：&lt;br&gt;
1、互斥条件： 所谓互斥就是进程在某一时间内独占资源。&lt;br&gt;
2、请求与保持条件： 一个进程因请求资源而阻塞时， 对已获得的资源保持不放。&lt;br&gt;
3、不剥夺条件:进程已获得资源， 在末使用完之前， 不能强行剥夺。&lt;br&gt;
4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。&lt;/p&gt;
&lt;p&gt;活锁： 任务或者执行者没有被阻塞， 由于某些条件没有满足， 导致一直重复尝试， 失败， 尝试， 失败。&lt;br&gt;
活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“ 活”，  而处于死锁的实体表现为等待； 活锁有可能自行解开， 死锁则不能。&lt;/p&gt;
&lt;p&gt;饥饿： 一个或者多个线程因为种种原因无法获得所需要的资源， 导致一直无法执行的状态。&lt;br&gt;
Java 中导致饥饿的原因：&lt;br&gt;
1、高优先级线程吞噬所有的低优先级线程的 CPU 时间。&lt;br&gt;
2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前   持续地对该同步块进行访问。&lt;br&gt;
3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)， 因为其他线程总是被持续地获得唤醒。&lt;/p&gt;
&lt;h2 id=&#34;五-java-中用到的线程调度算法是什么&#34;&gt;五、 Java 中用到的线程调度算法是什么？&lt;/h2&gt;
&lt;p&gt;采用时间片轮转的方式。可以设置线程的优先级，   会映射到下层的系统上面的优先级上， 如非特别需要， 尽量不要用， 防止线程饥饿。&lt;/p&gt;
&lt;h2 id=&#34;六-什么是线程组为什么在java-中不推荐使用&#34;&gt;六、 什么是线程组，为什么在Java 中不推荐使用？&lt;/h2&gt;
&lt;p&gt;ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象， 也可以有线程组， 组中还可以有线程， 这样的组织结构有点类似于树的形式。&lt;br&gt;
为什么不推荐使用？ 因为使用有很多的安全隐患吧， 没有具体追究， 如果需要使用， 推荐使用线程池。&lt;/p&gt;
&lt;h2 id=&#34;七-为什么使用executor-框架&#34;&gt;七、 为什么使用Executor 框架？&lt;/h2&gt;
&lt;p&gt;每次执行任务创建线程 new Thread()比较消耗性能， 创建一个线程是比较耗时、耗资源的。&lt;br&gt;
调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建， 线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪， 还有线程之间的频繁交替也会消耗很多系统资源。&lt;br&gt;
接使用 new Thread() 启动的线程不利于扩展， 比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。&lt;/p&gt;
">Java核心专题1-并发编程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/java-ji-chu-ti-pian/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;备战面试，收集整理一些问题&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;1.面向对象和面向过程的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2java-%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9&#34;&gt;2.Java 语言有哪些特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E5%85%B3%E4%BA%8E-jvm-jdk-%E5%92%8C-jre-%E6%9C%80%E8%AF%A6%E7%BB%86%E9%80%9A%E4%BF%97%E7%9A%84%E8%A7%A3%E7%AD%94&#34;&gt;3.关于 JVM JDK 和 JRE 最详细通俗的解答&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4oracle-jdk-%E5%92%8C-openjdk-%E7%9A%84%E5%AF%B9%E6%AF%94&#34;&gt;4.Oracle JDK 和 OpenJDK 的对比&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-java-%E5%92%8C-c%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;5. Java 和 C++的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-%E4%BB%80%E4%B9%88%E6%98%AF-java-%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%BB%E7%B1%BB-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%BB%E7%B1%BB%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C&#34;&gt;6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-java-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%97%B4%E6%9C%89%E9%82%A3%E4%BA%9B%E5%B7%AE%E5%88%AB&#34;&gt;7. Java 应用程序与小程序之间有那些差别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;8. 字符型常量和字符串常量的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9-%E6%9E%84%E9%80%A0%E5%99%A8-constructor-%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB-override&#34;&gt;9. 构造器 Constructor 是否可被 override&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;10. 重载和重写的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11-java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7-%E5%B0%81%E8%A3%85-%E7%BB%A7%E6%89%BF-%E5%A4%9A%E6%80%81&#34;&gt;11. Java 面向对象编程三大特性: 封装 继承 多态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-string-stringbuffer-%E5%92%8C-stringbuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88-string-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84&#34;&gt;12. String StringBuffer 和 StringBuilder 的区别是什么 String 为什么是不可变的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1&#34;&gt;13. 自动装箱与拆箱&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14-%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%86%85%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E6%B3%95%E7%9A%84&#34;&gt;14. 在一个静态方法内调用一个非静态成员为什么是非法的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#15-%E5%9C%A8-java-%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%81%9A%E4%BA%8B%E4%B8%94%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8&#34;&gt;15. 在 Java 中定义一个不做事且没有参数的构造方法的作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#16-import-java-%E5%92%8C-javax-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB&#34;&gt;16. import java 和 javax 有什么区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#17-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88&#34;&gt;17. 接口和抽象类的区别是什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#18-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E9%82%A3%E4%BA%9B&#34;&gt;18. 成员变量与局部变量的区别有那些&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#19-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BB%80%E4%B9%88%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C&#34;&gt;19. 创建一个对象用什么运算符?对象实体与对象引用有何不同?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#20-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BF%94%E5%9B%9E%E5%80%BC%E5%9C%A8%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E9%87%8C%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88&#34;&gt;20. 什么是方法的返回值?返回值在类的方法里的作用是什么?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#21-%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88-%E8%8B%A5%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97-%E4%B8%BA%E4%BB%80%E4%B9%88&#34;&gt;21. 一个类的构造方法的作用是什么 若一个类没有声明构造方法,该程序能正确执行吗 ?为什么?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7&#34;&gt;22. 构造方法有哪些特性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C&#34;&gt;23. 静态方法和实例方法有何不同&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89%E4%B8%8E%E6%8C%87%E5%90%91%E4%BB%96%E4%BB%AC%E7%9A%84%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E4%B8%A4%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C&#34;&gt;24. 对象的相等与指向他们的引用相等，两者有什么不同？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#25-%E5%9C%A8%E8%B0%83%E7%94%A8%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E5%89%8D%E4%BC%9A%E5%85%88%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%85%B6%E7%9B%AE%E7%9A%84%E6%98%AF&#34;&gt;25. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#26-%E4%B8%8E-equals%E9%87%8D%E8%A6%81&#34;&gt;26. == 与 equals(重要)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#27hashcode-%E4%B8%8E-equals%E9%87%8D%E8%A6%81&#34;&gt;27.hashCode 与 equals（重要）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#28-%E4%B8%BA%E4%BB%80%E4%B9%88-java-%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92&#34;&gt;28. 为什么 Java 中只有值传递&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#29-%E7%AE%80%E8%BF%B0%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88&#34;&gt;29. 简述线程，程序、进程的基本概念。以及他们之间关系是什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#30-%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81&#34;&gt;30. 线程有哪些基本状态?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#31-%E5%85%B3%E4%BA%8E-final-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93&#34;&gt;31 关于 final 关键字的一些总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
(目录)&lt;/p&gt;
&lt;h2 id=&#34;1面向对象和面向过程的区别&#34;&gt;1.面向对象和面向过程的区别&lt;/h2&gt;
&lt;p&gt;面向过程&lt;br&gt;
优点： 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发，性能是最重要的因素。 缺点： 没有面向对象易维护、易复用、易扩展&lt;br&gt;
面向对象&lt;br&gt;
优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的&lt;/p&gt;
&lt;h2 id=&#34;2java-语言有哪些特点&#34;&gt;2.Java 语言有哪些特点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;简单易学；&lt;/li&gt;
&lt;li&gt;面向对象（封装，继承，多态）；&lt;/li&gt;
&lt;li&gt;平台无关性（ Java 虚拟机实现平台无关性）；&lt;/li&gt;
&lt;li&gt;可靠性；&lt;/li&gt;
&lt;li&gt;安全性；&lt;/li&gt;
&lt;li&gt;支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；&lt;/li&gt;
&lt;li&gt;支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；&lt;/li&gt;
&lt;li&gt;编译与解释并存；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3关于-jvm-jdk-和-jre-最详细通俗的解答&#34;&gt;3.关于 JVM JDK 和 JRE 最详细通俗的解答&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;JVM&lt;/strong&gt;&lt;br&gt;
Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。&lt;br&gt;
什么是字节码?采用字节码的好处是什么?&lt;br&gt;
在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同的计算机上运行。&lt;br&gt;
Java 程序从&lt;strong&gt;源代码到运行&lt;/strong&gt;一般有下面 &lt;strong&gt;3 步&lt;/strong&gt;：&lt;br&gt;
我们需要格外注意的是 .class-&amp;gt;机器码 这一步。在这一步 jvm 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的，也就是所谓的热点代&lt;br&gt;
码，所以后面引进了 JIT 编译器，JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。&lt;br&gt;
HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分&lt;br&gt;
系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式&lt;br&gt;
AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就&lt;br&gt;
避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ， AOT 编译器的编译质量是肯定比不上 JIT 编译器的。 总结：Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。&lt;br&gt;
&lt;strong&gt;JDK 和 JRE&lt;/strong&gt;&lt;br&gt;
JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。&lt;br&gt;
JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。&lt;br&gt;
如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用&lt;br&gt;
程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译&lt;br&gt;
servlet。&lt;/p&gt;
&lt;h2 id=&#34;4oracle-jdk-和-openjdk-的对比&#34;&gt;4.Oracle JDK 和 OpenJDK 的对比&lt;/h2&gt;
&lt;p&gt;可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么&lt;br&gt;
Oracle 和 OpenJDK 之间是否存在重大差异？下面通过我通过我收集到一些资料对你解答这个被很多人忽视的问题。&lt;br&gt;
对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：&lt;br&gt;
问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？&lt;br&gt;
答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。 总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Oracle JDK 版本将每三年发布一次，而 OpenJDK 版本每三个月发布一次；&lt;/li&gt;
&lt;li&gt;OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是&lt;br&gt;
OpenJDK 的一个实现，并不是完全开源的；&lt;/li&gt;
&lt;li&gt;Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎&lt;br&gt;
相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；&lt;/li&gt;
&lt;li&gt;顶级公司正在使用 Oracle JDK，例如 Android Studio，Minecraft 和&lt;br&gt;
IntelliJ IDEA 开发工具，其中 Open JDK 不太受欢迎；&lt;/li&gt;
&lt;li&gt;在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；&lt;/li&gt;
&lt;li&gt;Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；&lt;/li&gt;
&lt;li&gt;Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-java-和-c的区别&#34;&gt;5. Java 和 C++的区别&lt;/h2&gt;
&lt;p&gt;我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！&lt;br&gt;
•	都是面向对象的语言，都支持封装、继承和多态&lt;br&gt;
•	Java 不提供指针来直接访问内存，程序内存更加安全&lt;br&gt;
•	Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。&lt;br&gt;
•	Java 有自动内存管理机制，不需要程序员手动释放无用内存&lt;/p&gt;
&lt;h2 id=&#34;6-什么是-java-程序的主类-应用程序和小程序的主类有何不同&#34;&gt;6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同&lt;/h2&gt;
&lt;p&gt;一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main（）方法的类。而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。&lt;/p&gt;
&lt;h2 id=&#34;7-java-应用程序与小程序之间有那些差别&#34;&gt;7. Java 应用程序与小程序之间有那些差别&lt;/h2&gt;
&lt;p&gt;简单说应用程序是从主线程启动(也就是 main() 方法)。applet 小程序没有 main 方法，主要是嵌在浏览器页面上运行(调用 init()线程或者 run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。&lt;/p&gt;
&lt;h2 id=&#34;8-字符型常量和字符串常量的区别&#34;&gt;8. 字符型常量和字符串常量的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符&lt;/li&gt;
&lt;li&gt;含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201104132752132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;占内存大小 字符常量只占 2 个字节 字符串常量占若干个字节(至少一个字符结束标志) (注意： char 在 Java 中占两个字节) java 编程思想第四版：2.2.2 节&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;9-构造器-constructor-是否可被-override&#34;&gt;9. 构造器 Constructor 是否可被 override&lt;/h2&gt;
&lt;p&gt;在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以&lt;br&gt;
Constructor 也就不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。&lt;/p&gt;
&lt;h2 id=&#34;10-重载和重写的区别&#34;&gt;10. 重载和重写的区别&lt;/h2&gt;
&lt;p&gt;重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　&lt;br&gt;
重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类&lt;br&gt;
方法访问修饰符为 private 则子类就不能重写该方法。&lt;/p&gt;
&lt;h2 id=&#34;11-java-面向对象编程三大特性-封装-继承-多态&#34;&gt;11. Java 面向对象编程三大特性: 封装 继承 多态&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;封装&lt;/strong&gt;&lt;br&gt;
封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。 继承&lt;br&gt;
继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。&lt;br&gt;
关于&lt;strong&gt;继承&lt;/strong&gt;如下 3 点请记住：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;子类拥有父类非 private 的属性和方法。&lt;/li&gt;
&lt;li&gt;子类可以拥有自己属性和方法，即子类可以对父类进行扩展。&lt;/li&gt;
&lt;li&gt;子类可以用自己的方式实现父类的方法。（以后介绍）。 多态&lt;br&gt;
所谓&lt;strong&gt;多态&lt;/strong&gt;就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。&lt;br&gt;
在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;12-string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的&#34;&gt;12. String StringBuffer 和 StringBuilder 的区别是什么 String 为什么是不可变的&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可变性&lt;/strong&gt; 　&lt;br&gt;
简单的来说：String 类中使用 final 关键字字符数组保存字符串，private　&lt;br&gt;
final　char　value[]，所以 String 对象是不可变的。而 StringBuilder 与&lt;br&gt;
StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中&lt;br&gt;
也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。&lt;br&gt;
StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是&lt;br&gt;
AbstractStringBuilder 实现的，大家可以自行查阅源码。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AbstractStringBuilder.java 
abstract class AbstractStringBuilder implements Appendable, CharSequence {char[] value;  int count; 
    AbstractStringBuilder() { 
    } 
    AbstractStringBuilder(int capacity) {
    value = new char[capacity]; 
    } 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;线程安全性&lt;/strong&gt;&lt;br&gt;
String 中的对象是不可变的，也就可以理解为常量，线程安全。&lt;br&gt;
AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。&lt;br&gt;
&lt;strong&gt;性能&lt;/strong&gt;&lt;br&gt;
每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将&lt;br&gt;
指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用&lt;br&gt;
StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，&lt;br&gt;
但却要冒多线程不安全的风险。 对于三者&lt;strong&gt;使用的总结&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;操作少量的数据 = String&lt;/li&gt;
&lt;li&gt;单线程操作字符串缓冲区下操作大量数据 = StringBuilder&lt;/li&gt;
&lt;li&gt;多线程操作字符串缓冲区下操作大量数据 = StringBuffer&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;13-自动装箱与拆箱&#34;&gt;13. 自动装箱与拆箱&lt;/h2&gt;
&lt;p&gt;装箱：将基本类型用它们对应的引用类型包装起来；  拆箱：将包装类型转换为基本数据类型；&lt;/p&gt;
&lt;h2 id=&#34;14-在一个静态方法内调用一个非静态成员为什么是非法的&#34;&gt;14. 在一个静态方法内调用一个非静态成员为什么是非法的&lt;/h2&gt;
&lt;p&gt;由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。&lt;/p&gt;
&lt;h2 id=&#34;15-在-java-中定义一个不做事且没有参数的构造方法的作用&#34;&gt;15. 在 Java 中定义一个不做事且没有参数的构造方法的作用&lt;/h2&gt;
&lt;p&gt;Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。&lt;/p&gt;
&lt;h2 id=&#34;16-import-java-和-javax-有什么区别&#34;&gt;16. import java 和 javax 有什么区别&lt;/h2&gt;
&lt;p&gt;刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。&lt;br&gt;
所以，实际上 java 和 javax 没有区别。这都是一个名字。&lt;/p&gt;
&lt;h2 id=&#34;17-接口和抽象类的区别是什么&#34;&gt;17. 接口和抽象类的区别是什么&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法&lt;/li&gt;
&lt;li&gt;接口中的实例变量默认是 final 类型的，而抽象类中则不一定&lt;/li&gt;
&lt;li&gt;一个类可以实现多个接口，但最多只能实现一个抽象类&lt;/li&gt;
&lt;li&gt;一个类实现接口的话要实现接口的所有方法，而抽象类不一定&lt;/li&gt;
&lt;li&gt;接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;18-成员变量与局部变量的区别有那些&#34;&gt;18. 成员变量与局部变量的区别有那些&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的&lt;br&gt;
变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰；&lt;/li&gt;
&lt;li&gt;从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存&lt;/li&gt;
&lt;li&gt;从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。&lt;/li&gt;
&lt;li&gt;成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值）；而局部变量则不会自动赋值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;19-创建一个对象用什么运算符对象实体与对象引用有何不同&#34;&gt;19. 创建一个对象用什么运算符?对象实体与对象引用有何不同?&lt;/h2&gt;
&lt;p&gt;new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或   个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。&lt;/p&gt;
&lt;h2 id=&#34;20-什么是方法的返回值返回值在类的方法里的作用是什么&#34;&gt;20. 什么是方法的返回值?返回值在类的方法里的作用是什么?&lt;/h2&gt;
&lt;p&gt;方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！&lt;/p&gt;
&lt;h2 id=&#34;21-一个类的构造方法的作用是什么-若一个类没有声明构造方法该程序能正确执行吗-为什么&#34;&gt;21. 一个类的构造方法的作用是什么 若一个类没有声明构造方法,该程序能正确执行吗 ?为什么?&lt;/h2&gt;
&lt;p&gt;主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。&lt;/p&gt;
&lt;h2 id=&#34;22-构造方法有哪些特性&#34;&gt;22. 构造方法有哪些特性&lt;/h2&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;没有返回值，但不能用 void 声明构造函数；&lt;/li&gt;
&lt;li&gt;生成类的对象时自动执行，无需调用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;23-静态方法和实例方法有何不同&#34;&gt;23. 静态方法和实例方法有何不同&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在外部调用静态方法时，可以使用&amp;quot;类名.方法名&amp;quot;的方式，也可以使用&amp;quot;对象名.方法名&amp;quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。&lt;/li&gt;
&lt;li&gt;静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无&lt;br&gt;
此限制.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;24-对象的相等与指向他们的引用相等两者有什么不同&#34;&gt;24. 对象的相等与指向他们的引用相等，两者有什么不同？&lt;/h2&gt;
&lt;p&gt;对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。&lt;/p&gt;
&lt;h2 id=&#34;25-在调用子类构造方法之前会先调用父类没有参数的构造方法其目的是&#34;&gt;25. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是?&lt;/h2&gt;
&lt;p&gt;帮助子类做初始化工作。&lt;/p&gt;
&lt;h2 id=&#34;26-与-equals重要&#34;&gt;26. == 与 equals(重要)&lt;/h2&gt;
&lt;p&gt;== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型&lt;mark&gt;比较的是值，引用数据类型&lt;/mark&gt;比较的是内存地址)&lt;br&gt;
equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：&lt;br&gt;
•	情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。&lt;br&gt;
•	情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//举个例子： 
public class test1 { 
    public static void main(String[] args) {         String a = new String(&amp;quot;ab&amp;quot;); // a 为一个引用 
        String b = new String(&amp;quot;ab&amp;quot;); // b为另一个引用,对象的内容一样 
        String aa = &amp;quot;ab&amp;quot;; // 放在常量池中         String bb = &amp;quot;ab&amp;quot;; // 从常量池中查找         if (aa == bb) // true 
            System.out.println(&amp;quot;aa==bb&amp;quot;);         if (a == b) // false，非同一对象             System.out.println(&amp;quot;a==b&amp;quot;);         if (a.equals(b)) // true             System.out.println(&amp;quot;aEQb&amp;quot;);         if (42 == 42.0) { // true             System.out.println(&amp;quot;true&amp;quot;); 
        } 
    } 
} 
说明： 
•	String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 
•	当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没
有就在常量池中重新创建一个 String 对象。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;27hashcode-与-equals重要&#34;&gt;27.hashCode 与 equals（重要）&lt;/h2&gt;
&lt;p&gt;面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？”&lt;br&gt;
&lt;strong&gt;hashCode（）介绍&lt;/strong&gt;&lt;br&gt;
hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义&lt;br&gt;
在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。&lt;br&gt;
散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）&lt;br&gt;
&lt;strong&gt;为什么要有 hashCode&lt;/strong&gt;&lt;br&gt;
我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：&lt;br&gt;
当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 hashCode（）与 equals（）的相关规定&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果两个对象相等，则 hashcode 一定也是相同的&lt;/li&gt;
&lt;li&gt;两个对象相等,对两个对象分别调用 equals 方法都返回 true&lt;/li&gt;
&lt;li&gt;两个对象有相同的 hashcode 值，它们也不一定是相等的&lt;/li&gt;
&lt;li&gt;因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖&lt;/li&gt;
&lt;li&gt;hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;28-为什么-java-中只有值传递&#34;&gt;28. 为什么 Java 中只有值传递&lt;/h2&gt;
&lt;h2 id=&#34;29-简述线程程序-进程的基本概念-以及他们之间关系是什么&#34;&gt;29. 简述线程，程序、进程的基本概念。以及他们之间关系是什么&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。&lt;br&gt;
&lt;strong&gt;程序&lt;/strong&gt;是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。&lt;br&gt;
&lt;strong&gt;进程&lt;/strong&gt;是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。&lt;/p&gt;
&lt;h2 id=&#34;30-线程有哪些基本状态&#34;&gt;30. 线程有哪些基本状态?&lt;/h2&gt;
&lt;h2 id=&#34;31-关于-final-关键字的一些总结&#34;&gt;31 关于 final 关键字的一些总结&lt;/h2&gt;
&lt;p&gt;final 关键字主要用在三个地方：变量、方法、类。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。&lt;/li&gt;
&lt;li&gt;当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。&lt;/li&gt;
&lt;li&gt;使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。&lt;/li&gt;
&lt;/ol&gt;
">Java基础题篇</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/json-de-yi-xie-zhi-shi/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;合抱之木始于毫末,万丈高楼起于垒土&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1什么是json&#34;&gt;1.什么是JSON&lt;/h3&gt;
&lt;p&gt;答:JSON(JavaScript Object Notation) 是一种&lt;em&gt;轻量级&lt;/em&gt;的&lt;strong&gt;数据交换格式&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2json基于两种结构&#34;&gt;2.JSON基于两种结构：&lt;/h3&gt;
&lt;p&gt;JSON[1] 结构有两种结构[2]&lt;br&gt;
json简单说就是&lt;strong&gt;javascript中的对象和数组&lt;/strong&gt;，所以这两种结构就是&lt;strong&gt;对象&lt;/strong&gt;和&lt;strong&gt;数组&lt;/strong&gt;两种结构，通过这两种结构可以表示各种复杂的结构。&lt;/p&gt;
&lt;p&gt;2.1 JSON格式之对象格式&lt;br&gt;
对象（object） 是一个无序的“‘名称/值’对”集合。一个&lt;strong&gt;对象&lt;/strong&gt;以“&lt;strong&gt;{&lt;/strong&gt;”（左括号）开始，“&lt;strong&gt;}&lt;/strong&gt;”（右括号）结束。每个“&lt;strong&gt;名称&lt;/strong&gt;”后跟一个“&lt;strong&gt;:&lt;/strong&gt;”（冒号）；“‘&lt;strong&gt;名称/值&lt;/strong&gt;’ 对”之间使用“&lt;strong&gt;,&lt;/strong&gt;”（逗号）分隔。&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/2020110221022048.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//例
{“id”:&amp;quot;1&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;周董&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.2JSON格式之数组格式&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201102210442981.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//例
[&amp;quot;1&amp;quot;,&amp;quot;周董&amp;quot;,&amp;quot;歌手&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.3JSON格式之嵌套格式&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201102210606783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//例
[&amp;quot;周董&amp;quot;,&amp;quot;唱歌&amp;quot;,[1,2,3,4,5],{&amp;quot;id&amp;quot;:1,&amp;quot;name&amp;quot;:&amp;quot;月半伦&amp;quot;,&amp;quot;hobby&amp;quot;:[&amp;quot;写歌&amp;quot;,&amp;quot;拍电影&amp;quot;,&amp;quot;喝奶茶&amp;quot;]}]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;http://json.cn/&#34;&gt;Json在线解析地址&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201102220656655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">JSON的一些知识</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/mian-shi-zhi-dubbo-pian/"" data-c="
          &lt;h3 id=&#34;1-dubbo-是什么&#34;&gt;1、Dubbo 是什么？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Dubbo（阿里巴巴公司开源分布式服务框架）是一个分布式、高性能、透明化的&lt;strong&gt;RPC服务框架&lt;/strong&gt;，提供服务自动注册、自动发现等高效服务治理方案，可以和Spring框架无缝集成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-为什么要用-dubbo&#34;&gt;2、为什么要用 Dubbo？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;随着服务化的进一步发展，服务越来越多，服务之间的&lt;strong&gt;调用和依赖&lt;/strong&gt;关系也越来越复杂，诞生了&lt;strong&gt;面向服务的架构体系（SOA）&lt;/strong&gt;，&lt;br&gt;
因此也衍生了一系列相应的技术，如对服务提供、调用、发现、路由连接处理、通信协议、日志输出等行为进行&lt;strong&gt;封装的服务框架&lt;/strong&gt;，&lt;br&gt;
为&lt;strong&gt;分布式系统的服务治理框架&lt;/strong&gt;就出现了，Dubbo也就产生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3-dubbo-和-spring-cloud-有什么区别&#34;&gt;3、Dubbo 和 Spring Cloud 有什么区别？&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20201121104323617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;最大区别：Dubbo底层是使用&lt;strong&gt;Netty这样的NIO框架&lt;/strong&gt;，是&lt;strong&gt;基于TCP协议&lt;/strong&gt;传输的，&lt;strong&gt;配合以Hession序列化完成RPC&lt;/strong&gt;通信。&lt;br&gt;
而SpringCloud是基于&lt;strong&gt;Http协议+Rest接口调用远程过程&lt;/strong&gt;的通信，相对来说，Http请求会有更大的报文，占的带宽也会更多。但是Rest相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;4-dubbo-都支持什么协议推荐用哪种&#34;&gt;4、dubbo 都支持什么协议，推荐用哪种？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;dubbo(&lt;strong&gt;推荐&lt;/strong&gt;):单一长连接和NIO同步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议TCP 异步 Hessian序列化；&lt;/li&gt;
&lt;li&gt;rmi:采用JDK标准的rmi协议实现，传输参数和返回参数对象需要实现Serializable接口，使用java标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议TCP。  多个短连接，TCP协议传输，同步传输，适用常规的远程服务调用和rmi互操作。在依赖版本的Common-Collections包，java序列化存在安全漏洞；&lt;/li&gt;
&lt;li&gt;webservice:基于WebService的远程调用协议，继承CXF实现，提供和原生WebService的互操作。 多个短连接，基于HTTP传输 同步传输 适用于系统集成和跨语言调用；&lt;/li&gt;
&lt;li&gt;http:基于Http表单提交的远程调用协议，使用Spring的HttpInvoke实现。多个短连接，传输协议HTTP，传入参数大小混合，提供者个数多余消费者，需要给应用程序和浏览器JS调用；&lt;/li&gt;
&lt;li&gt;hessian:集成Hessian服务，基于HTTP通讯，采用Servlet暴露服务，Dubbo内嵌Jetty作为服务器时默认实现，提供与hession服务互操作。多个短连接，同步http传输，hessian序列化，传入参数较大，提供者大于消费者 提供者压力较大，可传文件；&lt;/li&gt;
&lt;li&gt;mamcache:基于memcached实现的RPC协议&lt;/li&gt;
&lt;li&gt;redis:基于redis实现的RPC协议&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;5-dubbo-需要-web-容器吗&#34;&gt;5、Dubbo 需要 Web 容器吗？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;不需要。如果硬要用Web容器，只会增加复杂性，也浪费资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;6-dubbo-内置了哪几种服务容器&#34;&gt;6、Dubbo 内置了哪几种服务容器？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Spring Container&lt;/li&gt;
&lt;li&gt;Jetty Container&lt;/li&gt;
&lt;li&gt;Log4j Container&lt;br&gt;
Doubble容器只是一个简单的Main方法，并加载一个简单的Spring容器，用于暴露服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;7-dubbo-里面有哪几种节点角色&#34;&gt;7、Dubbo 里面有哪几种节点角色？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;---------&lt;strong&gt;节点&lt;/strong&gt;     ------------ &lt;strong&gt;角色说明&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Provider------暴露服务的服务提供方&lt;/li&gt;
&lt;li&gt;Consumer------调用远程服务的服务消费方&lt;/li&gt;
&lt;li&gt;Register------服务注册与发现的注册中心&lt;/li&gt;
&lt;li&gt;Monitor------统计服务的调用次数和调用时间的监控中心&lt;/li&gt;
&lt;li&gt;Container------服务运行容器&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;8-画一画服务注册与发现的流程图&#34;&gt;8、画一画服务注册与发现的流程图&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;来自 Dubbo 官网&lt;/strong&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20201121151212974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;9-dubbo-默认使用什么注册中心还有别的选择吗&#34;&gt;9、Dubbo 默认使用什么注册中心，还有别的选择吗？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;采用&lt;strong&gt;Zookeeper&lt;/strong&gt;作为注册中心，还有Redis、Multicast、Simple注册中心 但不推荐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;10-dubbo-有哪几种配置方式&#34;&gt;10、Dubbo 有哪几种配置方式？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1.Spring配置方式&lt;br&gt;
2.Java API配置方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;11-dubbo-核心的配置有哪些&#34;&gt;11、Dubbo 核心的配置有哪些？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;------ &lt;strong&gt;配置&lt;/strong&gt;------ -------------&lt;strong&gt;配置说明&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dubbo:service------服务配置&lt;/li&gt;
&lt;li&gt;dubbo:reference------引用配置&lt;/li&gt;
&lt;li&gt;dubbo:protocol------协议配置&lt;/li&gt;
&lt;li&gt;dubbo:application------应用配置&lt;/li&gt;
&lt;li&gt;dubbo:module------模块配置&lt;/li&gt;
&lt;li&gt;dubbo:register------注册中心配置&lt;/li&gt;
&lt;li&gt;dubbo:monitor------监控中心配置&lt;/li&gt;
&lt;li&gt;dubbo:provider------提供方配置&lt;/li&gt;
&lt;li&gt;dubbo:method------方法配置&lt;/li&gt;
&lt;li&gt;dubbo:argument------参数配置&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;配置间的关系&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201124191635515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;12-在-provider-上可以配置的-consumer-端的属性有哪些&#34;&gt;12、在 Provider 上可以配置的 Consumer 端的属性有哪些？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;timeout------方法调用超时&lt;/li&gt;
&lt;li&gt;retries------失败重试次数，默认重试2次&lt;/li&gt;
&lt;li&gt;loadbalance------负载均衡算法，默认是随机&lt;/li&gt;
&lt;li&gt;actives------消费者端，最大并发调用限制&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;13-dubbo-启动时如果依赖的服务不可用会怎样&#34;&gt;13、Dubbo 启动时如果依赖的服务不可用会怎样？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Dubbo缺省会在&lt;strong&gt;启动时&lt;/strong&gt;检查依赖的服务是否可用，不可用时会抛出异常，阻止spring初始化完成，默认&lt;strong&gt;check=&amp;quot;true&amp;quot;&lt;/strong&gt;,可以通过**check=&amp;quot;false&amp;quot;**关闭检查&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;14-dubbo-推荐使用什么序列化框架你知道的还有哪些&#34;&gt;14、Dubbo 推荐使用什么序列化框架，你知道的还有哪些？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;推荐使用&lt;strong&gt;Hessian序列化&lt;/strong&gt;，还有Duddo、FastJson、Java自带序列化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;15-dubbo-默认使用的是什么通信框架还有别的选择吗&#34;&gt;15、Dubbo 默认使用的是什么通信框架，还有别的选择吗？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Dubbo&lt;strong&gt;默认使用Netty框架&lt;/strong&gt;，也是推荐的选择，另外内容还有集成有Mina、Grizzly&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;16-dubbo-有哪几种集群容错方案默认是哪种&#34;&gt;16、Dubbo 有哪几种集群容错方案，默认是哪种？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;默认是Failover Cluster集群容错方案；&lt;/strong&gt;&lt;br&gt;
.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Failover  Cluster&lt;/strong&gt; 失败自动切换，当出现失败，重启其它服务器。通常用于&lt;strong&gt;读操作&lt;/strong&gt;，但重试会带来更长延迟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Failfast Cluster&lt;/strong&gt; 快熟失败，只发起一次调用，失败立即报错。通常用于&lt;strong&gt;非幂等性的写操作&lt;/strong&gt;，比如新增记录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Failsafe Cluster&lt;/strong&gt; 失败安全，出现异常时，直接忽略。通常用于&lt;strong&gt;写入审计日志&lt;/strong&gt;等操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Failback Cluster&lt;/strong&gt; 失败自动恢复，后台记录失败请求，定时重发。通常用于&lt;strong&gt;消息通知&lt;/strong&gt;操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Forking Cluster&lt;/strong&gt; 并行调用多个服务器，只要一个成功即返回。通常用于&lt;strong&gt;实时性要求较高的读操作&lt;/strong&gt;，但需要浪费更多服务资源。可通过forks=&amp;quot;2&amp;quot;来设置最大并行数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Broadcast Cluster&lt;/strong&gt; 广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者&lt;strong&gt;更新缓存或日志等本地资源&lt;/strong&gt;信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;17-dubbo-有哪几种负载均衡策略默认是哪种&#34;&gt;17、Dubbo 有哪几种负载均衡策略，默认是哪种？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Random LoadBalance------随机，按权重设置随机概率（&lt;strong&gt;默认&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;RoundRobin LoadBalance------轮询，按公约后的权重设置轮询比率&lt;/li&gt;
&lt;li&gt;LeastActive LoadBalance------最少活跃调用数。相同活跃数的随机&lt;/li&gt;
&lt;li&gt;ConsistentHash LoadBalance------一致性Hash,相同参数的请求总是发到同一提供者&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;18-注册了多个同一样的服务如果测试指定的某一个服务呢&#34;&gt;18、注册了多个同一样的服务，如果测试指定的某一个服务呢？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;可以配置环境&lt;strong&gt;点对点直连&lt;/strong&gt;，绕过注册中心，将&lt;strong&gt;以服务接口为单位&lt;/strong&gt;，忽略注册中心的提供者列表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;19-dubbo-支持服务多协议吗&#34;&gt;19、Dubbo 支持服务多协议吗？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;允许配置多协议，在不同服上支持不同协议或者同一服务上同时支持多种协议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;20-当一个服务接口有多种实现时怎么做&#34;&gt;20、当一个服务接口有多种实现时怎么做？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;可以用&lt;strong&gt;group属性&lt;/strong&gt;来分组，服务提供方和消费方都指定同一个group即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;21-服务上线怎么兼容旧版本&#34;&gt;21、服务上线怎么兼容旧版本？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;可以用&lt;strong&gt;版本号（version）过度&lt;/strong&gt;。多个不同版本的服务注册到注册中心，版本号不同的服务相互不引用。这个和服务分组的概念有点类似。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;22-dubbo-可以对结果进行缓存吗&#34;&gt;22、Dubbo 可以对结果进行缓存吗？&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//为了提高数据访问速度。Dubbo提供了声明式缓存，以减少用户加缓存的工作量
&amp;lt;dubbo:reference cache=&amp;quot;true&amp;quot;/&amp;gt;
//其实比普通的配置文件多了一个标签cache=&amp;quot;true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-dubbo-服务之间的调用是阻塞的吗&#34;&gt;23、Dubbo 服务之间的调用是阻塞的吗？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;默认是同步等待结果阻塞，支持异步调用&lt;/strong&gt;。&lt;br&gt;
Dubbo是基于&lt;strong&gt;NIO的非阻塞实现并行&lt;/strong&gt;调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个&lt;strong&gt;Future对象&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;异步调用流程图&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201124200559629.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;24-dubbo-支持分布式事务吗&#34;&gt;24、Dubbo 支持分布式事务吗？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;目前暂时不支持，可与通过tcc-transaction框架实现&lt;/strong&gt;&lt;br&gt;
tcc-transaction是开源的TCC补偿性分布式事务框架， tcc-transaction通过Dubbo&lt;strong&gt;隐式传参&lt;/strong&gt;的功能，避免自己对业务代码的入侵。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;25-dubbo-telnet-命令能做什么&#34;&gt;25、Dubbo telnet 命令能做什么？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;dubbo通过telnet命令来进行服务治理，具体可以参考&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247483709&amp;amp;idx=1&amp;amp;sn=afe0688c184f00902529583a85d90089&amp;amp;scene=21#wechat_redirect&#34;&gt;dubbo服务调试管理实用命令&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;telnet localhost 8090
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;26-dubbo-支持服务降级吗&#34;&gt;26、Dubbo 支持服务降级吗？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;以通过dubbo:reference中设置 &lt;strong&gt;mock=&amp;quot;return null&amp;quot;&lt;/strong&gt;。mock的值也可以修改为true，然后在跟接口同一个路径下实现一个Mock类， 命名规则是 “&lt;strong&gt;接口名称+Mock&lt;/strong&gt;”后缀。然后在Mock类里实现自己的降级逻辑。&lt;br&gt;
&lt;s&gt;Dubbo 2.2.0 以上版本支持。&lt;/s&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;27-dubbo-如何优雅停机&#34;&gt;27、Dubbo 如何优雅停机？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Dubbo是通过&lt;strong&gt;JDK的shutdownHook&lt;/strong&gt;来完成优雅停机的，所以如果使用 kill -9 pid 等强制关闭指令，是不会执行优雅停机的，只有通过&lt;strong&gt;kill pid&lt;/strong&gt; 时，才会执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;28-服务提供者能实现失效踢出是什么原理&#34;&gt;28、服务提供者能实现失效踢出是什么原理？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;服务失效踢出基于&lt;strong&gt;Zookeeper的临时节点&lt;/strong&gt;原理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;29-如何解决服务调用链过长的问题&#34;&gt;29、如何解决服务调用链过长的问题？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Dubbo可以使用**Pinpoint****和Apache Skywalking(Incubator)**实现分布式服务追踪，当然还有其他更多方案；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;30-服务读写推荐的容错策略是怎样的&#34;&gt;30、服务读写推荐的容错策略是怎样的？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;读操作建议使用Failover失败自动切换，默认重试两次其他服务器；&lt;/li&gt;
&lt;li&gt;写操作建议使用Failfast快速失败，发一次调用失败就立即报错；&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;31-dubbo-必须依赖的包有哪些&#34;&gt;31、Dubbo 必须依赖的包有哪些？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Dubbo必须依赖&lt;strong&gt;JDK&lt;/strong&gt;，其它为可选。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;32-dubbo-的管理控制台能做什么&#34;&gt;32、Dubbo 的管理控制台能做什么？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;管理控制台主要包含：路由规则 动态配置 服务降级 访问控制 权重调整 负载均衡，等管理功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;33-说说-dubbo-服务暴露的过程&#34;&gt;33、说说 Dubbo 服务暴露的过程。&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Dubbo会在spring实例化完bean之后，再刷新容器最后一步发布ContextRefreshEvent事件的时候，通知实现了ApplicationListener的ServiceBean类进行回调onApplicationEvent事件方法，Dubbo会在这个方法调用中调用ServiceBean父类ServiceConfig的export方法，而该方法真正实现了服务的（异步或者非异步）发布。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;34-dubbo-停止维护了吗&#34;&gt;34、Dubbo 停止维护了吗？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;2014年开始停止维护过几年，17年开始重新维护，并进入Apache项目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;35-dubbo-和-dubbox-有什么区别&#34;&gt;35、Dubbo 和 Dubbox 有什么区别？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Dubbox是继Dubbo停止维护后，当当网基于dubbo做的一个扩展项目，如加了&lt;strong&gt;服务可Restful调用&lt;/strong&gt;，更新了开源组件等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;36-你还了解别的分布式框架吗&#34;&gt;36、你还了解别的分布式框架吗？&lt;/h3&gt;
&lt;p&gt;Spring cloud 、Facebook的Thrift、Twitter的Finagle等&lt;/p&gt;
&lt;h3 id=&#34;37-dubbo-能集成-spring-boot-吗&#34;&gt;37、Dubbo 能集成 Spring Boot 吗？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;可以的，项目地址如下：&lt;br&gt;
&lt;a href=&#34;https://github.com/apache/incubator-dubbo-spring-boot-project&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;38-在使用过程中都遇到了些什么问题&#34;&gt;38、在使用过程中都遇到了些什么问题？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在注册中心找不到对应的服务，检查service实现类是否添加了**@service注解&lt;strong&gt;无法连接到注册中心，检查&lt;/strong&gt;配置文件**中的对应的测试ip是否正确。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;Dubbo 的设计目的是为了满足高并发小数据量的 rpc 调用，在大数据量下的性能表现并不好，建议使用 rmi 或 http 协议。&lt;/s&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;39-你读过-dubbo-的源码吗&#34;&gt;39、你读过 Dubbo 的源码吗？&lt;/h3&gt;
&lt;p&gt;&lt;s&gt;要了解 Dubbo 就必须看其源码，了解其原理，花点时间看下吧，网上也有很多教程&lt;/s&gt;&lt;/p&gt;
&lt;h3 id=&#34;40-你觉得用-dubbo-好还是-spring-cloud-好&#34;&gt;40、你觉得用 Dubbo 好还是 Spring Cloud 好？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;扩展性的问题&lt;/strong&gt;，没有好坏，只有适合不和适合；我更倾向于使用Dubbo，spring cloud版本&lt;strong&gt;升级&lt;/strong&gt;太快，&lt;strong&gt;组件更新&lt;/strong&gt;替换太频繁，&lt;strong&gt;配置&lt;/strong&gt;太繁琐等等&lt;/p&gt;
&lt;/blockquote&gt;
">面试之Dubbo篇</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/mian-shi-zhi-nginxredis-pian/"" data-c="
          &lt;h3 id=&#34;1-请解释一下什么是-nginx&#34;&gt;1、请解释一下什么是 Nginx?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Nginx（&lt;strong&gt;C语言&lt;/strong&gt;开发）是一个&lt;strong&gt;高性能的HTTP和反向代理服务器&lt;/strong&gt;，也是【轻量级】web服务器，以及电子邮件（IMAP/POP3/SMTP）代理服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-请列举-nginx-的一些特性&#34;&gt;2、请列举 Nginx 的一些特性。&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;反向代理&lt;/strong&gt; 、L7负载均衡&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;嵌入式&lt;/strong&gt;Perl解释器；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态二进制&lt;/strong&gt;升级；&lt;/li&gt;
&lt;li&gt;可用于&lt;strong&gt;重新编写&lt;/strong&gt;URL，具有非常好的PCRE支持；&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3-请列举-nginx-和-apache-之间的不同点&#34;&gt;3、请列举 Nginx 和 Apache 之间的不同点。&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1.最核心区别在于Apache是同步多进程模型，一个连接对应一个进程；   nginx是异步的，多个连接（万级别）可以对应一个进程；&lt;br&gt;
2.nginx的负载能力比Apache高很多。&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201126131453788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;4-使用反向代理服务器的优点是什么&#34;&gt;4、使用“反向代理服务器”的优点是什么?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;反向代理服务器可以&lt;strong&gt;隐藏源服务器的存在和特征&lt;/strong&gt;。它充当&lt;strong&gt;互联网和web服务器&lt;/strong&gt;之间的&lt;strong&gt;中间层&lt;/strong&gt;。这对于安全方面来说是很好的，特别是当你使用web托管服务时；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;5-请解释你如何通过不同于-80-的端口开启-nginx&#34;&gt;5、请解释你如何通过不同于 80 的端口开启 Nginx?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;为了通过一个不同的端口开启nginx,你必须进入 &lt;strong&gt;/etc/Nginx/sites-enables/&lt;/strong&gt;  ，如果这是默认文件，那么你必须打开名为  &lt;strong&gt;default&lt;/strong&gt; 的文件。编辑文件，并放置在你想要的端口：    &lt;strong&gt;Like server{listen 81;}&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;6-负载均衡描述一下&#34;&gt;6、负载均衡描述一下？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;负载均衡即是代理服务器将接收的请求&lt;strong&gt;均衡的分发&lt;/strong&gt;到各服务器中，&lt;br&gt;
负载均衡主要解决&lt;strong&gt;网络拥堵&lt;/strong&gt;问题，提高服务器&lt;strong&gt;响应速度&lt;/strong&gt;，服务&lt;strong&gt;就近提供&lt;/strong&gt;，达到更好的访问质量，减少后台服务器大并发压力&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;7-解释一下正向代理和反向代理&#34;&gt;7、解释一下正向代理和反向代理&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;正向代理：&lt;br&gt;
一个位于&lt;strong&gt;客户端和原始服务器（&lt;strong&gt;origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。&lt;br&gt;
总结：  代理端代理的是&lt;/strong&gt;客户端&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;反向代理&lt;br&gt;
反向代理（reverse proxy）方式是指以&lt;strong&gt;代理服务器来接受internet上的连接请&lt;/strong&gt;求，然后将请求发给内部网络上的服务器，&lt;br&gt;
并将服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器；&lt;br&gt;
总结：代理端代理的是&lt;strong&gt;服务端&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;8-为什么不使用多线程为什么-nginx-性能这么高&#34;&gt;8、为什么不使用多线程？为什么 Nginx 性能这么高？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Apache：&lt;br&gt;
创建&lt;strong&gt;多个进程或线程&lt;/strong&gt;，而每个进程或线程都会为其分配cpu和内存（&lt;strong&gt;线程要比进程小的多&lt;/strong&gt;，所以worker支持比perfork高的并发），并发过大会榨干服务器资源；&lt;br&gt;
Nginx:&lt;br&gt;
采用&lt;strong&gt;单线程来异步非阻塞处理请求&lt;/strong&gt;（管理员可以配置Nginx主进程的工作进程的数量）（epoll），&lt;strong&gt;不会为每个请求分配cpu和内存资源&lt;/strong&gt;，节省了大量资源，同时也减少了大量的cpu的上下文切换。所以才使得nginx支持更高的并发；&lt;br&gt;
&lt;strong&gt;异步非阻塞事件处理机制&lt;/strong&gt;：运用了&lt;strong&gt;epoll模型&lt;/strong&gt;，提供了一个&lt;strong&gt;队列&lt;/strong&gt;，排队解决&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;9-为什么要用-nginx&#34;&gt;9、为什么要用 Nginx？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;跨平台、配置简单&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非阻塞、高并发连接&lt;/strong&gt;：处理2-3万并发连接数，官方监测能支持5万并发；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存消耗小&lt;/strong&gt;：开启10个nginx才占150M内存，nginx采取了分阶段资源分配技术&lt;/li&gt;
&lt;li&gt;nginx处理&lt;strong&gt;静态文件&lt;/strong&gt;好，耗费内存少；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内置的健康检查&lt;/strong&gt;功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其它的节点上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节省宽带&lt;/strong&gt;： 支持GZIP压缩，可以添加浏览器本地缓存；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;稳定性高&lt;/strong&gt;：宕机概率非常小&lt;/li&gt;
&lt;li&gt;master/worker结构：一个&lt;strong&gt;master&lt;/strong&gt;进程，生成一个或多个&lt;strong&gt;worker&lt;/strong&gt;进程；&lt;/li&gt;
&lt;li&gt;接受用户请求是&lt;strong&gt;异步的&lt;/strong&gt;：浏览器将请求发送到nginx服务器，它先将用户请求&lt;strong&gt;全部接收&lt;/strong&gt;下来，再&lt;strong&gt;一次性发给后端&lt;/strong&gt;web服务器，极大减轻了web服务器的压力；&lt;/li&gt;
&lt;li&gt;一边&lt;strong&gt;接收&lt;/strong&gt;web服务器的返回数据，一边发送给浏览器客户端;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络依赖性&lt;/strong&gt;比较低，只要ping同就可以负载均衡;&lt;/li&gt;
&lt;li&gt;可以有多台&lt;strong&gt;nginx服务器&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;事件驱动：通信机制采用&lt;strong&gt;epoll模型；&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;10-redis-支持的数据类型&#34;&gt;10、Redis 支持的数据类型？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;String字符串：&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;11-什么是-redis-持久化redis-有哪几种持久化方式优缺点是什么&#34;&gt;11、什么是 Redis 持久化？Redis 有哪几种持久化方式？优缺点是什么？&lt;/h3&gt;
&lt;h3 id=&#34;12-使用过-redis-分布式锁么它是怎么实现的如果在-setnx-之后执行-expire-之前进程意外-crash-或者要重启维护了那会怎么样&#34;&gt;12、使用过 Redis 分布式锁么，它是怎么实现的？如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？&lt;/h3&gt;
&lt;h3 id=&#34;13-什么是缓存穿透如何避免什么是缓存雪崩何如避免&#34;&gt;13、什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？&lt;/h3&gt;
&lt;h3 id=&#34;14-什么是-redis简述它的优缺点&#34;&gt;14、什么是 Redis？简述它的优缺点？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;redis(Remote Dictionary Server) 是一个使用&lt;strong&gt;C语言&lt;/strong&gt;编写的，&lt;strong&gt;开源的&lt;/strong&gt;（BSD许可）&lt;strong&gt;高性能****非关系型&lt;/strong&gt;（NOSQL）的&lt;strong&gt;键值对数据库&lt;/strong&gt;；&lt;br&gt;
redis可以存储键和5种不同类型的值之间的映射。键的类型只能为&lt;strong&gt;字符串&lt;/strong&gt;，值支持5种数据类型：&lt;strong&gt;字符串--列表--散列表--集合--有序集合&lt;/strong&gt;；&lt;br&gt;
&lt;s&gt;与传统数据库不同的是redis的数据时存在&lt;strong&gt;内存中&lt;/strong&gt;的，所以读的写速度非常快，因此redis被广泛应用于&lt;strong&gt;缓存&lt;/strong&gt;方向，每秒可以处理超过&lt;strong&gt;10万次读写&lt;/strong&gt;操作，是已知性能最快的key-value DB。另外，redis也经常用来做&lt;strong&gt;分布式锁&lt;/strong&gt;。除此之外，redi&lt;strong&gt;s支持事务、持久化、LUA脚本吗、LRU驱动事件、多种集群方案&lt;/strong&gt;。&lt;/s&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;读写性能&lt;/strong&gt;优异，redis能读的速度是110000次/S，写的速度是81000次/秒；&lt;/li&gt;
&lt;li&gt;支持&lt;strong&gt;数据持久化&lt;/strong&gt;，支持AOF和RDB良种持久化方式；&lt;/li&gt;
&lt;li&gt;支持&lt;strong&gt;事务&lt;/strong&gt;，redis的所有操作都是原子性的，同时redis还支持对几个操作合并后的原子性执行；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据结构&lt;/strong&gt;丰富， 除了支持string（字符串）类型的value外还支持hash（散列表）、set（集合）、 zset（有序集合）、list（列表）等数据结构；&lt;/li&gt;
&lt;li&gt;支持&lt;strong&gt;主从复制&lt;/strong&gt;，主机会自动将数据同步到从机，可以进行&lt;strong&gt;读写分离&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库容量受到&lt;strong&gt;物理内存的限制&lt;/strong&gt;，不能用作海量数据的高性能读写，因此redis适合的场景主要局限在&lt;strong&gt;较小数据量的高性能操作和运算上&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;redis&lt;strong&gt;不具备自动容错和恢复功能&lt;/strong&gt;，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或手动切换前端的ip才能恢复；&lt;/li&gt;
&lt;li&gt;主机宕机，宕机前有部分数据未能及时同步到从机，切换ip还会引入&lt;strong&gt;数据不一致&lt;/strong&gt;的问题，降低了系统可用性；&lt;/li&gt;
&lt;li&gt;redis&lt;strong&gt;较难支持在线扩容&lt;/strong&gt;，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;15-redis-相比-memcached-有哪些优势&#34;&gt;15、Redis 相比 memcached 有哪些优势？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;memcached所有的值均是简单的&lt;strong&gt;字符串&lt;/strong&gt;，redis作为替代者，支持更为&lt;strong&gt;丰富的数据类型&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;redis的&lt;strong&gt;速度&lt;/strong&gt;比memcached快很多&lt;/li&gt;
&lt;li&gt;redis可以&lt;strong&gt;持久化&lt;/strong&gt;其数据；&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;16-redis-官方为什么不提供-windows-版本&#34;&gt;16、Redis 官方为什么不提供 Windows 版本？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;因为目前Linux版本已经相当&lt;strong&gt;稳定&lt;/strong&gt;，而且&lt;strong&gt;用户量很大&lt;/strong&gt;，无需开发windows版本，反而会带来兼容性等问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;17-一个字符串类型的值能存储最大容量是多少&#34;&gt;17、一个字符串类型的值能存储最大容量是多少？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;512M&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;18-为什么-redis-需要把所有数据放到内存中&#34;&gt;18、为什么 Redis 需要把所有数据放到内存中？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;为了达到最快的&lt;strong&gt;读写速度&lt;/strong&gt;将数据都读到内存中，并通过&lt;strong&gt;异步的方式&lt;/strong&gt;将数据写入磁盘。所以redis&lt;strong&gt;具有快速和数据持久化&lt;/strong&gt;的特性。&lt;br&gt;
&lt;s&gt;如果不将数据放到内存中，磁盘的I/O速度会严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。如果设置里&lt;strong&gt;最大使用的内存&lt;/strong&gt;，则数据已有记录数达到内存限值后将不能继续插入新值；&lt;/s&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;19-redis-有哪些适合的场景&#34;&gt;19、Redis 有哪些适合的场景？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;会话缓存（session cache）用redis缓存会话比其他存储（如memcached）的优势在于：redis提供&lt;strong&gt;持久化&lt;/strong&gt;。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都不会高兴。&lt;/li&gt;
&lt;li&gt;全页缓存（&lt;strong&gt;FPC&lt;/strong&gt;）：除基本的会话token之外，redis还提供很简便的FPC平台；&lt;/li&gt;
&lt;li&gt;队列：redis在&lt;strong&gt;内存存储引擎领域&lt;/strong&gt;的一大优点是提供&lt;strong&gt;list和set操作&lt;/strong&gt;，这使得redis能作为一个很好&lt;strong&gt;的消息队列平台使用&lt;/strong&gt;。redis作为队列使用的操作，就类似于本地程序语言对list的push/pop操作；&lt;/li&gt;
&lt;li&gt;排行榜/计数器：redis在内存中对数据进行&lt;strong&gt;递增递减&lt;/strong&gt;的操作实现的非常好。**集合（set）和有序集合（sorted Set）**也使得我们在执行这些操作的时候变得非常简单，redis只是正好提供了这两种数据结构&lt;/li&gt;
&lt;li&gt;订阅/发布&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;20-redis-如何做内存优化&#34;&gt;20、Redis 如何做内存优化？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;可以好好利用Hash，list,sorted,set等集合类型数据，因为通常情况下很多小的key-value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以应尽可能的将数据模型抽象到散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称 姓氏 邮箱 密码设置单独的key，而是应该 把这个用户的所有信息&lt;strong&gt;存储到一张散列表里面&lt;/strong&gt;；&lt;/p&gt;
&lt;/blockquote&gt;
">面试之Nginx、Redis篇</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/mian-shi-zhong-chang-jian-wen-ti-hui-ji/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;大家好，我是Java初学者，来CSDN主要也是为了学习知识。在个人博客中主要记录一些个人笔记、总结、学习心得等，如有不足之处请纠正，欢迎补充。——来自 菜鸟的蜕变&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-8759343&#34;&gt; &lt;em&gt;持续更新...&lt;/em&gt;&lt;br&gt;
&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80-mysql%E4%B8%8Eoracle%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;一、MySql与Oracle的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C-list%E4%B8%8Ehashmap%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0&#34;&gt;二、List与HashMap底层的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89-%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81&#34;&gt;三、乐观锁与悲观锁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B-synchronized%E4%B8%8Elock%E5%8C%BA%E5%88%AB&#34;&gt;四、synchronized与lock区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94-ioniobioaio%E5%8C%BA%E5%88%AB&#34;&gt;五、IO,NIO,BIO,AIO区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AD-jsp%E5%92%8Cservlet%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8&#34;&gt;六、jsp和servlet的过滤器和拦截器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%83-spring%E6%A1%86%E6%9E%B6%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1&#34;&gt;七、Spring框架里如何实现事务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AB-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81sql&#34;&gt;八、如何实现动态sql&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B9%9D-mybatis%E4%B8%8Ejdbc%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86&#34;&gt;九、Mybatis与JDBC底层工作原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81-springboot2x%E4%B8%8E1x%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB&#34;&gt;十、SpringBoot2.x与1.x的一些区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%B8%80-springboot%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0&#34;&gt;十一、SpringBoot常见的注解及其底层实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%BA%8C-spring%E4%B8%ADdi%E4%B8%8Eioc%E5%8E%9F%E7%90%86&#34;&gt;十二、Spring中DI与IOC原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%B8%89-jdk18%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7&#34;&gt;十三、JDK1.8的新特性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E5%9B%9B-js%E5%BC%95%E5%85%A5%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BA%8B%E4%BB%B6&#34;&gt;十四、JS引入以及常见事件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%BA%94-vue%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E4%BA%8B%E4%BB%B6&#34;&gt;十五、VUE的理解及其事件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E5%85%AD-sql%E8%AF%AD%E5%8F%A5%E6%9C%AC%E8%BA%AB%E7%9A%84%E4%BC%98%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9&#34;&gt;十六、sql语句本身的优化以及创建表的注意事项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%B8%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%B4%A2%E5%BC%95&#34;&gt;十七、数据库的索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E5%85%AB-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB&#34;&gt;十八、数据库的事务与隔离级别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%B9%9D-%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%BD%AC%E5%8F%91%E5%8C%BA%E5%88%AB%E6%A1%86%E6%9E%B6%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0&#34;&gt;十九、重定向与转发区别（框架里如何实现）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81-%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E6%8A%80%E6%9C%AFcookie-session&#34;&gt;二十、会话跟踪技术（cookie  session...）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E4%B8%80-%E6%89%80%E4%BA%86%E8%A7%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86iso%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B&#34;&gt;二十一、所了解的网络知识（ISO七层模型...）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E4%BA%8C-tcp%E4%B8%8Eudp%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;二十二、TCP与UDP的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E4%B8%89-http%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%90%86%E8%A7%A3&#34;&gt;二十三、HTTP协议的理解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-8759343&#34;&gt; *持续更新...*
@[TOC](目录： )&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一-mysql与oracle的区别&#34;&gt;一、MySql与Oracle的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;并发性&lt;br&gt;
MySQL:&lt;br&gt;
MySQL以表级锁为主，对资源锁定的粒度很大，如果一个session对一个表加锁时间过长，会让其他session无法更新此表中的数据。&lt;br&gt;
虽然InnoDB引擎的表可以用行级锁，但这个行级锁的机制依赖于表的索引，如果表没有索引或sql语句未使用索引，仍然会使用表级锁。&lt;br&gt;
Oracle:&lt;br&gt;
Oracle使用行级锁，对资源锁定的粒度要小很多，只是锁定sql需要的资源，并且加锁是在数据中心的数据行上，不依赖于索引。所以Oracle对并发性的支持要好很多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务的提交&lt;br&gt;
MySQL默认自动提交，而Oracle默认不自动提交--需用户手动提交，需要在写commit，指令或点击commit按钮。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务隔离级别&lt;br&gt;
MySQL是read commited的隔离级别，而Oracle是repeatable read的隔离级别，二者都支持serializable串行化事务隔离级别，可以实现最高级别的读一致。&lt;br&gt;
每个session提交后其他session才能看到提交的更改。&lt;br&gt;
Oracle通过在undo表空间中构造多版本数据来实现读一致，每个session查询时，如对应数据块发生变化，Oracle会在undo表空间中为这个session构造它查询时的旧的数据块；&lt;br&gt;
MySQL没有雷士Oracle的构造多版本数据块的机制，只支持read commited的隔离级别。一个session读取数据时，其他session不能更改数据，但可以在表最后插入数据。session更新数据时要加上排它锁，其他session无法访问数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分页查询&lt;br&gt;
MySQL是直接在SQL语句中写  &amp;quot;select xxx from xxx where xxx limit x,y&amp;quot;  ，有limit就可以实现分页；而Oracle则是需要用伪列ROWNUM和嵌套查询。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务支持&lt;br&gt;
MySQL在innodb存储引擎的行级锁的情况下才可支持事务，而Oracle则完全支持事务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;持久性&lt;br&gt;
MySQL在数据库更新或重启，会丢失数据，而Oracle会把提交的SQL操作线写入在线联机日志文件中，保存到磁盘上 可随时恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑备份&lt;br&gt;
MySQL（逻辑）备份时要锁定数据才能保证备份的数据是一致的，影响业务正常的DML使用，而Oracle备份时不需锁定数据且备份的数据是一致的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;管理工具&lt;br&gt;
MySQL管理工具较少，在linux下的管理工具的安装有时还需装额外的包（phpmyadmin ...），有些复杂；&lt;br&gt;
Oracle有多种成熟命令行、图形界面、web管理工具，还有其他第三方管理工具，管理方便且高效。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;权限与安全&lt;br&gt;
MySQL的用户与主机有关，容易被仿冒主机及IP有可乘之机；&lt;br&gt;
Oracle则较为传统，中规中矩。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分区表与分区索引&lt;br&gt;
MySQL不太成熟稳定，Oracle则很成熟，可提高用户访问DB的体验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性能诊断&lt;br&gt;
MySQL诊断调优方法较少，主要有慢查询日志；&lt;br&gt;
Oracle则有各种陈述的诊断调优工具，能实现多自动分析、诊断功能。如：awr、&lt;br&gt;
addm、sqltrace、tkproof等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复制&lt;br&gt;
MySQL复制服务器配置简单，但主库出现问题时 从库有可能丢失一定数据，且需要手动切换从库到主库；&lt;br&gt;
Oracle既有推和拉式的传统数据复制，也有dataguard的双机或多级容灾机制，主库出现问题时 可自动切换备库到主库，但配置管理复杂。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他&lt;br&gt;
MySQL是轻量级数据库-免费，没有服务恢复数据；&lt;br&gt;
Oracle重量型数据库-收费，Oracle公司对Oracle数据库有任何服务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;二-list与hashmap底层的实现&#34;&gt;二、List与HashMap底层的实现&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;List&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;List实现Collection接口，它的数据结构是有序可以重复的结合，该结合的体系有索引；它有三个实现类：ArrayList、LinkList、Vector三个实现类；&lt;br&gt;
三个实现类的区别：&lt;br&gt;
ArrayList:底层数据结构使数组结构，查询速度快，增删改慢，&lt;br&gt;
LinkList:底层使用链表结构，增删速度快，查询稍慢；&lt;br&gt;
Vector：底层是数组结构，线程同步ArrayList是线程不同步；&lt;br&gt;
可变长度数组不断new数组：&lt;br&gt;
ArrayList当初始化容量超过10时，会new一个50%de ,把原来的东西放入这150%中；&lt;br&gt;
Vector：当容量超过10时，会new一个100%的浪费内存；&lt;/p&gt;
&lt;p&gt;List接口对Collection进行了简单的扩充，它的具体实现类常用的有ArrayList和LinkedList。你可以将任何东西放到一个List容器中，并在需要时从中取出。ArrayList从其命名中可以看出它是一种类似数组的形式进行存储，因此它的随机访问速度极快，而LinkedList的内部实现是链表，它适合于在链表中间需要频繁进行插入和删除操作。在具体应用时可以根据需要自由选择。前面说的Iterator只能对容器进行向前遍历，而ListIterator则继承了Iterator的思想，并提供了对List进行双向遍历的方法。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;HashMap底层实现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许重复的键。Map接口有两个基本的实现，HashMap和TreeMap。TreeMap保存了对象的排列次序，而HashMap则不能。HashMap允许键和值为null。HashMap是非synchronized的，但collection框架提供方法能保证HashMap synchronized，这样多个线程同时访问HashMap时，能保证只有一个线程更改Map。&lt;br&gt;
构造方法:&lt;br&gt;
HashMap提供了四个构造方法，构造方法中，依靠第三个方法来执行的，但是前三个方法都没有进行数组的初始化操作，即使调用了构造方法此时存放HaspMap中数组元素的table表长度依旧为0 。在第四个构造方法中调用了inflateTable()方法完成了table的初始化操作，并将m中的元素添加到HashMap中。&lt;br&gt;
HashMap的工作原理 ：HashMap是基于散列法（又称哈希法hashing）的原理，使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。&lt;br&gt;
当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket（桶）位置来储存Entry对象。”HashMap是在bucket中储存键对象和值对象，作为Map.Entry。并不是仅仅只在bucket中存储值&lt;/p&gt;
&lt;h2 id=&#34;三-乐观锁与悲观锁&#34;&gt;三、乐观锁与悲观锁&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;br&gt;
·悲观锁（Pessimistic Lock）：每次拿数据的时候都会担心会被别人修改（疑心重很悲观），所以每次在拿数据的时候都会&lt;strong&gt;上锁&lt;/strong&gt;。确保自己使用的过程中不会被别人访问，自己使用完后再解锁。&lt;br&gt;
期间需要访问该数据的都会等待。&lt;s&gt;（传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。）&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;·乐观锁（Optimistic Lock）：每次拿数据的时候都完全不担心会被别人修改（心态好很乐观），所以每次在拿数据的时候都&lt;strong&gt;不会上锁&lt;/strong&gt;。但是在更新数据的时候去判断该期间是否被别人修改过（使用版本号、CAS算法实现等机制），期间该数据可以随便被其他人读取。&lt;s&gt;（乐观锁&lt;strong&gt;适用于多读&lt;/strong&gt;的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。）&lt;/s&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用场景&lt;br&gt;
乐观锁适用于多读场景，即冲突很少发生的时候，这样可以省去锁的开销，加大系统的吞吐量；&lt;br&gt;
悲观锁适用于多写场景下，多写情况 一般会产生冲突，这就会导致上层应用汇不断进行retry，反而降低了性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;乐观锁常见的两种实现方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;乐观锁一般会使用版本号机制或CAS算法实现。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;版本号机制：&lt;br&gt;
在数据表中加上一个数据版本号version字段，表示数据	被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。&lt;br&gt;
&lt;em&gt;例：&lt;br&gt;
假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。&lt;br&gt;
操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。&lt;br&gt;
在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。&lt;br&gt;
操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。&lt;br&gt;
操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。&lt;br&gt;
这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;CAS算法(compare and swap——比较与交换)&lt;/p&gt;
&lt;p&gt;有名的无所算法，无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。涉及三个操作数：&lt;br&gt;
需要读写的内存值 V&lt;br&gt;
进行比较的值 A&lt;br&gt;
拟写入的新值 B&lt;br&gt;
当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;乐观锁的缺点&lt;br&gt;
ABA 问题（&lt;strong&gt;乐观锁常见问题&lt;/strong&gt;）&lt;br&gt;
如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 &amp;quot;ABA&amp;quot;问题。&lt;br&gt;
JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。&lt;br&gt;
循环时间长开销大&lt;br&gt;
自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。&lt;br&gt;
只能保证一个共享变量的原子操作&lt;br&gt;
CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CAS与synchronized的使用情景&lt;br&gt;
&lt;em&gt;&lt;strong&gt;简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。&lt;br&gt;
对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。&lt;br&gt;
&lt;s&gt;其它：Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。&lt;/s&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;四-synchronized与lock区别&#34;&gt;四、synchronized与lock区别&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20201030090249716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;实现层&lt;br&gt;
synchronized是Java关键字，JVM层面实现加锁和释放锁；Lock是一个接口，在代码层面实现加锁和释放锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法&lt;br&gt;
sychronized用在代码块和方法上；lock只能写在代码里，不能直接修改方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;释放锁&lt;br&gt;
sychronized在线程代码执行完或出现异常自动释放锁；Lock不自动释放，需要在finally{}代码块显示地中释放锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待&lt;br&gt;
sychronized会导致线程拿不到锁一直等待；Lock可以设置尝试获取锁或获取锁失败一定超时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通知&lt;br&gt;
sychronized无法得知是否获取锁成功；Lock可以通过tryLock获得锁是否成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功能复杂性&lt;br&gt;
sychronized加锁可重入、不可中断、非公平；&lt;br&gt;
Lock可重入、可判断、可公平和不公平、细分读写锁提高效率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;五-ioniobioaio区别&#34;&gt;五、IO,NIO,BIO,AIO区别&lt;/h2&gt;
&lt;p&gt;简单来说就是input和output流，IO流主要是用来处理设备之间的数据传输，Java IO对于数据的操作都是通过流实现的，而java用于操作流的对象都在IO包中。&lt;br&gt;
BIO：同步阻塞,服务器实现模式为一个连接一个线程, 适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中, ，JDK1.4以前的唯一选择，但程序直观简单易理解。&lt;br&gt;
NIO：同步非阻塞,服务器实现模式为一个请求一个线程, 适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。&lt;br&gt;
AIO：异步非阻塞,服务器实现模式为一个有效请求一个线程, 适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。&lt;/p&gt;
&lt;h2 id=&#34;六-jsp和servlet的过滤器和拦截器&#34;&gt;六、jsp和servlet的过滤器和拦截器&lt;/h2&gt;
&lt;p&gt;Jsp：JSP(Java Server Pages)是Sun 公司指定的一种服务器端动态页面技术的组件规范，Jsp是以“.jsp”为后缀的文件，在该文件中主要是html 和少量的java 代码。jsp 文件在容器中会转换成Servlet中执行。&lt;br&gt;
Servlet：Servlet (Server Applet)是Sun公司指定的一种用来扩展Web服务器功能的组件规范，属于服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。&lt;br&gt;
jsp就是在html里面写java代码，servlet就是在java里面写html&lt;br&gt;
过滤器和拦截器的区别：&lt;br&gt;
①拦截器是基于java的反射机制的，而过滤器是基于函数回调。&lt;br&gt;
②拦截器不依赖与servlet容器，过滤器依赖与servlet容器。&lt;br&gt;
③拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。&lt;br&gt;
④拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。&lt;br&gt;
⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。&lt;br&gt;
⑥拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。&lt;/p&gt;
&lt;h2 id=&#34;七-spring框架里如何实现事务&#34;&gt;七、Spring框架里如何实现事务&lt;/h2&gt;
&lt;p&gt;实现方式共有两种：&lt;strong&gt;声明式和编程式(事务操作的地方很少的时候)&lt;/strong&gt;；&lt;strong&gt;声明式事务管理&lt;/strong&gt;方式。&lt;br&gt;
基于AOP技术实现的声明式事务管理，实质就是：在方法执行前后进行拦截，然后在目标方法开始之前创建并加入事务，执行完目标方法后根据执行情况提交或回滚事务。&lt;br&gt;
声明式事务管理又有两种方式：基于XML配置文件的方式；另一个是在业务方法上进行@Transactional注解，将事务规则应用到业务逻辑中。&lt;/p&gt;
&lt;h2 id=&#34;八-如何实现动态sql&#34;&gt;八、如何实现动态sql&lt;/h2&gt;
&lt;p&gt;Mybatis动态sql可以在Xml映射文件内，以标签的形式编写动态sql&lt;br&gt;
Mybatis提供了9种动态sql标签：&lt;br&gt;
trim | where | set | foreach | if | choose | when | otherwise | bind。&lt;br&gt;
执行原理是根据表达式的值 完成逻辑判断并动态拼接sql的功能。&lt;/p&gt;
&lt;h2 id=&#34;九-mybatis与jdbc底层工作原理&#34;&gt;九、Mybatis与JDBC底层工作原理&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;mybatis的工作原理：&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
MyBatis是支持普通SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。&lt;br&gt;
MyBatis使用简单的XML或注解用于配置和原始映射，将接口和Java的POJOs（Plain Ordinary Java Objects，普通的 Java对象）映射成数据库中的记录。&lt;br&gt;
每个MyBatis应用程序主要都是使用SqlSessionFactory实例的，一个SqlSessionFactory实例可以通过SqlSessionFactoryBuilder获得。用xml文件构建SqlSessionFactory实例是非常简单的事情。&lt;br&gt;
推荐在这个配置中使用类路径资源，但可以使用任何Reader实例，包括用文件路径或file://开头的url创建的实例。MyBatis有一个实用类----Resources，它有很多方法，可以方便地从类路径及其它位置加载资源。&lt;br&gt;
&lt;em&gt;&lt;strong&gt;JDBC原理&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
Java数据库连接技术的简称。&lt;br&gt;
是一种用于执行SQL语句的JavaAPI，提供连接各种常用数据库的能力。&lt;br&gt;
1&amp;gt;加载驱动——-2&amp;gt;获取连接对象—–3&amp;gt;创建命令—–4&amp;gt;执行sql语句，并且返回结果集——5&amp;gt;处理结果集—–6&amp;gt;关闭连接&lt;/p&gt;
&lt;h2 id=&#34;十-springboot2x与1x的一些区别&#34;&gt;十、SpringBoot2.x与1.x的一些区别？&lt;/h2&gt;
&lt;p&gt;1.&lt;em&gt;配置变更&lt;/em&gt;&lt;br&gt;
2.&lt;em&gt;JDK版本&lt;/em&gt;升级：2.x至少需要JDK1.8的支持，2.x里面的许多方法应用了JDK8的许多高级新特性。&lt;br&gt;
3.&lt;em&gt;第三方库&lt;/em&gt;升级：响应式spring编程支持&lt;br&gt;
2.x通过启动器和自动配置全面支持Spring的相应编程，响应式编程是完全异步和非阻塞的，它是基于时间驱动模型，而不是传统的线程模型。就连Spring Boot内部叶对一些功能点进行了很必要的响应式升级，最值得注意的是对内嵌式容器的支持。&lt;br&gt;
4.&lt;em&gt;HTTP/2支持&lt;/em&gt;&lt;br&gt;
提供对HTTP/2的支持，如：Tomcat，undertow,jetty,这个得依赖具体选择得应用服务器和应用环境。&lt;br&gt;
5.&lt;em&gt;配置属性绑定&lt;/em&gt;&lt;br&gt;
在2.x中，配置绑定功能有一些改造，在调整了1.x中许多不一致地方外，还提供了独立注解之外得API来装配配置属性，并且增加了属性得来源。&lt;br&gt;
6.更多&lt;em&gt;改进和加强&lt;/em&gt;&lt;br&gt;
Gradle插件提供了一些重要得特性提升。&lt;br&gt;
Kotlin 2.x开始提供了runApplication函数来运行Spring Boot应用&lt;br&gt;
Actuator加强所有得HTTP执行端点现在都暴露在/actuator路径下，并对JSON结果集也做了改善&lt;br&gt;
Data支持上面有说到对响应式&lt;/p&gt;
&lt;h2 id=&#34;十一-springboot常见的注解及其底层实现&#34;&gt;十一、SpringBoot常见的注解及其底层实现&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;@SpringBootApplication&lt;/strong&gt;包含了@springBootConfiguration,(继承了@Configuration注解主要用于加载配置文件，二者的功能也一样，标志这个类是配置类，并会将当前类内申明的一个或多个以@Bean标志的方法的实例纳入到spring容器中，并且实列名就是方法名。)；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@EnableAutoConfiguration&lt;/strong&gt;可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，@EnableAutoConfiguration可以智能的自动配置功效才得以大功告成；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@componentScan&lt;/strong&gt;（@ComponentScan的功能其实就是自动扫描并加载符合条件的组件或bean定义，最终将这些bean定义加载到容器中。我们可以通过basePackages等属性指定@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现从声明@ComponentScan所在类的package进行扫描，默认情况下是不指定的，所以SpringBoot的启动类最好放在root package下。）；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Controller&lt;/strong&gt;——控制器，处理http请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@RestController&lt;/strong&gt;—— 复合注解，从源码我们知道,@RestController注解相当于@ResponseBody+@Controller合在一起的作用,RestController使用的效果是将方法返回的对象直接在浏览器上展示成json格式；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@RequestBody&lt;/strong&gt;通过HttpMessageConverter读取Request Body并反序列化为Object（泛指）对象；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@RequestMapping&lt;/strong&gt;&lt;br&gt;
@RequestMapping 是 Spring Web 应用程序中最常被用到的注解之一。这个注解会将 HTTP 请求映射到 MVC 和 REST 控制器的处理方法上；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@GetMapping&lt;/strong&gt;用于将HTTP get请求映射到特定处理程序的方法注解&lt;br&gt;
注解简写：@RequestMapping(value = &amp;quot;/say&amp;quot;,method = RequestMethod.GET)等价于：@GetMapping(value = &amp;quot;/say&amp;quot;)&lt;br&gt;
GetMapping源码是@RequestMapping(method = RequestMethod.GET)的缩写；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@PostMapping&lt;/strong&gt;用于将HTTP post请求映射到特定处理程序的方法注解&lt;br&gt;
是@RequestMapping(method = RequestMethod.POST)的缩写&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@PathVariable&lt;/strong&gt;:获取url中的数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//请求示例：
http://localhost:8080/User/getUser/123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;@RequestParam&lt;/strong&gt;:获取请求参数的值&lt;/p&gt;
&lt;h2 id=&#34;十二-spring中di与ioc原理&#34;&gt;十二、Spring中DI与IOC原理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;控制反转&lt;/strong&gt;IoC(Inversion of Control)即&lt;strong&gt;创建对象的控制权进行转移&lt;/strong&gt;，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IoC容器，它就是一个专门用来&lt;strong&gt;创建对象的工厂&lt;/strong&gt;，你要什么对象，它就给你什么对象，有了IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。&lt;br&gt;
&lt;strong&gt;DI&lt;/strong&gt;（Dependency Injection），即“依赖注入”：&lt;strong&gt;组件之间依赖关系&lt;/strong&gt;由容器在&lt;strong&gt;运行期&lt;/strong&gt;决定。&lt;/p&gt;
&lt;p&gt;IOC：&lt;br&gt;
DispatcherServlet在初始化init()的时候，会去创建ApplicationContext，在其构造实例化时加载配置文件，并解析文件封装成一个个BeanDefinition，然后将BeanDefinition一个个以key-value的形式缓存到一个集合Map中。之后在调用getBean()时，会根据全类名去刚刚缓存的集合里拿到对应的BeanDefinition，之后根据BeanDefinition创建真正的实例对象。之后spring进一步把创建好的实例对象封装成BeanWapper，在把BeanWapper保存到IOC容器中。&lt;br&gt;
DI:&lt;br&gt;
在调用 &lt;strong&gt;getBean&lt;/strong&gt; ( )时，才会执行依赖注入，利用 &lt;strong&gt;反射以及注解&lt;/strong&gt;对其进行依赖注入。&lt;/p&gt;
&lt;h2 id=&#34;十三-jdk18的新特性&#34;&gt;十三、JDK1.8的新特性&lt;/h2&gt;
&lt;p&gt;1.&lt;strong&gt;Lambda表达式&lt;/strong&gt;：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。&lt;br&gt;
2.&lt;strong&gt;方法引用&lt;/strong&gt;：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。&lt;br&gt;
3.&lt;strong&gt;默认方法&lt;/strong&gt;：默认方法就是一个在接口里面有了一个实现的方法。&lt;br&gt;
4.&lt;strong&gt;新工具&lt;/strong&gt;：新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。&lt;br&gt;
5.&lt;strong&gt;Stream API&lt;/strong&gt;：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。&lt;br&gt;
6.&lt;strong&gt;Date Time API&lt;/strong&gt;：加强对日期与时间的处理。&lt;br&gt;
7.&lt;strong&gt;Optional类&lt;/strong&gt;：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。&lt;br&gt;
8.&lt;strong&gt;Nashorn，JavaScript引擎&lt;/strong&gt;：JDK1.8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。&lt;/p&gt;
&lt;h2 id=&#34;十四-js引入以及常见事件&#34;&gt;十四、JS引入以及常见事件&lt;/h2&gt;
&lt;p&gt;①外部引用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//用script标签，链接外部的js文件
&amp;lt;script src=&amp;quot;main.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;②内部引用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//写在HTML文件内，用script标签包括
&amp;lt;head&amp;gt;
  &amp;lt;script&amp;gt;
    alert(&#39;Hello World!&#39;);
  &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;③行内引用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//写在HTML元素内部
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;按钮&amp;quot; onclick=&amp;quot;alert(&#39;Hello World&#39;)&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;常见事件：&lt;/strong&gt;&lt;br&gt;
点击事件（onclick）&lt;br&gt;
页面加载事件（onload）&lt;br&gt;
内容改变事件（onchange）：事件内容发生变化时&lt;br&gt;
聚焦事件（onfocus）&lt;br&gt;
失去焦点事件（onblur）&lt;br&gt;
窗口滚动事件（onscroll）&lt;br&gt;
表单提交事件（onsubmit）&lt;br&gt;
鼠标移动到某对象上方（Onmousemove）、鼠标离开某一对象	 （onmouseout）、鼠标移动到某个区域（onmouseover）&lt;br&gt;
鼠标按下事件（onmousedown）、鼠标松开事件（onmouseup）&lt;/p&gt;
&lt;h2 id=&#34;十五-vue的理解及其事件&#34;&gt;十五、VUE的理解及其事件&lt;/h2&gt;
&lt;p&gt;Vue是一套构建用户界面的渐进式框架,也可以理解为是一个视图模板引擎,强调的是状态到界面的映射。&lt;s&gt;开发人员将js代码分为了三个板块,数据(Model),逻辑控制(*),视图(View),数据板块只负责数据部分,视图板块负责更改样式,逻辑控制负责联系视图板块和数据板块,这样子有很大的好处,当需求发生变动时,只需要修改对应的板块就好&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//常见事件
   &amp;lt;!-- 方法处理器 --&amp;gt;
 &amp;lt;button v-on:click=&amp;quot;doThis&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;
 &amp;lt;!-- 缩写 --&amp;gt;
&amp;lt;button @click=&amp;quot;doThis&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;

 &amp;lt;!-- 内联语句 --&amp;gt;
&amp;lt;button v-on:click=&amp;quot;doThat(&#39;HelloWord&#39;, $event)&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;
 &amp;lt;!-- stop停止冒泡 --&amp;gt;
 &amp;lt;button @click.stop=&amp;quot;doThis&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;十六-sql语句本身的优化以及创建表的注意事项&#34;&gt;十六、sql语句本身的优化以及创建表的注意事项&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Sql语句优化：&lt;/strong&gt;&lt;br&gt;
（1）a. ORDER BY + LIMIT组合的索引优化;&lt;br&gt;
b. WHERE + ORDER BY + LIMIT组合的索引优化;&lt;br&gt;
c. WHERE+ORDER BY多个栏位+LIMIT&lt;br&gt;
(2）如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引&lt;br&gt;
(3)like语句优化&lt;br&gt;
(4)where子句使用 ！= 或 &amp;lt;&amp;gt; 操作符优化&lt;br&gt;
(5)where子句中使用 IS NULL 或 IS NOT NULL 的优化&lt;br&gt;
(6)where子句使用or的优化&lt;br&gt;
(7)where子句使用IN 或 NOT IN的优化(between替换in、exist替换in、left join替换in)&lt;br&gt;
(8)where子句中对字段进行表达式操作的优化&lt;br&gt;
（9）任何地方都不要用 select * from table，用具体的字段列表替换&amp;quot;*&amp;quot;，不要返回用不到的字段&lt;br&gt;
（10）使用“临时表”暂存中间结果&lt;br&gt;
（11）limit分页优化&lt;br&gt;
（12）批量插入优化&lt;br&gt;
（13）利用limit 1 、top 1 取得一行&lt;br&gt;
（14）尽量不要使用 BY RAND()命令&lt;br&gt;
（15）尽量用 union all 替换 union&lt;br&gt;
（16）避免类型转换：where子句中出现column字段的类型和传入的参数类型不一致的时候发生的类型转换&lt;br&gt;
（17）尽可能使用更小的字段&lt;br&gt;
（18）Inner join 和 left join、right join、子查询&lt;br&gt;
&lt;strong&gt;建表注意事项：&lt;/strong&gt;&lt;br&gt;
使用三大范式去设计表；&lt;br&gt;
树形结构的数据，通常采用自连接的方式；&lt;br&gt;
字典表设计结构参考，通常采用结构表来进行设计&lt;/p&gt;
&lt;h2 id=&#34;十七-数据库的索引&#34;&gt;十七、数据库的索引&lt;/h2&gt;
&lt;p&gt;索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都	以B-树的形式保存。mysql中主要有FULLTEXT(全文索引),HASH,BTREE,RTREE四种&lt;br&gt;
HASH：在in和“=”条件下可一次定位，效率高，但对于范围查询和排序及组合索引效率任然不高。&lt;br&gt;
BTREE:按一定算法将值存入属性结构中（二叉树），查询时依次遍历；&lt;br&gt;
RTREE：仅支持geometry数据类型&lt;br&gt;
&lt;strong&gt;索引类型:&lt;/strong&gt;&lt;br&gt;
普通索引：加速查询，允许插入重复值和空置&lt;br&gt;
唯一索引：加速查询，列值唯一&lt;br&gt;
主键索引:加速查询，列值唯一，且表中只有一个&lt;br&gt;
全文索引：在MyISAM引擎上使用只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，解决了模糊查询效率低的问题。&lt;br&gt;
组合索引：用于组合搜索，其效率大于索引合并。&lt;/p&gt;
&lt;h2 id=&#34;十八-数据库的事务与隔离级别&#34;&gt;十八、数据库的事务与隔离级别&lt;/h2&gt;
&lt;p&gt;数据库事务的四大&lt;strong&gt;特性&lt;/strong&gt;：&lt;br&gt;
原子性：要么全部成功，要么全部失败回滚；&lt;br&gt;
一致性：使数据库从一个一致性状态变换到另一个一致性状态；&lt;br&gt;
隔离性：两个用户操作同一张表时，互不干扰；&lt;br&gt;
持久性：事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201104005843861.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
脏读：一个事务处理过程中读取到另一个未提交的事务中的数据；&lt;br&gt;
不可重复度：一个事务读取了另一个已提交的事务中的数据；&lt;br&gt;
幻读：一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。&lt;/p&gt;
&lt;h2 id=&#34;十九-重定向与转发区别框架里如何实现&#34;&gt;十九、重定向与转发区别（框架里如何实现）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;区别：&lt;/strong&gt;&lt;br&gt;
1.请求重定向和请求转发都是web开发中资源跳转的方式。&lt;br&gt;
2.请求转发是服务器内部的跳转&lt;br&gt;
地址栏发生变化&lt;br&gt;
只有一个请求相应&lt;br&gt;
可以通过request域跳转目标的请求&lt;br&gt;
3.请求重定向是浏览器自动发起对跳转目标的请求&lt;br&gt;
地址栏会发生变化&lt;br&gt;
两次请求相应&lt;br&gt;
无法通过request域传递对象&lt;br&gt;
4.转发是服务器行为，重定向是客户端行为&lt;br&gt;
&lt;strong&gt;如何在框架里实现：&lt;/strong&gt;&lt;br&gt;
在SpringMVC框架中，控制处理器中处理方法的return语句默认就是转发实现，只不过实现的是转发到视图；&lt;br&gt;
在视图名称之前加上forward：完成转发&lt;br&gt;
return &amp;quot;forward:/index/isLogin&amp;quot;;&lt;br&gt;
在视图名称之前加上redirect: 完成重定向&lt;br&gt;
return &amp;quot;redirect:/index/isRegister&amp;quot;;&lt;/p&gt;
&lt;h2 id=&#34;二十-会话跟踪技术cookie-session&#34;&gt;二十、会话跟踪技术（cookie  session...）&lt;/h2&gt;
&lt;p&gt;1.客户端会话技术cookie：cookie是将数据保存在浏览器客户端的；&lt;br&gt;
&lt;strong&gt;Cookie：&lt;/strong&gt;&lt;br&gt;
cookie的数据存在浏览器&lt;br&gt;
浏览器客户端第一次请求服务器时，服务器端创建cookie，绑定数据后通过响应发送cookie到浏览器客户端，浏览器收到cookie后存储在本地，下次请求时将cookie又带回服务器&lt;br&gt;
浏览器对单个cookie的大小有限制，一般为4kb（不同浏览器存在差异），并对同一个域名下cookie的数量也有限制（一般20个以内）&lt;br&gt;
2.服务端会话技术session：session是将数据保存在服务器的；&lt;br&gt;
&lt;strong&gt;Session：&lt;/strong&gt;&lt;br&gt;
Session创建后服务器将Session ID 通过Cookie发送到客服端浏览器，而浏览器则将该Session ID 保存在会话Cookie中。当浏览器再次向服务器发送HTTP请求时，会将Session ID 信息一起发送给服务器。服务器根据该Session ID 在服务器内存找到对应的Session对象，即可取出共享数据&lt;br&gt;
session不是一打开网站就会立刻建立，创建session需要满足以下两个条件中的任意一个条件：&lt;br&gt;
（1）后台服务器端调用HttpSession session = request.getSession()进行创建&lt;br&gt;
（2）用户第一次访问jsp页面就会创建session，因为jsp默认会调用session = pageContext.getSession();&lt;br&gt;
session是依赖cookie的，JSessionId通过cookie传递到浏览器，并在浏览器通过cookie的形式存在&lt;br&gt;
3.Session和Cookie的&lt;strong&gt;区别&lt;/strong&gt;&lt;br&gt;
（1） Session存储在服务器端，Cookie存储在浏览器端&lt;br&gt;
（2）Session存储无大小限制，Cookie存储数据有大小限制&lt;br&gt;
（3）Session相对Cookie更安全&lt;/p&gt;
&lt;h2 id=&#34;二十一-所了解的网络知识iso七层模型&#34;&gt;二十一、所了解的网络知识（ISO七层模型...）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20201104010033983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
七大层：&lt;strong&gt;应用层、表示层、会话层、传输层、网络层、数据链路层、物理层&lt;/strong&gt;&lt;br&gt;
应用层：为网络用户或应用程序提供各种服务，如文件传输、电子邮件、网络管理和远程登录等（协议代表：HTTP、Telnet、FTP、SNMP、RTSP）；&lt;br&gt;
表示层：用于处理在多个通信系统之间交换信息的表示方式，包括数据格式的转换、数据加密与解密、数据压缩与恢复等（ASCII、ASN.1、JPEG、MPEG）；&lt;br&gt;
会话层：针对远程访问进行管理（比如断点续传），包括会话管理、传输同步以及数据交换管理等（NetBIOS、ASP）;&lt;br&gt;
传输层：传输层从会话层接收数据，形成报文（Message），并且在必要时将其分成若干个分组，然后交给网络层进行传输。为上一层进行通信的两个进程之间提供一个可靠的端到端服务，使传输层以上的各层不再关心信息传输的问题；（端到端：进行相互通信的两个节点不是直接通过传输介质连接起来，相互之间有很多交换设备，如路由器），TCP、UDP、SPX；&lt;br&gt;
网络层：进行路由选择，以确保数据分组（Packet）从发送端到达接收端，并在子网发生阻塞时进行拥塞控制。网络层还要解决异构网络（比如网络协议不同）的互连问题，以实现数据分组在不同类型的网络中传输（IP、IPX、RIP、OSPF）。&lt;br&gt;
数据链路层：在两个相邻节点间的线路上无差错地传送以帧为单位的数据，并要产生和识别帧边界。数据链路层还提供了差错控制与流量控制的方法，保证在物理线路上传送的数据无差错（SDLC、HDLC、PPP、STP、帧中继）。&lt;br&gt;
物理层：透明地传送二进制比特流，但物理层并不关心比特流的实际意义和结构，只是负责接收和传送比特流。定义网络硬件的特性，包括使用什么样的传输介质以及与传输介质连接的接头等物理特性，所典型规范代表有（EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45）。&lt;/p&gt;
&lt;h2 id=&#34;二十二-tcp与udp的区别&#34;&gt;二十二、TCP与UDP的区别&lt;/h2&gt;
&lt;p&gt;1.连接方面区别&lt;br&gt;
TCP是面向连接；&lt;br&gt;
UDP是无连接的，即发送数据之前不需要建立连接；&lt;br&gt;
2.安全方面的区别&lt;br&gt;
TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；&lt;br&gt;
UDP尽最大努力交付，即不保证可靠交付；&lt;br&gt;
3.传输效率的区别&lt;br&gt;
TCP传输效率相对较低；&lt;br&gt;
UDP传输效率高，适用于对高速传输和实时性有较高的通信或广播通信；&lt;br&gt;
4.连接对象数量的区别&lt;br&gt;
TCP连接只能是点到点，一对一的；&lt;br&gt;
UDP支持一对一，一对多，多对一和多对多的交互通信&lt;/p&gt;
&lt;h2 id=&#34;二十三-http协议的理解&#34;&gt;二十三、HTTP协议的理解&lt;/h2&gt;
&lt;p&gt;超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。&lt;br&gt;
HTTP请求内容：请求行、请求头、空行、请求体组成&lt;br&gt;
请求行：请求方式+url+协议版本&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;常见的请求方法有GET、POST、PUT、DELETE、HEAD;&lt;/li&gt;
&lt;li&gt;客户端获取的资源路径（所谓的URL）；&lt;/li&gt;
&lt;li&gt;客户端使用的HTTP协议版本号&lt;br&gt;
请求头：客户端向服务器发送请求的补充说明&lt;br&gt;
请求体：一般携带的请求参数&lt;br&gt;
HTTP响应内容：响应行、响应头、空行、响应体组成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20201104010446849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201104010446837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">面试中常见问题汇集：</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/nginx-fu-wu-qi-zheng-fan-xiang-dai-li/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;本章主要简单介绍正向代理与反向代理，以及Nginx服务器&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;一-反向代理reverse-proxy&#34;&gt;一、反向代理（reverse proxy）&lt;/h3&gt;
&lt;p&gt;反向代理服务器位于&lt;strong&gt;用户与目标服务器&lt;/strong&gt;之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为&lt;strong&gt;Web加速&lt;/strong&gt;，即使用反向代理作为Web服务器的前置机来&lt;strong&gt;降低网络和服务器的负载&lt;/strong&gt;，提高访问效率。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;反向代理服务器位于用户与目标服务器之间&lt;/li&gt;
&lt;li&gt;对于用户而言，以为代理服务器就是真实的服务器&lt;/li&gt;
&lt;li&gt;反向代理机制保护了真实的服务器信息&lt;/li&gt;
&lt;li&gt;反向代理一般称之为&lt;strong&gt;服务端代理&lt;/strong&gt;。&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201107130911921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
步骤:&lt;br&gt;
1.当用户发起请求时,该请求被代理服务器&lt;strong&gt;拦截&lt;/strong&gt;.&lt;br&gt;
2.代理服务器查询自己的配置文件,根据url地址获取&lt;strong&gt;真实&lt;/strong&gt;的服务器信息.&lt;br&gt;
3.由代理服务器根据真实的服务器信息,&lt;strong&gt;获取&lt;/strong&gt;数据.&lt;br&gt;
4.真实的服务器接收请求之后,将数据&lt;strong&gt;返回&lt;/strong&gt;给代理服务器.&lt;br&gt;
5.代理服务器接收到服务器数据之后,将数据回&lt;strong&gt;传给&lt;/strong&gt;用户,本次代理结束.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二-正向代理forward-proxy&#34;&gt;二、正向代理(Forward Proxy)&lt;/h3&gt;
&lt;p&gt;正向代理，是一个位于**客户端和原始服务器（origin server）**之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。&lt;strong&gt;客户端才使用正向代理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;特点:&lt;br&gt;
1.代理服务器位于&lt;strong&gt;用户与真实服务器&lt;/strong&gt;之间的&lt;br&gt;
2.客户非常清楚自己访问的服务到底是谁?&lt;br&gt;
3.服务器不清楚访问自己的服务器到底是谁,以为只是代理服务器访问.&lt;br&gt;
4.正向代理称之为&lt;strong&gt;客户端代理&lt;/strong&gt;.保护了客户的信息&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201107131628222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;三-nginx服务器&#34;&gt;三、Nginx服务器&lt;/h3&gt;
&lt;p&gt;1.Nginx服务器介绍&lt;br&gt;
Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。&lt;br&gt;
其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器&lt;/strong&gt;，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。&lt;/p&gt;
&lt;p&gt;特点:&lt;br&gt;
①.占用&lt;strong&gt;内存&lt;/strong&gt;少 不超过2M&lt;br&gt;
②.&lt;strong&gt;并发&lt;/strong&gt;能力强 5万/秒 tomcat 150-220个/秒&lt;br&gt;
③.开发&lt;strong&gt;语言&lt;/strong&gt; C语言&lt;/p&gt;
&lt;p&gt;2.Nginx下载&lt;br&gt;
&lt;a href=&#34;http://nginx.org/en/download.html&#34;&gt;官网地址&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201107132424136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3.Nginx安装&lt;br&gt;
启动: 首先右键以管理员身份运行,之后程序闪退表示服务器启动正常.&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201107132628740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;4.检查Nginx服务启动项&lt;br&gt;
nginx启动时,会启动2个进程项,其中一个&lt;br&gt;
①.主进程 主要为用户提供反向代理服务 占用内存大&lt;br&gt;
②.守护进程 防止主进程意外关闭的. 占用内存小的&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201107132718244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
5.启动正常测试&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;浏览器地址栏输入：localhost&lt;br&gt;
默认端口号 80&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20201107132934373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
6. Nginx命令&lt;br&gt;
目录: 在Nginx的根目录中执行&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201107133142333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//①启动命令      start  nginx*
//②重启命令      nginx  -s  reload*
//③停止命令      nginx   -s  stop*
&lt;/code&gt;&lt;/pre&gt;
">Nginx服务器+（正、反向代理）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/restful-feng-ge-yi-xie-ren-shi/"" data-c="
          &lt;p&gt;&lt;strong&gt;什么是rest?&lt;/strong&gt;&lt;br&gt;
REST(英文：Representational State Transfer，简称REST，意思：表述性状态转换，描述了一个架构样式的网络系统，比如web应用)。&lt;/p&gt;
&lt;p&gt;它是一种软件架构风格、设计风格，而&lt;strong&gt;不是标准&lt;/strong&gt;，只是提供了一组设计原则和约束条件，它主要用于客户端和服务端&lt;em&gt;交互类的软件&lt;/em&gt;。基于这个风格设计的软件可以更简介，更有层次，更易于实现缓存等机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是RESTful？&lt;/strong&gt;&lt;br&gt;
REST：指的是一组&lt;strong&gt;架构约束条件和原则&lt;/strong&gt;。满足这些约束条件和原则的应用程序或设计就是RESTful。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;restful风格实现1&lt;br&gt;
restful风格实现2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** 
	 * restful风格实现1：
	 *  作用：可以动态的接受url中的参数
	 *  语法：
	 *  	1.url中的地址如果是参数，则需要使用 / 分割
	 *  	2.controller方法接受参数时，要使用 {} 号方式获取
	 *  	3.如果需要获取参数信息，则使用特定的注解标识
	 *  restful风格实现2：需要指定访问的请求类型，并且根据特定的类型执行业务
	 *    请求类型：
	 *    	1.get--执行查询操作
	 *    	2.post--执行入库操作
	 *    	3. put--执行更新操作
	 *    	4.delete--执行删除操作
	 * */
//	例子：
	 //@RequestMapping(value=&amp;quot;page/{moduleName}&amp;quot;,method=RequestMethod.GET)
	@GetMapping(&amp;quot;/page/{moduleName}&amp;quot;)
	public String module(@PathVariable String moduleName) {
		return moduleName;
	}
&lt;/code&gt;&lt;/pre&gt;
">restful风格一些认识</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/ru-men-liao-jie-jdbc/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;我是刚入门java的菜鸟，到CSDN膜拜大佬。下面分享一下JDBC，初来乍到多多关照，对于学习Java干完事！&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;sun公司设定的一套&lt;strong&gt;数据库标准&lt;/strong&gt;，标准就是JDBC（Java Database Connectivity）。&lt;br&gt;
但它只是规范，&lt;em&gt;不做具体实现&lt;/em&gt;。于是数据库厂商又根据JDBC标准，实现自家的&lt;strong&gt;驱动Driver&lt;/strong&gt;。&lt;br&gt;
如：mysql驱动&lt;em&gt;com.mysql.cj.jdbc.Driver&lt;/em&gt;，Oracle的驱动&lt;em&gt;oracle.jdbc.OracleDriver&lt;/em&gt;。有了这套解决方案，java就可以访问数据库中的数据了。&lt;br&gt;
Java中提倡面向接口开发，而最经典的接口设计莫过于JDBC数据库接口。&lt;br&gt;
Connection链接、Statement语句、PreparedStatement预处理语句、CallableStatement存储过程、ResultSet结果集。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;调用方式有三种：&lt;/em&gt;&lt;br&gt;
(1)Statement语句、&lt;br&gt;
(2)PreparedStatement预处理语句、&lt;br&gt;
(3)CallableStatement存储过程，&lt;br&gt;
推荐使用第二种PreparedStatement，防止SQL注入，其也是预编译性能高。&lt;/p&gt;
&lt;p&gt;执行流程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册数据库驱动&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Class.forName(driverClass)
//加载MySql驱动
Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;)
//加载Oracle驱动
Class.forName(&amp;quot;oracle.jdbc.driver.OracleDriver&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;获取数据库连接&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Connection conn = DriverManger.getConnection(URL,&amp;quot;数据库用户名&amp;quot;,&amp;quot;数据库密码&amp;quot;);
URL:&amp;quot;jdbc:mysql://localhost:3306/数据库库名&amp;quot;
DriverManger.getConnection() 用于获取数据库连接  
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;传输器(statement/PreparedStatement)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Statement stat = conn.CreateStatement();

conn.createStatement();
conn.prepareStatement(sql);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;结果集对象(ResultSet)&lt;br&gt;
ResultSet对象用于封装SQL语句查询的结果,提供了遍历数据及获取数据的方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ResultSet rs = stat.executeQuery(sql) //执行SQL语句返回结果集
    executeQuery(String sql);
用于向数据库发送查询类的SQL语句,返回一个ResultSet对象中
	executeUpdate(String sql);
用于向数据库发送更新(增删改)类型的语句,返回一个int值,表示影响的行数
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.tedu.jdbc;

import java.sql.*;

public class Testjdbc {
    public static void main(String[] args) throws Exception{
        String driver = &amp;quot;com.mysql.jdbc.Driver&amp;quot;;
        String url = &amp;quot;jdbc:mysql://localhost:3306/mall&amp;quot;;		//注意SID
        String sql = &amp;quot;select * from item&amp;quot;;

        String user = &amp;quot;root&amp;quot;;
        String password = &amp;quot;root&amp;quot;;

        Class.forName(driver);
        Connection cn = DriverManager.getConnection(url, user, password);

        PreparedStatement stat = cn.prepareStatement(sql);

        ResultSet rs = stat.executeQuery(sql);	//执行SQL语句返回结果集
        ResultSetMetaData md = rs.getMetaData();	//获取表结构信息

        //获取列数
        int cols = rs.getMetaData().getColumnCount();

        //打印列名
        for(int i=1; i&amp;lt;=cols; i++) {
            System.out.print(md.getColumnName(i)+&amp;quot;\t&amp;quot;);
        }

        //打印数据
        while(rs.next()) {
            System.out.println();
            for(int i=1; i&amp;lt;=cols; i++) {
                System.out.print(rs.getString(i)+&amp;quot;\t\t&amp;quot;);
            }
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;
">入门了解JDBC</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/shou-cang-hui-ji/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;收录一些个人觉得OK的博客、网站等，方便查阅学习&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-6314005&#34;&gt; &lt;em&gt;持续更新...&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-6314005&#34;&gt; *持续更新...*&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;博客篇&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/chk218/article/details/83620744&#34;&gt; 程序员必备的网站推荐&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/lszw/p/11395644.html&#34;&gt;win7    JDK安装与环境变量配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/wo_shi_LTB/article/details/79268437?spm=1000.2123.3001.4430&#34;&gt;IDEA-配置文件位置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/whiteGu/article/details/83095589&#34;&gt;IDEA常用基础设置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/likun557/article/details/107948005?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161536951116780265488441%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;amp;request_id=161536951116780265488441&amp;amp;biz_id=0&#34;&gt;IDEA实用插件&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;网站篇&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://apache.apooloo.cn/#/down/f1b54d77df533af9d9de55cf3f4e2cea&#34;&gt;常用软件下载（IDEA、JDK、MySql、Windows等）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.znds.com/&#34;&gt;ZNDS智能电视网（喜欢折腾电视机的可以前去学习·去广告·海外影视等）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://baomidou.com/guide/&#34;&gt;MyBatis-Plus（简称 MP）， MyBatis 的增强工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://json.cn/&#34;&gt;Json.cn在线解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://ngrok.cc/&#34;&gt;Sunny-Ngrok内网转发 - 国内内网映射服务器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jeasyui.cn/&#34;&gt;EasyUI-中文站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.layui.com/&#34;&gt;layui-经典模块化前端框架&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://element.faas.ele.me/#/zh-CN&#34;&gt;Element-网站快速成型工具&lt;/a&gt;&lt;/p&gt;
">收藏汇集</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/sql-you-hua-zhuan-ti-pian/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;学习·持续更&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-一张表里面有-id-自增主键当-insert-了-17-条记录之后删除了第-151617-条记录再把-mysql-重启再-insert-一条记录这条记录的-id-是-18-还是-15&#34;&gt;1、一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，再把 Mysql 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15 ？&lt;/h2&gt;
&lt;p&gt;(1)如果表的类型是 MyISAM，那么是 18&lt;br&gt;
因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里，重启 MySQL 自增主键的最大&lt;br&gt;
ID 也不会丢失&lt;br&gt;
（2）如果表的类型是 InnoDB，那么是 15&lt;br&gt;
InnoDB 表只是把自增主键的最大 ID 记录到内存中，所以重启数据库或者是对表进行&lt;br&gt;
OPTIMIZE 操作，都会导致最大 ID 丢失&lt;/p&gt;
&lt;h2 id=&#34;2-mysql-的技术特点是什么&#34;&gt;2、Mysql 的技术特点是什么？&lt;/h2&gt;
&lt;p&gt;Mysql 数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多&lt;br&gt;
线程 SQL 服务器、不同的后端、广泛的应用程序编程接口和管理工具。&lt;/p&gt;
&lt;h2 id=&#34;3-heap-表是什么&#34;&gt;3、Heap 表是什么？&lt;/h2&gt;
&lt;p&gt;HEAP 表存在于内存中，用于临时高速存储。&lt;/p&gt;
&lt;p&gt;BLOB 或 TEXT 字段是不允许的&lt;br&gt;
只能使用比较运算符=，&amp;lt;，&amp;gt;，=&amp;gt;，= &amp;lt;&lt;br&gt;
HEAP 表不支持 AUTO_INCREMENT 索引不可为 NULL&lt;/p&gt;
&lt;h2 id=&#34;4-mysql-服务器默认端口是什么&#34;&gt;4、	Mysql 服务器默认端口是什么？&lt;/h2&gt;
&lt;p&gt;Mysql 服务器的默认端口是 3306。&lt;/p&gt;
&lt;h2 id=&#34;5-与-oracle-相比mysql-有什么优势&#34;&gt;5、	与 Oracle 相比，Mysql 有什么优势？&lt;/h2&gt;
&lt;p&gt;Mysql 是开源软件，随时可用，无需付费。&lt;br&gt;
Mysql 是便携式的带有命令提示符的 GUI。&lt;br&gt;
使用 Mysql 查询浏览器支持管理&lt;/p&gt;
&lt;h2 id=&#34;6-如何区分-float-和-double&#34;&gt;6、	如何区分 FLOAT 和 DOUBLE？&lt;/h2&gt;
&lt;p&gt;以下是 FLOAT 和 DOUBLE 的区别：&lt;br&gt;
浮点数以 8 位精度存储在 FLOAT 中，并且有四个字节。浮点数存储在 DOUBLE 中，精度为 18 位，有八个字节。&lt;/p&gt;
&lt;h2 id=&#34;7-区分-char_length-和-length&#34;&gt;7、	区分 CHAR_LENGTH 和 LENGTH？&lt;/h2&gt;
&lt;p&gt;CHAR_LENGTH 是字符数，而 LENGTH 是字节数。Latin 字符的这两个数据是相同的，但是对于 Unicode 和其他编码，它们是不同的。&lt;/p&gt;
&lt;h2 id=&#34;8-请简洁描述-mysql-中-innodb-支持的四种事务隔离级别名称以及逐级之间的区别-sql-标准定义的四个隔离级别为&#34;&gt;8、	请简洁描述 Mysql 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？ SQL 标准定义的四个隔离级别为：&lt;/h2&gt;
&lt;p&gt;read uncommited ：读到未提交数据&lt;br&gt;
read committed：脏读，不可重复读&lt;br&gt;
repeatable read：可重读&lt;br&gt;
serializable ：串行事物&lt;/p&gt;
&lt;h2 id=&#34;9-在-mysql-中-enum-的用法是什么&#34;&gt;9、	在 Mysql 中 ENUM 的用法是什么？&lt;/h2&gt;
&lt;p&gt;ENUM 是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Create table size(name ENUM(&#39;Smail,&#39;Medium&#39;,&#39;Large&#39;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;10-如何定义-regexp&#34;&gt;10、	如何定义 REGEXP？&lt;/h2&gt;
&lt;p&gt;REGEXP 是模式匹配，其中匹配模式在搜索值的任何位置。&lt;/p&gt;
&lt;h2 id=&#34;11-char-和-varchar-的区别&#34;&gt;11、	CHAR 和 VARCHAR 的区别？&lt;/h2&gt;
&lt;p&gt;以下是 CHAR 和 VARCHAR 的区别：&lt;/p&gt;
&lt;p&gt;CHAR 和 VARCHAR 类型在存储和检索方面有所不同&lt;br&gt;
CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255&lt;/p&gt;
&lt;p&gt;当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除尾随空格。&lt;/p&gt;
&lt;h2 id=&#34;12-列的字符串类型可以是什么&#34;&gt;12、	列的字符串类型可以是什么？&lt;/h2&gt;
&lt;p&gt;字符串类型是：&lt;/p&gt;
&lt;p&gt;SET&lt;br&gt;
BLOB&lt;br&gt;
ENUM&lt;br&gt;
CHAR&lt;br&gt;
TEXT&lt;br&gt;
VARCHAR&lt;/p&gt;
&lt;h2 id=&#34;13-如何获取当前的-mysql-版本&#34;&gt;13、	如何获取当前的 Mysql 版本？&lt;/h2&gt;
&lt;p&gt;SELECT VERSION();用于获取当前 Mysql 的版本。&lt;/p&gt;
&lt;h2 id=&#34;14-mysql-中使用什么存储引擎存储引擎称为表类型数据使用各种技术存储在文件中&#34;&gt;14、	Mysql 中使用什么存储引擎？存储引擎称为表类型，数据使用各种技术存储在文件中。&lt;/h2&gt;
&lt;p&gt;技术涉及：&lt;/p&gt;
&lt;p&gt;Storage mechanism&lt;br&gt;
Locking levels&lt;br&gt;
Indexing&lt;br&gt;
Capabilities and functions.&lt;/p&gt;
&lt;h2 id=&#34;15-mysql-驱动程序是什么&#34;&gt;15、	Mysql 驱动程序是什么？&lt;/h2&gt;
&lt;p&gt;以下是 Mysql 中可用的驱动程序：&lt;/p&gt;
&lt;p&gt;PHP 驱动程序&lt;br&gt;
JDBC 驱动程序&lt;br&gt;
ODBC 驱动程序&lt;br&gt;
CWRAPPER&lt;br&gt;
PYTHON 驱动程序&lt;br&gt;
PERL 驱动程序&lt;br&gt;
RUBY 驱动程序&lt;br&gt;
CAP11PHP 驱动程序&lt;br&gt;
Ado.net5.mxj&lt;/p&gt;
&lt;h2 id=&#34;16-timestamp-在-update-current_timestamp-数据类型上做什么&#34;&gt;16、	TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据类型上做什么？&lt;/h2&gt;
&lt;p&gt;创建表时 TIMESTAMP 列用 Zero 更新。只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP 修饰符就将时间戳字段更新为当前时间。&lt;/p&gt;
">SQL优化专题篇</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/tomcat-zhi-mian-shi-zhuan-ti/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;未更完，待整理&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-tomcat-的缺省端口是多少怎么修改&#34;&gt;1、Tomcat 的缺省端口是多少，怎么修改？&lt;/h3&gt;
&lt;p&gt;1）找到 Tomcat 目录下的 conf 文件夹&lt;br&gt;
2）进入 conf 文件夹里面找到 server.xml 文件&lt;br&gt;
3）打开 server.xml 文件&lt;br&gt;
4）在 server.xml 文件里面找到下列信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;Connector connectionTimeout=&amp;quot;20000&amp;quot; 
port=&amp;quot;8080&amp;quot; 
protocol=&amp;quot;HTTP/1.1&amp;quot; 
redirectPort=&amp;quot;8443&amp;quot; 
uriEncoding=&amp;quot;utf-8&amp;quot;/&amp;gt;
port=&amp;quot;8080&amp;quot;
//改成你想要的端口
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-tomcat-有几种部署方式&#34;&gt;2、Tomcat 有几种部署方式？&lt;/h3&gt;
&lt;p&gt;1）直接把 Web 项目放在 webapps 下，Tomcat 会自动将其部署&lt;br&gt;
2）在 server.xml 文件上配置&lt;Context&gt;节点，设置相关的属性即可&lt;br&gt;
3）通过 Catalina 来进行配置:进入到 conf\Catalina\localhost 文件下，创建一个 xml 文件，该文件的名字就是站点的名字。&lt;br&gt;
编写 XML 的方式来进行设置。&lt;/p&gt;
&lt;h3 id=&#34;3tomcat-工作模式&#34;&gt;3.Tomcat 工作模式&lt;/h3&gt;
&lt;p&gt;Tomcat 是一个 JSP/Servlet 容器。其作为 Servlet 容器，有三种工作模式：独 立的 Servlet 容器、进程内的 Servlet 容器和进程外的 Servlet 容器。&lt;br&gt;
进入 Tomcat 的请求可以根据 Tomcat 的工作模式分为如下两类：&lt;br&gt;
Tomcat 作为应用程序服务器：请求来自于前端的 web 服务器，这可能是 Apache, IIS, Nginx 等；&lt;br&gt;
Tomcat 作为独立服务器：请求来自于 web 浏览器；&lt;/p&gt;
&lt;h3 id=&#34;4-tomcat-容器是如何创建-servlet-类实例用到了什么原理&#34;&gt;4、tomcat 容器是如何创建 servlet 类实例？用到了什么原理？&lt;/h3&gt;
&lt;p&gt;当容器启动时，会读取在 webapps 目录下所有的 web 应用中的 web.xml 文件，然后对 xml 文件进行解析，&lt;br&gt;
并读取 servlet 注册信息。然后，将每个应用中注册的 servlet 类都进行加载，并通过反射的方式实例化。&lt;br&gt;
（有时候也是在第一次请求时实例化）在 servlet 注册时加上如果为正数，则在一开始就实例化，&lt;br&gt;
如果不写或为负数，则第一次请求实例化。&lt;/p&gt;
&lt;h3 id=&#34;5内存调优&#34;&gt;5.内存调优&lt;/h3&gt;
&lt;p&gt;内存方式的设置是在 catalina.sh 中，调整一下 JAVA_OPTS 变量即可，因为后&lt;br&gt;
面的启动参数会把 JAVA_OPTS 作为 JVM 的启动参数来处理。&lt;br&gt;
具体设置如下：&lt;br&gt;
&lt;strong&gt;JAVA_OPTS=&amp;quot;$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -&lt;br&gt;
XX:NewRatio=4 -XX:SurvivorRatio=4&amp;quot;&lt;/strong&gt;&lt;br&gt;
其各项参数如下：&lt;br&gt;
&lt;strong&gt;-Xmx3550m&lt;/strong&gt;：设置 JVM 最大可用内存为 3550M。&lt;br&gt;
&lt;strong&gt;-Xms3550m&lt;/strong&gt;：设置 JVM 促使内存为 3550m。此值可以设置与-Xmx 相同，以&lt;br&gt;
避免每次垃圾回收完成后 JVM 重新分配内存。&lt;br&gt;
&lt;strong&gt;-Xmn2g&lt;/strong&gt;：设置年轻代大小为 2G。整个堆大小=年轻代大小 + 年老代大小 +&lt;br&gt;
持久代大小。持久代一般固定大小为 64m，所以增大年轻代后，将会减小年老&lt;br&gt;
代大小。此值对系统性能影响较大，Sun 官方推荐配置为整个堆的 3/8。&lt;br&gt;
&lt;strong&gt;-Xss128k&lt;/strong&gt;：设置每个线程的堆栈大小。JDK5.0 以后每个线程堆栈大小为 1M，&lt;br&gt;
以前每个线程堆栈大小为 256K。更具应用的线程所需内存大小进行调整。在相&lt;br&gt;
同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的&lt;br&gt;
线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右。&lt;br&gt;
&lt;strong&gt;-XX:NewRatio=4&lt;/strong&gt;:设置年轻代（包括 Eden 和两个 Survivor 区）与年老代的比&lt;br&gt;
值（除去持久代）。设置为 4，则年轻代与年老代所占比值为 1：4，年轻代占&lt;br&gt;
整个堆栈的 1/5&lt;br&gt;
&lt;strong&gt;-XX:SurvivorRatio=4&lt;/strong&gt;：设置年轻代中 Eden 区与 Survivor 区的大小比值。设置&lt;br&gt;
为 4，则两个 Survivor 区与一个 Eden 区的比值为 2:4，一个 Survivor 区占整&lt;br&gt;
个年轻代的 1/6&lt;br&gt;
&lt;strong&gt;-XX:MaxPermSize=16m&lt;/strong&gt;:设置持久代大小为 16m。&lt;br&gt;
&lt;strong&gt;-XX:MaxTenuringThreshold=0&lt;/strong&gt;：设置垃圾最大年龄。如果设置为 0 的话，则年&lt;br&gt;
轻代对象不经过 Survivor 区，直接进入年老代。对于年老代比较多的应用，可&lt;br&gt;
以提高效率。如果将此值设置为一个较大值，则年轻代对象会在 Survivor 区进&lt;br&gt;
行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收&lt;br&gt;
的概论。&lt;/p&gt;
&lt;h3 id=&#34;6共享-session-处理&#34;&gt;6.共享 session 处理&lt;/h3&gt;
&lt;p&gt;目前的处理方式有如下几种：&lt;br&gt;
1).使用 Tomcat &lt;strong&gt;本身的 Session 复制功能&lt;/strong&gt;&lt;br&gt;
参考 http://ajita.iteye.com/blog/1715312（Session 复制的配置）&lt;br&gt;
方案的有点是配置简单，缺点是当集群数量较多时，Session 复制的时间会比&lt;br&gt;
较长，影响响应的效率&lt;br&gt;
2).使用&lt;strong&gt;第三方来存放共享&lt;/strong&gt; Session&lt;br&gt;
目前用的较多的是使用 memcached 来管理共享 Session，借助于&lt;br&gt;
memcached-sesson-manager 来进行 Tomcat 的 Session 管理&lt;br&gt;
参考 http://ajita.iteye.com/blog/1716320（使用 MSM 管理 Tomcat 集群&lt;br&gt;
session）&lt;br&gt;
3).使用&lt;strong&gt;黏性 session 的策略&lt;/strong&gt;&lt;br&gt;
对于会话要求不太强（不涉及到计费，失败了允许重新请求下等）的场合，同&lt;br&gt;
一个用户的 session 可以由 nginx 或者 apache 交给同一个 Tomcat 来处理，这&lt;br&gt;
就是所谓的 session sticky 策略，目前应用也比较多&lt;br&gt;
参考：&lt;a href=&#34;http://ajita.iteye.com/blog/1848665&#34;&gt;（tomcat session sticky）&lt;/a&gt;&lt;br&gt;
nginx 默认不包含 session sticky 模块，需要重新编译才行（windows 下我也不&lt;br&gt;
知道怎么重新编译）&lt;br&gt;
优点是处理效率高多了，缺点是强会话要求的场合不合适&lt;/p&gt;
&lt;h3 id=&#34;7添加-jms-远程监控&#34;&gt;7.添加 JMS 远程监控&lt;/h3&gt;
&lt;p&gt;对于部署在局域网内其它机器上的 Tomcat，可以打开 JMX 监控端口，局域网&lt;br&gt;
其它机器就可以通过这个端口查看一些常用的参数（但一些比较复杂的功能不&lt;br&gt;
支持），同样是在 JVM 启动参数中配置即可，配置如下：&lt;br&gt;
&lt;strong&gt;-Dcom.sun.management.jmxremote.ssl=false -&lt;br&gt;
Dcom.sun.management.jmxremote.authenticate=false&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;-Djava.rmi.server.hostname=192.168.71.38&lt;/strong&gt; 设置 JVM 的 JMS 监控监听的 IP&lt;br&gt;
地址，主要是为了防止错误的监听成 127.0.0.1 这个内网地址&lt;br&gt;
&lt;strong&gt;-Dcom.sun.management.jmxremote.port=1090&lt;/strong&gt; 设置 JVM 的 JMS 监控的端口&lt;br&gt;
&lt;strong&gt;-Dcom.sun.management.jmxremote.ssl=false&lt;/strong&gt; 设置 JVM 的 JMS 监控不实用&lt;br&gt;
SSL&lt;br&gt;
&lt;strong&gt;-Dcom.sun.management.jmxremote.authenticate=false&lt;/strong&gt; 设置 JVM 的 JMS 监&lt;br&gt;
控不需要认证&lt;/p&gt;
&lt;h3 id=&#34;8专业点的分析工具有&#34;&gt;8.专业点的分析工具有&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IBM ISA，JProfiler、probe&lt;/strong&gt; 等，具体监控及分析方式去网上搜索即可&lt;/p&gt;
&lt;h3 id=&#34;9关于-tomcat-的-session-数目&#34;&gt;9.关于 Tomcat 的 session 数目&lt;/h3&gt;
&lt;p&gt;这个可以直接从 Tomcat 的 &lt;strong&gt;web 管理界面&lt;/strong&gt;去查看即可 ；&lt;br&gt;
或者借助于&lt;strong&gt;第三方工具 Lambda Probe&lt;/strong&gt; 来查看，它相对于 Tomcat 自带的管理&lt;br&gt;
稍微多了点功能，但也不多 ；&lt;/p&gt;
&lt;h3 id=&#34;10监视-tomcat-的内存使用情况&#34;&gt;10.监视 Tomcat 的内存使用情况&lt;/h3&gt;
&lt;p&gt;使用 JDK 自带的 jconsole 可以比较明了的看到内存的使用情况，线程的状态，&lt;br&gt;
当前加载的类的总量等；&lt;br&gt;
JDK 自带的 jvisualvm 可以下载插件（如 GC 等），可以查看更丰富的信息。&lt;br&gt;
如果是分析本地的 Tomcat 的话，还可以进行内存抽样等，检查每个类的使用&lt;br&gt;
情况&lt;/p&gt;
">Tomcat之面试专题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/yuan-ma-kuang-jia-zhuan-ti-1-mybatis/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;多多阅读，吸取精华&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;s&gt;- [ ] &lt;em&gt;持续更新...&lt;/em&gt;&lt;/s&gt;&lt;br&gt;
&lt;s&gt;- [ ] &lt;em&gt;此篇更新完毕&lt;/em&gt;&lt;/s&gt;&lt;/p&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1356395&#34;&gt; &lt;em&gt;待整理版式，以便查阅&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1356395&#34;&gt; *待整理版式，以便查阅*&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80-%E4%BB%80%E4%B9%88%E6%98%AFmybatis&#34;&gt;一、什么是Mybatis？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C-mybaits-%E7%9A%84%E4%BC%98%E7%82%B9&#34;&gt;二、 Mybaits 的优点：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89-mybatis-%E6%A1%86%E6%9E%B6%E7%9A%84%E7%BC%BA%E7%82%B9&#34;&gt;三、 MyBatis 框架的缺点：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B-mybatis-%E6%A1%86%E6%9E%B6%E9%80%82%E7%94%A8%E5%9C%BA%E5%90%88&#34;&gt;四、 MyBatis 框架适用场合：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94-mybatis-%E4%B8%8Ehibernate-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C&#34;&gt;五、 MyBatis 与Hibernate 有哪些不同？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88&#34;&gt;六、#{}和 ${}的区别是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%83-%E5%BD%93%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E5%92%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8D%E4%B8%80%E6%A0%B7-%E6%80%8E%E4%B9%88%E5%8A%9E&#34;&gt;七、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AB-%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2like-%E8%AF%AD%E5%8F%A5%E8%AF%A5%E6%80%8E%E4%B9%88%E5%86%99&#34;&gt;八、模糊查询like 语句该怎么写?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B9%9D-%E9%80%9A%E5%B8%B8%E4%B8%80%E4%B8%AAxml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E9%83%BD%E4%BC%9A%E5%86%99%E4%B8%80%E4%B8%AAdao-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E4%B9%8B%E5%AF%B9%E5%BA%94&#34;&gt;九、通常一个Xml 映射文件，都会写一个Dao 接口与之对应，&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81-mybatis-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E7%9A%84%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88&#34;&gt;十、Mybatis 是如何进行分页的？分页插件的原理是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%B8%80-mybatis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B0%86sql-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B0%81%E8%A3%85%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%9A%84-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%98%A0%E5%B0%84%E5%BD%A2%E5%BC%8F&#34;&gt;十一、Mybatis 是如何将sql 执行结果封装为目标对象并返回的？ 都有哪些映射形式？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%BA%8C-%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5&#34;&gt;十二、如何执行批量插入?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%B8%89-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E4%B8%BB%E9%94%AE%E5%80%BC&#34;&gt;十三、如何获取自动生成的(主)键值?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E5%9B%9B-%E5%9C%A8-mapper-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0&#34;&gt;十四、在 mapper 中如何传递多个参数?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%BA%94-mybatis-%E5%8A%A8%E6%80%81sql-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%A8%E6%80%81sql&#34;&gt;十五、Mybatis 动态sql 有什么用？执行原理？有哪些动态sql？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E5%85%AD-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%E9%99%A4%E4%BA%86%E5%B8%B8%E8%A7%81%E7%9A%84-selectinsertupdaedelete-%E6%A0%87%E7%AD%BE%E4%B9%8B%E5%A4%96%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%87%E7%AD%BE&#34;&gt;十六、Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%B8%83-mybatis-%E7%9A%84-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD-%E4%B8%8D%E5%90%8C%E7%9A%84-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6-id-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D&#34;&gt;十七、Mybatis 的 Xml 映射文件中， 不同的 Xml 映射文件， id 是否可以重复？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E5%85%AB-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-mybatis-%E6%98%AF%E5%8D%8A%E8%87%AA%E5%8A%A8-orm-%E6%98%A0%E5%B0%84%E5%B7%A5%E5%85%B7%E5%AE%83%E4%B8%8E%E5%85%A8%E8%87%AA%E5%8A%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C&#34;&gt;十八、为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%B9%9D-%E4%B8%80%E5%AF%B9%E4%B8%80-%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2&#34;&gt;十九、一对一、一对多的关联查询 ？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81-mybatis-%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%AF%B9%E4%B8%80%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%85%B7%E4%BD%93%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84&#34;&gt;二十、MyBatis 实现一对一有几种方式?具体怎么操作的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E4%B8%80-mybatis-%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%AF%B9%E5%A4%9A%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84&#34;&gt;二十一、MyBatis 实现一对多有几种方式,怎么操作的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E4%BA%8C-mybatis-%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%A6%82%E6%9E%9C%E6%94%AF%E6%8C%81%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88&#34;&gt;二十二、Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E4%B8%89-mybatis-%E7%9A%84%E4%B8%80%E7%BA%A7-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98&#34;&gt;二十三、Mybatis 的一级、二级缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E5%9B%9B-%E4%BB%80%E4%B9%88%E6%98%AF-mybatis-%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F&#34;&gt;二十四、什么是 MyBatis 的接口绑定？有哪些实现方式？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E4%BA%94-%E4%BD%BF%E7%94%A8-mybatis-%E7%9A%84mapper-%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A6%81%E6%B1%82&#34;&gt;二十五、使用 MyBatis 的mapper 接口调用时有哪些要求？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E5%85%AD-mapper-%E7%BC%96%E5%86%99%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F&#34;&gt;二十六、Mapper 编写有哪几种方式？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E4%B8%83-%E7%AE%80%E8%BF%B0-mybatis-%E7%9A%84%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6&#34;&gt;二十七、简述 Mybatis 的插件运行原理，以及如何编写一个插件。&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
(专题目录)&lt;/p&gt;
&lt;h2 id=&#34;一-什么是mybatis&#34;&gt;一、什么是Mybatis？&lt;/h2&gt;
&lt;p&gt;1、Mybatis 是一个半 ORM（ 对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身， 不需要花费精力去处理加载驱动、创建连接、创建&lt;br&gt;
statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能， 灵活度高。&lt;br&gt;
2、MyBatis 可以使用 XML 或注解来配置和映射原生信息， 将 POJO 映射成数据库中的记录， 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。&lt;br&gt;
3、通过 xml 文件或注解的方式将要执行的各种 statement 配置起来， 并通过java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。（ 从执行 sql 到返回 result 的过程）。&lt;/p&gt;
&lt;h2 id=&#34;二-mybaits-的优点&#34;&gt;二、 Mybaits 的优点：&lt;/h2&gt;
&lt;p&gt;1、基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签， 支持编写动态 SQL 语句， 并可重用。&lt;br&gt;
2、与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；&lt;br&gt;
3、很好的与各种数据库兼容（ 因为 MyBatis 使用 JDBC 来连接数据库，所以只要JDBC 支持的数据库 MyBatis 都支持）。&lt;br&gt;
4、能够与 Spring 很好的集成；&lt;br&gt;
5、提供映射标签， 支持对象与数据库的 ORM 字段关系映射； 提供对象关系映射标签， 支持对象关系组件维护。&lt;/p&gt;
&lt;h2 id=&#34;三-mybatis-框架的缺点&#34;&gt;三、 MyBatis 框架的缺点：&lt;/h2&gt;
&lt;p&gt;1、SQL 语句的编写工作量较大， 尤其当字段多、关联表多时， 对开发人员编写SQL 语句的功底有一定要求。&lt;br&gt;
2、SQL 语句依赖于数据库， 导致数据库移植性差， 不能随意更换数据库。&lt;/p&gt;
&lt;h2 id=&#34;四-mybatis-框架适用场合&#34;&gt;四、 MyBatis 框架适用场合：&lt;/h2&gt;
&lt;p&gt;1、MyBatis 专注于 SQL 本身， 是一个足够灵活的 DAO 层解决方案。&lt;br&gt;
2、对性能的要求很高，或者需求变化较多的项目，如互联网项目， MyBatis 将是不错的选择。&lt;/p&gt;
&lt;h2 id=&#34;五-mybatis-与hibernate-有哪些不同&#34;&gt;五、 MyBatis 与Hibernate 有哪些不同？&lt;/h2&gt;
&lt;p&gt;1、Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 Sql 语句。&lt;br&gt;
2、Mybatis 直接编写原生态 sql， 可以严格控制 sql 执行性能， 灵活度高， 非常适合对关系数据模型要求不高的软件开发， 因为这类软件需求变化频繁， 一但需求变化要求迅速输出成果。但是灵活的前提是 mybatis 无法做到数据库无关性， 如果需要实现支持多种数据库的软件，则需要自定义多套 sql 映射文件，工作量大。&lt;br&gt;
3、Hibernate 对象/关系映射能力强， 数据库无关性好， 对于关系模型要求高的软件， 如果用 hibernate 开发可以节省很多代码， 提高效率。&lt;/p&gt;
&lt;h2 id=&#34;六-和-的区别是什么&#34;&gt;六、#{}和 ${}的区别是什么？&lt;/h2&gt;
&lt;p&gt;#{}是预编译处理，  $ {} 是字符串替换。 Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的set 方法来赋值；&lt;br&gt;
Mybatis 在处理&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;就&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;把&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;{}时，就是把&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;时&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;就&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;把&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{}替换成变量的值。使用#{}可以有效的防止 SQL 注入， 提高系统安全性。&lt;/p&gt;
&lt;h2 id=&#34;七-当实体类中的属性名和表中的字段名不一样-怎么办&#34;&gt;七、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？&lt;/h2&gt;
&lt;p&gt;第 1 种： 通过在查询的 sql 语句中定义字段名的别名， 让字段名的别名和实体类的属性名一致。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;select id=&amp;quot;selectorder&amp;quot;  parametertype=&amp;quot;int&amp;quot;  resultetype=&amp;quot;me.gacl.domain.order&amp;quot;&amp;gt;
select order_id id, order_no orderno ,order_price price form orders where order_id=#{id};
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第 2 种： 通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应的关系。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;select id=&amp;quot;getOrder&amp;quot; parameterType=&amp;quot;int&amp;quot; resultMap=&amp;quot;orderresultmap&amp;quot;&amp;gt;
select * from orders where order_id=#{id}
&amp;lt;/select&amp;gt;

&amp;lt;resultMap type=&amp;quot;me.gacl.domain.order&amp;quot;  id=&amp;quot;orderresultmap&amp;quot;&amp;gt;
&amp;lt;!–用 id 属性来映射主键字段–&amp;gt;
&amp;lt;id property=&amp;quot;id&amp;quot;  column=&amp;quot;order_id&amp;quot;&amp;gt;

&amp;lt;!–用 result 属性来映射非主键字段，property 为实体类属性名，column 为数据表中的属性–&amp;gt;
&amp;lt;result property =  &amp;quot;orderno&amp;quot;  column =&amp;quot;order_no&amp;quot;/&amp;gt;
&amp;lt;result property=&amp;quot;price&amp;quot;  column=&amp;quot;order_price&amp;quot;  /&amp;gt;
&amp;lt;/reslutMap&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;八-模糊查询like-语句该怎么写&#34;&gt;八、模糊查询like 语句该怎么写?&lt;/h2&gt;
&lt;p&gt;第 1 种： 在 Java 代码中添加 sql 通配符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;string wildcardname =  &amp;quot;%smi%&amp;quot;;
list&amp;lt;name&amp;gt; names = mapper.selectlike(wildcardname);
&amp;lt;select id=&amp;quot;selectlike&amp;quot;&amp;gt;
select * from foo where bar like #{value}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第 2 种： 在 sql 语句中拼接通配符， 会引起 sql 注入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;string wildcardname =  &amp;quot;smi&amp;quot;;
list&amp;lt;name&amp;gt; names = mapper.selectlike(wildcardname);
&amp;lt;select id=&amp;quot;selectlike&amp;quot;&amp;gt;
select * from foo where bar like &amp;quot;%&amp;quot;#{value}&amp;quot;%&amp;quot;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;九-通常一个xml-映射文件都会写一个dao-接口与之对应&#34;&gt;九、通常一个Xml 映射文件，都会写一个Dao 接口与之对应，&lt;/h2&gt;
&lt;p&gt;请问，这个Dao 接口的工作原理是什么？Dao 接口里的方法， 参数不同时，方法能重载吗？&lt;br&gt;
Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值； 接口的方法名， 就是映射文件中 Mapper 的 Statement 的 id 值； 接口方法内的参数， 就是传递给 sql 的参数。&lt;br&gt;
Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值， 可唯一定位一个 MapperStatement。在 Mybatis 中， 每一个&lt;br&gt;
&amp;lt; select&amp;gt;、 &amp;lt; insert&amp;gt;、&amp;lt; update&amp;gt;、&amp;lt; delete&amp;gt;标签，都会被解析为一个MapperStatement 对象。&lt;br&gt;
举例： com.mybatis3.mappers.StudentDao.findStudentById， 可以唯一 找 到 namespace 为 com.mybatis3.mappers.StudentDao 下 面 id 为findStudentById 的 MapperStatement 。&lt;br&gt;
Mapper 接口里的方法，是不能重载的，因为是使用 全限名+方法名  的保存和寻找策略。Mapper 接口的工作原理是 JDK 动态代理， Mybatis 运行时会使用 JDK 动态代理为 Mapper 接口生成代理对象 proxy， 代理对象会拦截接口方法， 转而执行 MapperStatement 所代表的 sql， 然后将 sql 执行结果返回。&lt;/p&gt;
&lt;h2 id=&#34;十-mybatis-是如何进行分页的分页插件的原理是什么&#34;&gt;十、Mybatis 是如何进行分页的？分页插件的原理是什么？&lt;/h2&gt;
&lt;p&gt;Mybatis 使用 RowBounds 对象进行分页， 它是针对 ResultSet 结果集执行的内存分页，而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能， 也可以使用分页插件来完成物理分页。&lt;br&gt;
分页插件的基本原理是使用 Mybatis 提供的插件接口， 实现自定义插件， 在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。&lt;/p&gt;
&lt;h2 id=&#34;十一-mybatis-是如何将sql-执行结果封装为目标对象并返回的-都有哪些映射形式&#34;&gt;十一、Mybatis 是如何将sql 执行结果封装为目标对象并返回的？ 都有哪些映射形式？&lt;/h2&gt;
&lt;p&gt;第一种是使用&lt;resultMap&gt;标签， 逐一定义数据库列名和对象属性名之间的映射关系。&lt;br&gt;
第二种是使用 sql 列的别名功能， 将列的别名书写为对象属性名。&lt;br&gt;
有了列名与属性名的映射关系后， Mybatis 通过反射创建对象， 同时使用反射给对象的属性逐一赋值并返回， 那些找不到映射关系的属性， 是无法完成赋值的。&lt;/p&gt;
&lt;h2 id=&#34;十二-如何执行批量插入&#34;&gt;十二、如何执行批量插入?&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//首先,创建一个简单的 insert 语句:
	&amp;lt;insert id=&amp;quot;insertname&amp;quot;&amp;gt;
		insert into names (name) values (#{value})
	&amp;lt;/insert&amp;gt;
//然后在 java 代码中像下面这样执行批处理插入:
list &amp;lt; string &amp;gt; names = new arraylist(); names.add(&amp;quot;fred&amp;quot;); names.add(&amp;quot;barney&amp;quot;); names.add(&amp;quot;betty&amp;quot;);
names.add(&amp;quot;wilma&amp;quot;);
// 注意这里 executortype.batch sqlsession sqlsession =
sqlsessionfactory.opensession(executortype.batch); try {
namemapper mapper = sqlsession.getmapper(namemapper.class); for (string name: names) {
mapper.insertname(name);
}
sqlsession.commit();
} catch (Exception e) { e.printStackTrace(); sqlSession.rollback();
throw e;
}
finally {
sqlsession.close();
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;十三-如何获取自动生成的主键值&#34;&gt;十三、如何获取自动生成的(主)键值?&lt;/h2&gt;
&lt;p&gt;insert 方法总是返回一个 int 值 ， 这个值代表的是插入的行数。&lt;br&gt;
如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//示例：
&amp;lt;insert id=&amp;quot;insertname&amp;quot;  usegeneratedkeys=&amp;quot;true&amp;quot;  keyproperty=&amp;quot;id&amp;quot;&amp;gt;
insert into names (name) values (#{name})
&amp;lt;/insert&amp;gt;
name name = new name(); name.setname(&amp;quot;fred&amp;quot;);
int rows = mapper.insertname(name);
// 完成后,id 已经被设置到对象中system.out.println(&amp;quot;rows inserted =&amp;quot; + rows);
system.out.println(&amp;quot;generated key value =  &amp;quot; + name.getid());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;十四-在-mapper-中如何传递多个参数&#34;&gt;十四、在 mapper 中如何传递多个参数?&lt;/h2&gt;
&lt;p&gt;第一种： DAO 层的函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public UserselectUser(String name,String area);
//对应的 xml,#{0}代表接收的是 dao 层中的第一个参数，#{1}代表 dao 层中第二参数，更多参数一致往后加即可。
&amp;lt;select id=&amp;quot;selectUser&amp;quot;resultMap=&amp;quot;BaseResultMap&amp;quot;&amp;gt; select *	fromuser_user_t	whereuser_name = #{0}
anduser_area=#{1}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种： 使用 @param 注解:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface usermapper {
user selectuser(@param(&amp;quot;username&amp;quot;) string username,@param(&amp;quot;hashedpassword&amp;quot;) string hashedpassword);
}
//然后,就可以在 xml 像下面这样使用(推荐封装为一个 map,作为单个参数传递给mapper):
&amp;lt;select id=&amp;quot;selectuser&amp;quot;  resulttype=&amp;quot;user&amp;quot;&amp;gt; select id, username, hashedpassword from some_table
where username = #{username}
and hashedpassword = #{hashedpassword}
&amp;lt;/select&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三种： 多个参数封装成 map&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try {
//映射文件的命名空间.SQL 片段的 ID，就可以调用对应的映射文件中的
SQL
//由于我们的参数超过了两个，而方法中只有一个 Object 参数收集，因此我们使用 Map 集合来装载我们的参数
Map &amp;lt; String, Object &amp;gt; map = new HashMap(); map.put(&amp;quot;start&amp;quot;, start);
map.put(&amp;quot;end&amp;quot;, end);
return sqlSession.selectList(&amp;quot;StudentID.pagination&amp;quot;, map);
} catch (Exception e) { e.printStackTrace(); sqlSession.rollback(); throw e;
} finally {
MybatisUtil.closeSqlSession();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;十五-mybatis-动态sql-有什么用执行原理有哪些动态sql&#34;&gt;十五、Mybatis 动态sql 有什么用？执行原理？有哪些动态sql？&lt;/h2&gt;
&lt;p&gt;Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，执行原理是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能。&lt;br&gt;
Mybatis 提供了 9 种动态 sql 标签：trim | where | set | foreach | if | choose&lt;br&gt;
| when | otherwise | bind 。&lt;/p&gt;
&lt;h2 id=&#34;十六-xml-映射文件中除了常见的-selectinsertupdaedelete-标签之外还有哪些标签&#34;&gt;十六、Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？&lt;/h2&gt;
&lt;p&gt;&amp;lt; resultMap&amp;gt;、&amp;lt; parameterMap&amp;gt;、&amp;lt; sql&amp;gt;、&amp;lt; include&amp;gt;、&lt;br&gt;
&amp;lt; selectKey&amp;gt;， 加上动态 sql 的 9 个标签， 其中&amp;lt; sql&amp;gt;为 sql 片段标签， 通过&amp;lt; include&amp;gt;标签引入  sql   片段，&amp;lt; selectKey&amp;gt;为不支持自增的主键生成策略标签。&lt;/p&gt;
&lt;h2 id=&#34;十七-mybatis-的-xml-映射文件中-不同的-xml-映射文件-id-是否可以重复&#34;&gt;十七、Mybatis 的 Xml 映射文件中， 不同的 Xml 映射文件， id 是否可以重复？&lt;/h2&gt;
&lt;p&gt;不同的 Xml 映射文件， 如果配置了 namespace， 那么 id 可以重复； 如果没有配置 namespace， 那么 id 不能重复；&lt;br&gt;
原因就是 namespace+id 是作为 Map&amp;lt;String, MapperStatement&amp;gt;的 key 使用的， 如果没有 namespace， 就剩下 id， 那么， id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。&lt;/p&gt;
&lt;h2 id=&#34;十八-为什么说-mybatis-是半自动-orm-映射工具它与全自动的区别在哪里&#34;&gt;十八、为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？&lt;/h2&gt;
&lt;p&gt;Hibernate 属于全自动 ORM 映射工具， 使用 Hibernate 查询关联对象或者关联集合对象时， 可以根据对象关系模型直接获取， 所以它是全自动的。而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。&lt;/p&gt;
&lt;h2 id=&#34;十九-一对一-一对多的关联查询&#34;&gt;十九、一对一、一对多的关联查询 ？&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;mapper namespace=&amp;quot;com.pj.mapper.userMapper&amp;quot;&amp;gt;

&amp;lt;!--association	一对一关联查询 --&amp;gt;
&amp;lt;select id=&amp;quot;getClass&amp;quot; parameterType=&amp;quot;int&amp;quot; resultMap=&amp;quot;ClassesResultMap&amp;quot;&amp;gt;
select * from class c,teacher t where c.teacher_id=t.t_id and c.c_id=#{id}
&amp;lt;/select&amp;gt;

&amp;lt;resultMap type=&amp;quot;com.pj.user.Classes&amp;quot; id=&amp;quot;ClassesResultMap&amp;quot;&amp;gt;
&amp;lt;!-- 实体类的字段名和数据表的字段名映射 --&amp;gt;
&amp;lt;id property=&amp;quot;id&amp;quot; column=&amp;quot;c_id&amp;quot;/&amp;gt;
&amp;lt;result property=&amp;quot;name&amp;quot; column=&amp;quot;c_name&amp;quot;/&amp;gt;
&amp;lt;association property=&amp;quot;teacher&amp;quot; javaType=&amp;quot;com.pj.user.Teacher&amp;quot;&amp;gt;
&amp;lt;id property=&amp;quot;id&amp;quot; column=&amp;quot;t_id&amp;quot;/&amp;gt;
&amp;lt;result property=&amp;quot;name&amp;quot; column=&amp;quot;t_name&amp;quot;/&amp;gt;
&amp;lt;/association&amp;gt;
&amp;lt;/resultMap&amp;gt;
//////
&amp;lt;!--collection	一对多关联查询 --&amp;gt;
&amp;lt;select id=&amp;quot;getClass2&amp;quot; parameterType=&amp;quot;int&amp;quot; resultMap=&amp;quot;ClassesResultMap2&amp;quot;&amp;gt;
select * from class c,teacher t,student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#{id}
&amp;lt;/select&amp;gt;

&amp;lt;resultMap type=&amp;quot;com.pj.user.Classes&amp;quot; id=&amp;quot;ClassesResultMap2&amp;quot;&amp;gt;
&amp;lt;id property=&amp;quot;id&amp;quot; column=&amp;quot;c_id&amp;quot;/&amp;gt;
&amp;lt;result property=&amp;quot;name&amp;quot; column=&amp;quot;c_name&amp;quot;/&amp;gt;
&amp;lt;association property=&amp;quot;teacher&amp;quot; javaType=&amp;quot;com.pj.user.Teacher&amp;quot;&amp;gt;
&amp;lt;id property=&amp;quot;id&amp;quot; column=&amp;quot;t_id&amp;quot;/&amp;gt;
&amp;lt;result property=&amp;quot;name&amp;quot; column=&amp;quot;t_name&amp;quot;/&amp;gt;
&amp;lt;/association&amp;gt;

&amp;lt;collection property=&amp;quot;student&amp;quot; ofType=&amp;quot;com.pj.user.Student&amp;quot;&amp;gt;
&amp;lt;id property=&amp;quot;id&amp;quot; column=&amp;quot;s_id&amp;quot;/&amp;gt;
&amp;lt;result property=&amp;quot;name&amp;quot; column=&amp;quot;s_name&amp;quot;/&amp;gt;
&amp;lt;/collection&amp;gt;
&amp;lt;/resultMap&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二十-mybatis-实现一对一有几种方式具体怎么操作的&#34;&gt;二十、MyBatis 实现一对一有几种方式?具体怎么操作的？&lt;/h2&gt;
&lt;p&gt;有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在resultMap 里面配置 association 节点配置一对一的类就可以完成；&lt;br&gt;
嵌套查询是先查一个表，根据这个表里面的结果的 外键 id，去再另外一个表里面查询数据,也是通过 association 配置，但另外一个表的查询通过 select 属性配置。&lt;/p&gt;
&lt;h2 id=&#34;二十一-mybatis-实现一对多有几种方式怎么操作的&#34;&gt;二十一、MyBatis 实现一对多有几种方式,怎么操作的？&lt;/h2&gt;
&lt;p&gt;有&lt;strong&gt;联合查询&lt;/strong&gt;和&lt;strong&gt;嵌套查询&lt;/strong&gt;。联合查询是几个表联合查询,只查询一次,通过在resultMap 里面的 collection 节点配置一对多的类就可以完成；&lt;br&gt;
嵌套查询是先查一个表,根据这个表里面的 结果的外键 id,去再另外一个表里面查询数据,也是通过配置 collection,但另外一个表的查询通过 select 节点配置。&lt;/p&gt;
&lt;h2 id=&#34;二十二-mybatis-是否支持延迟加载如果支持它的实现原理是什么&#34;&gt;二十二、Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？&lt;/h2&gt;
&lt;p&gt;答： Mybatis 仅支持 &lt;strong&gt;association 关联对象&lt;/strong&gt;和 &lt;strong&gt;collection 关联集合对象&lt;/strong&gt;的延迟加载， association 指的就是一对一， collection 指的就是一对多查询。在 Mybatis 配置文件中， 可以配置是否启用延迟加载  lazyLoadingEnabled=true|false。&lt;br&gt;
它的原理是， 使用 CGLIB 创建目标对象的代理对象， 当调用目标方法时， 进入拦截器方法， 比如调用 a.getB().getName()， 拦截器 invoke()方法发现 a.getB()是null 值， 那么就会单独发送事先保存好的查询关联 B 对象的 sql， 把 B 查询上来， 然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。&lt;br&gt;
当然了， 不光是 Mybatis， 几乎所有的包括 Hibernate， 支持延迟加载的原理都是一样的。&lt;/p&gt;
&lt;h2 id=&#34;二十三-mybatis-的一级-二级缓存&#34;&gt;二十三、Mybatis 的一级、二级缓存&lt;/h2&gt;
&lt;p&gt;1.一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存， 其存储作用域为Session， 当 Session flush  或  close  之后， 该  Session  中的所有  Cache  就将清空， 默认打开一级缓存。&lt;br&gt;
2.二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储， 不同在于其存储作用域为 Mapper(Namespace)， 并且可自定义存储源， 如 Ehcache。默认不打开二级缓存， 要开启二级缓存， 使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置&amp;lt; cache/&amp;gt; ；&lt;br&gt;
3.对于缓存数据更新机制， 当某一个作用域(一级缓存 Session/二级缓存&lt;br&gt;
Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear 。&lt;/p&gt;
&lt;h2 id=&#34;二十四-什么是-mybatis-的接口绑定有哪些实现方式&#34;&gt;二十四、什么是 MyBatis 的接口绑定？有哪些实现方式？&lt;/h2&gt;
&lt;p&gt;接口绑定，就是在 MyBatis 中任意定义接口,然后把&lt;strong&gt;接口里面的方法和 SQL 语句绑定&lt;/strong&gt;, 我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置。&lt;br&gt;
接口绑定有两种实现方式,一种是通过&lt;strong&gt;注解绑定&lt;/strong&gt;， 就是在接口的方法上面加上@Select、@Update 等注解， 里面包含 Sql 语句来绑定； 另外一种就是通过 &lt;strong&gt;xml 里面写 SQL 来绑定&lt;/strong&gt;, 在这种情况下,要指定 xml 映射文件里面的 namespace 必须为接口的&lt;em&gt;全路径名&lt;/em&gt;。&lt;em&gt;&lt;strong&gt;当 Sql 语句比较简单时候,用注解绑定, 当 SQL 语句比较复杂时候,用 xml 绑定,一般用 xml 绑定的比较多&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;h2 id=&#34;二十五-使用-mybatis-的mapper-接口调用时有哪些要求&#34;&gt;二十五、使用 MyBatis 的mapper 接口调用时有哪些要求？&lt;/h2&gt;
&lt;p&gt;1、Mapper 接口&lt;strong&gt;方法名&lt;/strong&gt;和 mapper.xml 中定义的每个 sql 的 &lt;strong&gt;id&lt;/strong&gt; 相同；&lt;br&gt;
2、Mapper 接口方法的输入&lt;strong&gt;参数类型&lt;/strong&gt;和 mapper.xml 中定义的每个 sql 的&lt;strong&gt;parameterType&lt;/strong&gt; 的类型相同；&lt;br&gt;
3、Mapper 接口方法的&lt;strong&gt;输出参数类型&lt;/strong&gt;和 mapper.xml 中定义的每个 sql 的&lt;strong&gt;resultType&lt;/strong&gt; 的类型相同；&lt;br&gt;
4、Mapper.xml 文件中的 &lt;strong&gt;namespace&lt;/strong&gt; 即是 mapper &lt;strong&gt;接口的类路径&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;二十六-mapper-编写有哪几种方式&#34;&gt;二十六、Mapper 编写有哪几种方式？&lt;/h2&gt;
&lt;p&gt;第一种： 接口实现类继承 SqlSessionDaoSupport： 使用此种方法需要编写mapper 接口， mapper 接口实现类、mapper.xml 文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//1、在 sqlMapConfig.xml 中配置 mapper.xml 的位置
&amp;lt;mappers&amp;gt;
&amp;lt;mapper resource=&amp;quot;mapper.xml 文件的地址&amp;quot; /&amp;gt;
&amp;lt;mapper resource=&amp;quot;mapper.xml 文件的地址&amp;quot; /&amp;gt;
&amp;lt;/mappers&amp;gt;
/*2、定义 mapper 接口
3、实现类集成 SqlSessionDaoSupport,mapper 方法中可以 this.getSqlSession()进行数据增删改查。
4、spring 配置*/
&amp;lt;bean id=&amp;quot; &amp;quot; class=&amp;quot;mapper 接口的实现&amp;quot;&amp;gt;
&amp;lt;property name=&amp;quot;sqlSessionFactory&amp;quot; ref=&amp;quot;sqlSessionFactory&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种： 使用 org.mybatis.spring.mapper.MapperFactoryBean：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//1、在 sqlMapConfig.xml 中配置 mapper.xml 的位置， 如果 mapper.xml 和mappre 接口的名称相同且在同一个目录， 这里可以不用配置
&amp;lt;mappers&amp;gt;
&amp;lt;mapper resource=&amp;quot;mapper.xml 文件的地址&amp;quot; /&amp;gt;
&amp;lt;mapper resource=&amp;quot;mapper.xml 文件的地址&amp;quot; /&amp;gt;
&amp;lt;/mappers&amp;gt;
/*2、定义 mapper 接口：
    1、mapper.xml 中的 namespace 为 mapper 接口的地址
    2、mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致
    3、Spring 中定义*/
&amp;lt;bean id=&amp;quot;&amp;quot; class=&amp;quot;org.mybatis.spring.mapper.MapperFactoryBean&amp;quot;&amp;gt;
&amp;lt;property name=&amp;quot;mapperInterface&amp;quot;	value=&amp;quot;mapper 接口地址&amp;quot; /&amp;gt;
&amp;lt;property name=&amp;quot;sqlSessionFactory&amp;quot; ref=&amp;quot;sqlSessionFactory&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三种： 使用 mapper 扫描器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/*1、mapper.xml 文件编写：
mapper.xml 中的 namespace 为 mapper 接口的地址；
mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致； 如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml 中进行配置。
2、定义 mapper 接口：
注意 mapper.xml 的文件名和 mapper 的接口名称保持一致， 且放在同一个目录3、配置 mapper 扫描器：*/
&amp;lt;bean class=&amp;quot;org.mybatis.spring.mapper.MapperScannerConfigurer&amp;quot;&amp;gt;
&amp;lt;property name=&amp;quot;basePackage&amp;quot; value=&amp;quot;mapper 接口包地址&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;property name=&amp;quot;sqlSessionFactoryBeanName&amp;quot; value=&amp;quot;sqlSessionFactory&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
//4、使用扫描器后从 spring 容器中获取 mapper 的实现对象。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二十七-简述-mybatis-的插件运行原理以及如何编写一个插件&#34;&gt;二十七、简述 Mybatis 的插件运行原理，以及如何编写一个插件。&lt;/h2&gt;
&lt;p&gt;答： Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、&lt;br&gt;
StatementHandler、Executor 这 4 种接口的插件， Mybatis 使用 JDK 的动态代理， 为需要拦截的接口生成代理对象以实现接口方法拦截功能， 每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke() 方法， 当然， 只会拦截那些你指定需要拦截的方法。&lt;br&gt;
编写插件： 实现 Mybatis 的 Interceptor 接口并复写 intercept()方法， 然后在给插件编写注解， 指定要拦截哪一个接口的哪些方法即可， 记住， 别忘了在配置文件中配置你编写的插件。&lt;/p&gt;
">源码框架专题1-MyBatis</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/yuan-ma-kuang-jia-zhuan-ti-2-spring/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;合抱之木始于毫末,万丈高楼起于垒土&lt;br&gt;
多多阅读，吸取精华&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1730296&#34;&gt; &lt;em&gt;持续更新...&lt;/em&gt;&lt;br&gt;
&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80-%E4%BB%80%E4%B9%88%E6%98%AFspring&#34;&gt;一、什么是spring?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C-%E4%BD%BF%E7%94%A8spring-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88&#34;&gt;二、使用Spring 框架的好处是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89-spring-%E7%94%B1%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%9D%97%E7%BB%84%E6%88%90&#34;&gt;三、Spring 由哪些模块组成?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B-%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87-%E6%A8%A1%E5%9D%97&#34;&gt;四、核心容器（应用上下文) 模块。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94-beanfactory-beanfactory-%E5%AE%9E%E7%8E%B0%E4%B8%BE%E4%BE%8B&#34;&gt;五、BeanFactory – BeanFactory 实现举例。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AD-xmlbeanfactory&#34;&gt;六、XMLBeanFactory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%83-%E8%A7%A3%E9%87%8Aaop-%E6%A8%A1%E5%9D%97&#34;&gt;七、解释AOP 模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AB-%E8%A7%A3%E9%87%8Ajdbc-%E6%8A%BD%E8%B1%A1%E5%92%8Cdao-%E6%A8%A1%E5%9D%97&#34;&gt;八、解释JDBC 抽象和DAO 模块。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B9%9D-%E8%A7%A3%E9%87%8A%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84%E9%9B%86%E6%88%90%E6%A8%A1%E5%9D%97&#34;&gt;九、解释对象/关系映射集成模块。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81-%E8%A7%A3%E9%87%8A-web-%E6%A8%A1%E5%9D%97&#34;&gt;十、解释 WEB 模块。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%B8%80-spring-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&#34;&gt;十一、Spring 配置文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%BA%8C-%E4%BB%80%E4%B9%88%E6%98%AF-spring-ioc-%E5%AE%B9%E5%99%A8&#34;&gt;十二、什么是 Spring IOC 容器？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%B8%89-ioc-%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88&#34;&gt;十三、IOC 的优点是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E5%9B%9B-applicationcontext-%E9%80%9A%E5%B8%B8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88&#34;&gt;十四、ApplicationContext 通常的实现是什么?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%BA%94-bean-%E5%B7%A5%E5%8E%82%E5%92%8C-application-contexts-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB&#34;&gt;十五、Bean 工厂和 Application contexts 有什么区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E5%85%AD-%E4%B8%80%E4%B8%AA-spring-%E7%9A%84%E5%BA%94%E7%94%A8%E7%9C%8B%E8%B5%B7%E6%9D%A5%E8%B1%A1%E4%BB%80%E4%B9%88&#34;&gt;十六、一个 Spring 的应用看起来象什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%B8%83-%E4%BB%80%E4%B9%88%E6%98%AF-spring-%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5&#34;&gt;十七、什么是 Spring 的依赖注入？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E5%85%AB-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84-ioc%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F&#34;&gt;十八、有哪些不同类型的 IOC（依赖注入）方式？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%B9%9D-%E5%93%AA%E7%A7%8D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E4%BD%A0%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5%E8%BF%98%E6%98%AF-setter-%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5&#34;&gt;十九、哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81-%E4%BB%80%E4%B9%88%E6%98%AF-spring-beans&#34;&gt;二十、什么是 Spring beans?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E4%B8%80-%E4%B8%80%E4%B8%AA-spring-bean-%E5%AE%9A%E4%B9%89-%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88&#34;&gt;二十一、一个 Spring Bean 定义  包含什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E4%BA%8C-%E5%A6%82%E4%BD%95%E7%BB%99-spring-%E5%AE%B9%E5%99%A8%E6%8F%90%E4%BE%9B%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE&#34;&gt;二十二、如何给 Spring 容器提供配置元数据?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E4%B8%89-%E4%BD%A0%E6%80%8E%E6%A0%B7%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F&#34;&gt;二十三、你怎样定义类的作用域?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E5%9B%9B-%E8%A7%A3%E9%87%8A-spring-%E6%94%AF%E6%8C%81%E7%9A%84%E5%87%A0%E7%A7%8Dbean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F&#34;&gt;二十四、解释 Spring 支持的几种bean 的作用域。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E4%BA%94-spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B-bean-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97&#34;&gt;二十五、Spring 框架中的单例 bean 是线程安全的吗?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E5%85%AD-%E8%A7%A3%E9%87%8A-spring-%E6%A1%86%E6%9E%B6%E4%B8%ADbean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&#34;&gt;二十六、解释 Spring 框架中bean 的生命周期。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E4%B8%83-%E5%93%AA%E4%BA%9B%E6%98%AF%E9%87%8D%E8%A6%81%E7%9A%84-bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E4%BD%A0%E8%83%BD%E9%87%8D%E8%BD%BD%E5%AE%83%E4%BB%AC%E5%90%97&#34;&gt;二十七、哪些是重要的 bean 生命周期方法？你能重载它们吗？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E5%85%AB-%E4%BB%80%E4%B9%88%E6%98%AF-spring-%E7%9A%84%E5%86%85%E9%83%A8bean&#34;&gt;二十八、什么是 Spring 的内部bean？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8D%81%E4%B9%9D-%E5%9C%A8-spring-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%B3%A8%E5%85%A5%E4%B8%80%E4%B8%AAjava-%E9%9B%86%E5%90%88&#34;&gt;二十九、在 Spring 中如何注入一个java 集合？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E5%8D%81-%E4%BB%80%E4%B9%88%E6%98%AF-bean-%E8%A3%85%E9%85%8D&#34;&gt;三十、什么是 bean 装配?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1730296&#34;&gt; *持续更新...*
@[TOC](Spring目录)&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一-什么是spring&#34;&gt;一、什么是spring?&lt;/h2&gt;
&lt;p&gt;Spring 是个 java 企业级应用的开源开发框架。Spring 主要用来开发 Java 应用， 但是有些扩展是针对构建 J2EE 平台的 web 应用。Spring  框架目标是简化 Java 企业级应用开发， 并通过 POJO 为基础的编程模型促进良好的编程习惯。&lt;/p&gt;
&lt;h2 id=&#34;二-使用spring-框架的好处是什么&#34;&gt;二、使用Spring 框架的好处是什么？&lt;/h2&gt;
&lt;p&gt;•	轻量：Spring 是轻量的，基本的版本大约 2MB。&lt;br&gt;
•		控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。&lt;br&gt;
•	面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务&lt;br&gt;
逻辑和系统服务分开。&lt;br&gt;
•	容器：Spring 包含并管理应用中对象的生命周期和配置。&lt;br&gt;
•		MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。&lt;br&gt;
•		事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。&lt;br&gt;
•		异常处理：Spring  提供方便的API 把具体技术相关的异常（比如由JDBC， Hibernate or JDO 抛出的）转化为一致的 unchecked 异常。&lt;/p&gt;
&lt;h2 id=&#34;三-spring-由哪些模块组成&#34;&gt;三、Spring 由哪些模块组成?&lt;/h2&gt;
&lt;p&gt;以下是 Spring 框架的基本模块：&lt;br&gt;
•	Core module&lt;br&gt;
•	Bean module&lt;br&gt;
•	Context module&lt;br&gt;
•	Expression Language module&lt;br&gt;
•	JDBC module&lt;br&gt;
•	ORM module&lt;br&gt;
•	OXM module&lt;br&gt;
•	Java Messaging Service(JMS) module&lt;br&gt;
•	Transaction module&lt;br&gt;
•	Web module&lt;br&gt;
•	Web-Servlet module&lt;br&gt;
•	Web-Struts module&lt;br&gt;
•	Web-Portlet module&lt;/p&gt;
&lt;h2 id=&#34;四-核心容器应用上下文-模块&#34;&gt;四、核心容器（应用上下文) 模块。&lt;/h2&gt;
&lt;p&gt;这是基本的 Spring 模块， 提供 spring 框架的基础功能， BeanFactory 是 任何以 spring 为基础的应用的核心。Spring 框架建立在此模块之上，它使 Spring 成为一个容器。&lt;/p&gt;
&lt;h2 id=&#34;五-beanfactory-beanfactory-实现举例&#34;&gt;五、BeanFactory – BeanFactory 实现举例。&lt;/h2&gt;
&lt;p&gt;Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从正真的应用代码中分离。&lt;br&gt;
最常用的 BeanFactory 实现是 XmlBeanFactory 类。&lt;/p&gt;
&lt;h2 id=&#34;六-xmlbeanfactory&#34;&gt;六、XMLBeanFactory&lt;/h2&gt;
&lt;p&gt;最常用的就是 org.springframework.beans.factory.xml.XmlBeanFactory ， 它根据 XML 文件中的定义加载 beans。该容器从 XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。&lt;/p&gt;
&lt;h2 id=&#34;七-解释aop-模块&#34;&gt;七、解释AOP 模块&lt;/h2&gt;
&lt;p&gt;AOP 模块用于发给我们的 Spring 应用做&lt;strong&gt;面向切面&lt;/strong&gt;的开发， 很多支持由 AOP 联盟提供， 这样就确保了 Spring 和其他 AOP 框架的共通性。这个模块&lt;strong&gt;将元数据编程引入 Spring&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;八-解释jdbc-抽象和dao-模块&#34;&gt;八、解释JDBC 抽象和DAO 模块。&lt;/h2&gt;
&lt;p&gt;通过使用 JDBC 抽象和 DAO 模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题， 它在各种不同的数据库的错误信息之上， 提供了一个统一的异常访问层。它还利用 Spring 的 AOP 模块给 Spring 应用中的对象提供事务管理服务。&lt;/p&gt;
&lt;h2 id=&#34;九-解释对象关系映射集成模块&#34;&gt;九、解释对象/关系映射集成模块。&lt;/h2&gt;
&lt;p&gt;Spring 通过提供 ORM 模块，支持我们在直接 JDBC 之上使用一个对象/关系映射映射(ORM)工具，Spring   支持集成主流的 ORM 框架，如 Hiberate,JDO 和   iBATIS SQL Maps。Spring 的事务管理同样支持以上所有 ORM 框架及 JDBC。&lt;/p&gt;
&lt;h2 id=&#34;十-解释-web-模块&#34;&gt;十、解释 WEB 模块。&lt;/h2&gt;
&lt;p&gt;Spring 的 WEB 模块是构建在 application context 模块基础之上， 提供一个适合 web 应用的上下文。这个模块也包括支持多种面向 web 的任务，如透明地处理多个文件上传请求和程序级请求参数的绑定到你的业务对象。它也有对 Jakarta Struts 的支持。&lt;/p&gt;
&lt;h2 id=&#34;十一-spring-配置文件&#34;&gt;十一、Spring 配置文件&lt;/h2&gt;
&lt;p&gt;Spring 配置文件是个 &lt;strong&gt;XML&lt;/strong&gt; 文件，这个文件包含了&lt;strong&gt;类信息&lt;/strong&gt;，描述了&lt;strong&gt;如何配置&lt;/strong&gt;它们， 以及&lt;strong&gt;如何相互调用&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;十二-什么是-spring-ioc-容器&#34;&gt;十二、什么是 Spring IOC 容器？&lt;/h2&gt;
&lt;p&gt;Spring IOC 负责&lt;strong&gt;创建对象，管理对象&lt;/strong&gt;（ 通过依赖注入（ &lt;strong&gt;DI&lt;/strong&gt;），&lt;strong&gt;装配&lt;/strong&gt;对象，&lt;strong&gt;配置&lt;/strong&gt;对象， 并且管理这些对象的整个&lt;strong&gt;生命周期&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;十三-ioc-的优点是什么&#34;&gt;十三、IOC 的优点是什么？&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;IOC 或 依赖注入&lt;/em&gt;把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和 JNDI 查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC 容器&lt;strong&gt;支持加载服务时的饿汉式初始化和懒加载&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;十四-applicationcontext-通常的实现是什么&#34;&gt;十四、ApplicationContext 通常的实现是什么?&lt;/h2&gt;
&lt;p&gt;•FileSystemXmlApplicationContext ：此容器从一个 XML 文件中加载 beans 的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。&lt;br&gt;
•ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载beans 的定义，这里，你需要正确设置 classpath 因为这个容器将在classpath 里找 bean 配置。&lt;br&gt;
•	WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个 WEB 应用的所有 bean。&lt;/p&gt;
&lt;h2 id=&#34;十五-bean-工厂和-application-contexts-有什么区别&#34;&gt;十五、Bean 工厂和 Application contexts 有什么区别？&lt;/h2&gt;
&lt;p&gt;Application contexts 提供一种方法处理文本消息， 一个通常的做法是加载文件资源（ 比如镜像），它们可以向注册为监听器的 bean 发布事件。另外，在容器或容器内的对象上执行的那些不得不由 bean 工厂以程序化方式处理的操作，可以在Application contexts 中以声明的方式处理。Application contexts 实现了&lt;br&gt;
MessageSource 接口， 该接口的实现以可插拔的方式提供获取本地化消息的方法。&lt;/p&gt;
&lt;h2 id=&#34;十六-一个-spring-的应用看起来象什么&#34;&gt;十六、一个 Spring 的应用看起来象什么？&lt;/h2&gt;
&lt;p&gt;•	一个定义了一些功能的接口。&lt;br&gt;
•	这实现包括属性，它的 Setter ， getter 方法和函数等。&lt;br&gt;
•	Spring AOP。&lt;br&gt;
•	Spring 的 XML 配置文件。&lt;br&gt;
•	使用以上功能的客户端程序。&lt;br&gt;
依赖注入&lt;/p&gt;
&lt;h2 id=&#34;十七-什么是-spring-的依赖注入&#34;&gt;十七、什么是 Spring 的依赖注入？&lt;/h2&gt;
&lt;p&gt;依赖注入， 是 IOC 的一个方面， 是个通常的概念， 它有多种解释。这概念是说你&lt;strong&gt;不用创建对象， 而只需要描述它如何被创建&lt;/strong&gt;。你不在代码里直接组装你的组件和服务， 但是要在配置文件里描述哪些组件需要哪些服务， 之后一个容器（ &lt;strong&gt;IOC 容器） 负责把他们组装起来&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;十八-有哪些不同类型的-ioc依赖注入方式&#34;&gt;十八、有哪些不同类型的 IOC（依赖注入）方式？&lt;/h2&gt;
&lt;p&gt;•		&lt;strong&gt;构造器依赖注入&lt;/strong&gt;：构造器依赖注入通过&lt;strong&gt;容器触发一个类的构造器&lt;/strong&gt;来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。&lt;br&gt;
•		&lt;strong&gt;Setter 方法注入&lt;/strong&gt;：Setter 方法注入是容器通过&lt;strong&gt;调用无参构造器或无参static 工厂 方法实例化 bean&lt;/strong&gt; 之后，调用该 bean 的 setter 方法，即实现了基于 setter 的依赖注入。&lt;/p&gt;
&lt;h2 id=&#34;十九-哪种依赖注入方式你建议使用构造器注入还是-setter-方法注入&#34;&gt;十九、哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？&lt;/h2&gt;
&lt;p&gt;两种依赖方式都可以使用， 构造器注入和 Setter 方法注入。最好的解决方案是用构造器参数实现强制依赖， setter 方法实现可选依赖。&lt;br&gt;
Spring Beans&lt;/p&gt;
&lt;h2 id=&#34;二十-什么是-spring-beans&#34;&gt;二十、什么是 Spring beans?&lt;/h2&gt;
&lt;p&gt;Spring beans 是那些形成 Spring 应用的主干的 java 对象。它们被 Spring IOC 容器初始化， 装配， 和管理。这些 beans 通过容器中配置的元数据创建。比如， 以 XML 文件中 的形式定义。&lt;br&gt;
Spring 框架定义的 beans 都是单件 beans。在 bean tag 中有个属性”&lt;br&gt;
&lt;strong&gt;singleton&lt;/strong&gt;”， 如果它被赋为  TRUE， bean   就是单件， 否则就是一个   &lt;strong&gt;prototype bean&lt;/strong&gt;。&lt;strong&gt;默认是 TRUE&lt;/strong&gt;， 所以所有在 Spring 框架中的 beans 缺省都是单件。&lt;/p&gt;
&lt;h2 id=&#34;二十一-一个-spring-bean-定义-包含什么&#34;&gt;二十一、一个 Spring Bean 定义  包含什么？&lt;/h2&gt;
&lt;p&gt;一个 Spring Bean 的定义包含容器必知的所有&lt;strong&gt;配置元数据&lt;/strong&gt;， 包括&lt;strong&gt;如何创建&lt;/strong&gt;一个bean， 它的&lt;strong&gt;生命周期&lt;/strong&gt;详情及它的&lt;strong&gt;依赖&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;二十二-如何给-spring-容器提供配置元数据&#34;&gt;二十二、如何给 Spring 容器提供配置元数据?&lt;/h2&gt;
&lt;p&gt;有三种重要的方法给 Spring 容器提供配置元数据。&lt;strong&gt;XML&lt;/strong&gt; 配置文件。&lt;br&gt;
基于&lt;strong&gt;注解&lt;/strong&gt;的配置。基于 &lt;strong&gt;java&lt;/strong&gt; 的配置。&lt;/p&gt;
&lt;h2 id=&#34;二十三-你怎样定义类的作用域&#34;&gt;二十三、你怎样定义类的作用域?&lt;/h2&gt;
&lt;p&gt;当定义一个 在 Spring 里， 我们还能给这个 bean 声明一个作用域。它可以通过bean 定义中的 &lt;strong&gt;scope&lt;/strong&gt; 属性来定义。如，当 Spring 要在需要的时候scope 新的 bean 实例，bean 的 scope 属性被指定为 &lt;strong&gt;prototype&lt;/strong&gt;。另一方面，一个 bean每次使用的时候&lt;strong&gt;必须返回同一个实例&lt;/strong&gt;， 这个 bean 的 scope 属性 必须设为&lt;strong&gt;singleton&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;二十四-解释-spring-支持的几种bean-的作用域&#34;&gt;二十四、解释 Spring 支持的几种bean 的作用域。&lt;/h2&gt;
&lt;p&gt;Spring 框架支持以下五种 bean 的作用域：&lt;/p&gt;
&lt;p&gt;•	&lt;strong&gt;singleton&lt;/strong&gt; : bean 在每个 Spring ioc 容器中&lt;strong&gt;只有一个实例&lt;/strong&gt;。&lt;br&gt;
•	&lt;strong&gt;prototype&lt;/strong&gt;：一个 bean 的定义可以有&lt;strong&gt;多个实例&lt;/strong&gt;。&lt;br&gt;
•	request：每次 http 请求都会创建一个 bean，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。&lt;br&gt;
•	session：在一个 HTTP Session 中，一个 bean 定义对应一个实例。该&lt;br&gt;
作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。&lt;br&gt;
•	lobal-session：在一个全局的 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。&lt;br&gt;
缺省的 Spring bean 的作用域是 Singleton.&lt;/p&gt;
&lt;h2 id=&#34;二十五-spring-框架中的单例-bean-是线程安全的吗&#34;&gt;二十五、Spring 框架中的单例 bean 是线程安全的吗?&lt;/h2&gt;
&lt;p&gt;不， Spring 框架中的单例 bean &lt;strong&gt;不是线程安全的&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;二十六-解释-spring-框架中bean-的生命周期&#34;&gt;二十六、解释 Spring 框架中bean 的生命周期。&lt;/h2&gt;
&lt;p&gt;•	Spring 容器 从 XML 文件中读取 bean 的定义，并实例化 bean。&lt;br&gt;
•	Spring 根据 bean 的定义填充所有的属性。&lt;br&gt;
•		如果bean 实现了BeanNameAware  接口，Spring  传递bean  的ID  到 setBeanName 方法。&lt;br&gt;
•		如果 Bean 实现了 BeanFactoryAware 接口， Spring 传递beanfactory 给 setBeanFactory 方 法 。&lt;br&gt;
•		如果有任何与 bean 相关联的 BeanPostProcessors，Spring 会在postProcesserBeforeInitialization()方法内调用它们。&lt;br&gt;
•		如果 bean 实现 IntializingBean 了，调用它的 afterPropertySet 方法， 如果 bean 声明了初始化方法，调用此初始化方法。&lt;br&gt;
•		如果有 BeanPostProcessors 和 bean 关联，这些 bean 的postProcessAfterInitialization() 方法将被调用。&lt;br&gt;
•	如果 bean 实现了 DisposableBean，它将调用 destroy()方法。&lt;/p&gt;
&lt;h2 id=&#34;二十七-哪些是重要的-bean-生命周期方法你能重载它们吗&#34;&gt;二十七、哪些是重要的 bean 生命周期方法？你能重载它们吗？&lt;/h2&gt;
&lt;p&gt;有两个重要的 bean 生命周期方法， 第一个是 &lt;strong&gt;setup&lt;/strong&gt; ， 它是在容器加载 bean 的时候被调用。第二个方法是 &lt;strong&gt;teardown&lt;/strong&gt; 它是在容器卸载类的时候被调用。&lt;br&gt;
The bean 标签有两个重要的属性（ init-method 和 destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（ @PostConstruct 和@PreDestroy）。&lt;/p&gt;
&lt;h2 id=&#34;二十八-什么是-spring-的内部bean&#34;&gt;二十八、什么是 Spring 的内部bean？&lt;/h2&gt;
&lt;p&gt;当一个 bean 仅被用作另一个 bean 的属性时， 它能被声明为一个内部 bean， 为了定义 inner bean， 在 Spring 的 基于 XML 的 配置元数据中， 可以在  或  元素内使用 元素， 内部 bean 通常是匿名的， 它们的 Scope 一般是 prototype。&lt;/p&gt;
&lt;h2 id=&#34;二十九-在-spring-中如何注入一个java-集合&#34;&gt;二十九、在 Spring 中如何注入一个java 集合？&lt;/h2&gt;
&lt;p&gt;Spring 提供以下几种集合的配置元素：&lt;br&gt;
•	类型用于注入一列值，允许有相同的值。&lt;br&gt;
•	类型用于注入一组值，不允许有相同的值。&lt;br&gt;
•	类型用于注入一组键值对，键和值都可以为任意类型。&lt;br&gt;
•	类型用于注入一组键值对，键和值都只能为 String 类型。&lt;/p&gt;
&lt;h2 id=&#34;三十-什么是-bean-装配&#34;&gt;三十、什么是 bean 装配?&lt;/h2&gt;
&lt;p&gt;装配，或 bean 装配是指在 Spring 容器中把 bean 组装到一起，前提是容器需要知道 bean 的依赖关系， 如何通过依赖注入来把它们装配到一起。&lt;/p&gt;
">源码框架专题2-Spring</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/zhu-jie-jie-huo/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;记录学习中用到的一些注解&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-4147263&#34;&gt; &lt;em&gt;持续更新...&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-4147263&#34;&gt; *持续更新...*&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mapper&#34;&gt;@mapper&lt;/h2&gt;
&lt;p&gt;mapper/dao包——&lt;strong&gt;@Mapper&lt;/strong&gt;将Mapper接口交给Mybatis管理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//@Mapper  //省略此处注解去启动类中加
public interface UserMapper extends BaseMapper&amp;lt;User&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动类——&lt;strong&gt;@MapperScan&lt;/strong&gt;代替了Mapper接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
@MapperScan(&amp;quot;com.pj.mapper&amp;quot;)//代替了Mapper接口 扫描此包下面的文件，方便快捷
public class SpringbootDemoApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringbootDemo2Application.class, args);
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pojo包——&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Data   //动态生成get/set/toString/equals等方法
@Accessors(chain = true) //开启链式加载结构 重构了set方法可以连续.
@NoArgsConstructor  //无参构造 必须添加
@AllArgsConstructor //全参构造

//@TableName(&amp;quot;User&amp;quot;)//标识对象与表的映射关系，如表明与对象名一致则可省略不写
@TableName
public class User {
    //实体对象的属性类型应该都是包装类型  Integer null int=0
    @TableId(type= IdType.AUTO)//主键自增写法
    private Integer id;
    //@TableField(value = &amp;quot;name&amp;quot;) //标识字段的属性 --一致可以不写
    private String name;
    private Integer age;
    private String sex;

   /* 链式加载源码
        public User setId(Integer id){
        this.id = id;
        return this;
    }*/
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;pathvariable&#34;&gt;@PathVariable&lt;/h2&gt;
&lt;p&gt;@PathVariable是spring3.0的一个新功能：接收请求路径中&lt;strong&gt;占位符&lt;/strong&gt;的值&lt;br&gt;
通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;s&gt;在Web应用中URL通常不是一成不变的，例如微博两个不同用户的个人主页对应两个不同的URL：http://weibo.com/user1,http://weibo.com/user2。我们不能对于每一个用户都编写一个被@RequestMapping注解的方法来处理其请求，也就是说，对于&lt;strong&gt;相同模式的URL&lt;/strong&gt;（例如不同用户的主页，它们仅仅是URL中的&lt;strong&gt;某一部分不同&lt;/strong&gt;，为他们各自的用户名，我们说它们具有相同的模式）&lt;/s&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//例
//在默认的情况下，Spring会对@PathVariable注解的变量进行自动赋值，
//当然你也可以指定@PathVariable使用哪一个URL中的变量
@GetMapping(&amp;quot;/page/{moduleName}&amp;quot;)
	//@PathVariable(&amp;quot;moduleName&amp;quot;) 可省略变量
	public String module(@PathVariable String moduleName) {
		
		return moduleName;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20201105001216334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;param&#34;&gt;@Param&lt;/h2&gt;
&lt;p&gt;@Param注解的作用是给&lt;strong&gt;参数命名&lt;/strong&gt;,参数命名后就能根据名字得到参数值,正确的将&lt;strong&gt;参数传入sql语句&lt;/strong&gt;中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;该注解我还需再查阅资料做修改&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// mapper/dao接口层  加@Param
void update( @Param(&amp;quot;status&amp;quot;) Integer status,@Param(&amp;quot;ids&amp;quot;) Long[] ids);

// xml映射层
	&amp;lt;update id=&amp;quot;update&amp;quot;&amp;gt;
update tb_item set status=#{status} where id in (
		&amp;lt;foreach collection=&amp;quot;ids&amp;quot; item=&amp;quot;id&amp;quot; separator=&amp;quot;,&amp;quot;&amp;gt;
			#{id}
		&amp;lt;/foreach&amp;gt;
		)
	&amp;lt;/update&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
">注解解惑</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/springboot-pei-zhi-wen-jian-de-shuo-ming/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#properties%E8%AF%B4%E6%98%8E&#34;&gt;properties说明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#yml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E&#34;&gt;YML配置文件说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
(目录)&lt;/p&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-3462779&#34;&gt; &lt;em&gt;持续更新...&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-3462779&#34;&gt; *持续更新...*&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;properties说明&#34;&gt;properties说明&lt;/h2&gt;
&lt;p&gt;1.语法: k-v结构 key=value&lt;br&gt;
2.数据类型: 默认是String数据类型 不要添加多余的&amp;quot;&amp;quot;号&lt;br&gt;
3.字符数据类型: properties的默认的加载的编码格式为ISO-8859-1 所以添加中文是需要字符转意.&lt;br&gt;
4.缺点: 所有的key都必须手动的编辑 没有办法复用 所以引入了yml配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//例
server.port=80
server.servlet.context-path=/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;yml配置文件说明&#34;&gt;YML配置文件说明&lt;/h2&gt;
&lt;p&gt;1.语法 K-V结构 写法上 key:value 实质上 key=value&lt;br&gt;
key:value中间使用 (:+空格) 分隔&lt;br&gt;
key与key之间有父子级关系的. 所以写的时候注意缩进项.&lt;br&gt;
YML配置文件默认的格式都是UTF-8编码 所以可以直接编辑中文&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//例：
server:
  port: 80//注意空格和上下级关系
  servlet:
    context-path: /
&lt;/code&gt;&lt;/pre&gt;
">SpringBoot配置文件的说明</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/jd-tu-pian-qu-shui-yin/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;实用&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.打开JD，打开任意商品，右键复制图片链接地址&lt;br&gt;
&lt;img src=&#34;https://blog9527.github.io/post-images/1653098398392.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2.新开标签页 粘贴图片链接地址&lt;br&gt;
&lt;img src=&#34;https://blog9527.github.io/post-images/1653098515856.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;3.将n0参数改为&lt;strong&gt;imgzone&lt;/strong&gt;即可&lt;br&gt;
&lt;img src=&#34;https://blog9527.github.io/post-images/1653098676133.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">JD图片去水印</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/linux-jian-dan-gai-shu/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Linux简单介绍&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;11linux概述&#34;&gt;1.1	Linux概述&lt;/h3&gt;
&lt;p&gt;1.1.1	Linux介绍&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。&lt;br&gt;
Linux操作系统&lt;strong&gt;诞生于1991 年10 月5 日&lt;/strong&gt;（这是第一次正式向外公布时间）。Linux存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。&lt;br&gt;
严格来讲，Linux这个词本身只&lt;strong&gt;表示Linux内核&lt;/strong&gt;，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU工程各种工具和数据库的操作系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.1.	Linux系统层级结构&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201109175606580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
1.1.3	Linux特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统开源并且免费&lt;/li&gt;
&lt;li&gt;对硬件要求很低 800M  3-4&lt;/li&gt;
&lt;li&gt;系统稳定性强&lt;/li&gt;
&lt;li&gt;系统安全性更好  (军工企业 断网)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1.1.4	Linux系统主流产品&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201109175741300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Linux简单概述</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/bi-ji-pian-zhi-wei-fu-wu/"" data-c="
          &lt;h3 id=&#34;spring-cloud-介绍&#34;&gt;&lt;strong&gt;spring cloud 介绍&lt;/strong&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;spring cloud 是&lt;strong&gt;一系列框架的集合&lt;/strong&gt;。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，&lt;strong&gt;如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等&lt;/strong&gt;，都可以用 spring boot 的开发风格做到一键启动和部署。spring cloud 并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 spring boot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套&lt;strong&gt;简单易懂、易部署和易维护&lt;/strong&gt;的分布式系统开发工具包。&lt;/p&gt;
&lt;p&gt;spring cloud&lt;br&gt;
对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用 spring&lt;br&gt;
cloud &lt;strong&gt;一站式解决方案&lt;/strong&gt;能在从容应对业务发展的同时&lt;strong&gt;大大减少开发成本&lt;/strong&gt;。同时，随着近几年微服务架构和 docker 容器概念的火爆，也会让&lt;br&gt;
spring cloud&lt;br&gt;
在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在目前五花八门的分布式解决方案中提供了&lt;strong&gt;标准化&lt;/strong&gt;的、一站式的技术方案，意义可能会堪比当年&lt;br&gt;
servlet 规范的诞生，有效推进服务端软件系统技术水平的进步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;spring-cloud技术组成&#34;&gt;&lt;strong&gt;spring cloud技术组成&lt;/strong&gt;&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20201123192801125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;eureka&lt;br&gt;
微服务治理，服务注册和发现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;ribbon&lt;br&gt;
负载均衡、请求重试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;hystrix&lt;br&gt;
断路器，服务降级、熔断&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;feign&lt;br&gt;
ribbon + hystrix集成，并提供声明式客户端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;hystrix dashboard 和 turbine&lt;br&gt;
hystrix 数据监控&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;zuul&lt;br&gt;
API 网关，提供微服务的统一入口，并提供统一的权限验证&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;config&lt;br&gt;
配置中心&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;bus&lt;br&gt;
消息总线, 配置刷新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;sleuth+zipkin&lt;br&gt;
链路跟踪&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;spring-cloud-对比-dubbo&#34;&gt;Spring Cloud 对比 Dubbo&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20201123193406653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;Dubbo&lt;br&gt;
Dubbo只是一个远程调用(RPC)框架 默认基于长连接,支持多种序列化格式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring Cloud&lt;br&gt;
框架集 提供了一整套微服务解决方案(全家桶) 基于http调用, Rest API&lt;br&gt;
这里是引用&lt;/p&gt;
&lt;/blockquote&gt;
">笔记篇之微服务</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/dbsql-zuo-you-nei-wai-quan-lian-jie/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;概念已记录完毕，待提供案例......&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SQL中表连接&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;join（inner join）--&lt;strong&gt;内连接&lt;/strong&gt;: 只连接匹配的行；&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201211084841186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;left join/left outer join--&lt;strong&gt;左连接/左外连接&lt;/strong&gt;:  返回左表中全部行（不管右边中是否存在与它们匹配的行），以及右表中全部匹配的行；&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201211084925105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;right join/right outer join --&lt;strong&gt;右连接/右外连接&lt;/strong&gt;:  包含右表的全部行（不管左表中是否存在它们匹配的行），以及左表中全部匹配的行；&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20201211084941371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;full join/full outer join--&lt;strong&gt;全连接/全外连接&lt;/strong&gt;：  包含左右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行；&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
">DB·SQL左右内外全连接</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/povoge-dui-xiang-de-qu-bie/"" data-c="
          &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Entity（实体）&lt;br&gt;
基本和数据表对应，&lt;strong&gt;一个实体一张表&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;PO（persistent object）&lt;br&gt;
代表&lt;strong&gt;持久层对象&lt;/strong&gt;，对应数据库中表的字段，可以理解为&lt;strong&gt;一个PO就是数据库中的一条记录&lt;/strong&gt;，没有增加别的属性和方法。持久对象由insert数据库创建 delete删除。&lt;/li&gt;
&lt;li&gt;VO（value object）&lt;br&gt;
值对象，用于&lt;strong&gt;业务层之间的数据传递&lt;/strong&gt;。主要体现在【&lt;strong&gt;视图&lt;/strong&gt;】的对象，&lt;strong&gt;对应展示界面显示的数据对象&lt;/strong&gt;，一个VO对象来封装整个界面展示所需要的对象数据，在控制层与视图层进行传输交换。&lt;/li&gt;
&lt;li&gt;BO（business object）&lt;br&gt;
&lt;strong&gt;业务对象层&lt;/strong&gt;，&lt;strong&gt;封装业务逻辑&lt;/strong&gt;的java对象，通过调用dao方法，结合 &lt;strong&gt;po 、vo&lt;/strong&gt;进行业务操作；&lt;/li&gt;
&lt;li&gt;DTO（Data Transfer Object）&lt;br&gt;
&lt;strong&gt;数据传输&lt;/strong&gt;对象，是一种设计模式之间传输数据的软件应用系统。数据传输目标往往是数据访问对象从数据库中检索数据。&lt;strong&gt;（接口间传递的数据封装）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;POJO(Plain Ordinary Java Object)&lt;br&gt;
简单的java对象。实际就是普通JavaBeans，最基本的Java Bean只有属性加上属性的get和set方法。&lt;br&gt;
&lt;strong&gt;一个POJO持久化以后就是PO；&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;直接用它传递、传递过程中就是DTO；&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;直接用来对应表示层就是VO&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Dao（data access object）&lt;br&gt;
数据访问对象。主要用来&lt;strong&gt;封装对数据的访问&lt;/strong&gt;，注意，是对数据的访问，不是对数据库的访问。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;1.Controller&lt;br&gt;
代表控制层，主要是Action/Servlet等构成,此层业务层与视图层打交道的中间层，负责传输VO对象和调用BO层的业务方法，负责视图层请求的数据处理后响应给视图层。&lt;br&gt;
2. View&lt;br&gt;
代表视图层的意思，主要是指由JSP、HTML等文件形成的显示层。&lt;br&gt;
所以实际项目中，一般都是这样应用的：&lt;br&gt;
控制层(controller-action)，业务层/服务层( bo-manager-service)，实体层(po-entity)，dao(dao)，视图对象(Vo-)，视图层(view-jsp/html)&lt;/p&gt;
&lt;/blockquote&gt;
">PO、VO...各对象的区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/base64-zhuan-tu-pian-tu-pian-zhuan-base64/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;base64转图片,方法一：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  /**
    * 1.base64转图片
   * @param base64str1 base64码
     * @param savePath 图片路径
    * @return
  */
public static boolean GenerateImage(String base64str1, String savePath) {
  //对字节数组字符串进行Base64解码并生成图片
   /**
     * 改编--需截取base64前缀方可转成功
      */
    String base64str = StringUtils.substringAfter(base64str1, &amp;quot;data:image/jpg;base64,&amp;quot;);
   //
    if (base64str == null) {
        return false;
    }
    BASE64Decoder decoder = new BASE64Decoder();
    try {
         //Base64解码
        byte[] b = decoder.decodeBuffer(base64str);
     // 处理数据
      for (int i = 0; i &amp;lt; b.length; ++i) {
         //调整异常数据
          if (b[i] &amp;lt; 0) {
              b[i] += 256;
        }
    }
       //文件夹不存在则自动创建
      File tempFile = new File(savePath);
      if (!tempFile.getParentFile().exists()) {
            tempFile.getParentFile().mkdirs();
       }
      //生成jpeg图片
      OutputStream out = new FileOutputStream(tempFile);
     out.write(b);
    out.flush();
         out.close();
         System.out.println(&amp;quot;*****转图片成功******&amp;quot;);
         return true;
      } catch (Exception e) {
         System.out.println(&amp;quot;*****转图片失败******&amp;quot;);
          return false;
       }
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;base64转图片,方法二：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; /**
     * 2.base64转图片
    * @param base64Code base64码
    */
    public static void convertBase64ToImage(String base64Code){
        BufferedImage image = null;
        byte[] imageByte = null;
        try {
            imageByte = DatatypeConverter.parseBase64Binary(base64Code);
            ByteArrayInputStream bis = new ByteArrayInputStream(imageByte);
            image = ImageIO.read(new ByteArrayInputStream(imageByte));
            bis.close();
            File outputfile = new File(&amp;quot;D:/sealImg.jpg&amp;quot;);
            ImageIO.write(image, &amp;quot;jpg&amp;quot;, outputfile);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;图片转base64字符串：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * 图片转base64字符串
     *
     * @param imgFile 图片路径
     * @return
     */
    public static String imageToBase64Str(String imgFile) {
        InputStream inputStream = null;
        byte[] data = null;
       try {
            inputStream = new FileInputStream(imgFile);
            data = new byte[inputStream.available()];
            inputStream.read(data);
            inputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        // 加密
        BASE64Encoder encoder = new BASE64Encoder();
        return encoder.encode(data);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
">base64转图片+图片转base64</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/linux-zhi-ming-ling-ji/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Linux的一些命令集&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;说明:Linux全部都是&lt;strong&gt;基于文件&lt;/strong&gt;的. 并且Linux中的目录都是&lt;strong&gt;树形结构&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12linux命令&#34;&gt;1.2Linux命令&lt;/h3&gt;
&lt;p&gt;1.2.1	cd命令集&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ifconfig/ ip addr		--检查IP地址&lt;br&gt;
pwd		--检查当前的位置&lt;br&gt;
tab键		--自动补齐（注意唯一性）&lt;br&gt;
&lt;strong&gt;cd命令是linux中最基本的命令语句，必须熟练掌握&lt;/strong&gt;&lt;br&gt;
cd /		--返回根目录&lt;br&gt;
cd ~		--用户主目录&lt;br&gt;
cd.		--当前目录&lt;br&gt;
cd..		--返回上一级目录&lt;br&gt;
cd /usr/		--进入到usr目录&lt;br&gt;
cd -		--返回上一个目录&lt;br&gt;
cd		--直接回家&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.2.2	ls目录和文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ls -1		--详细格式，文件权限，时间&lt;br&gt;
ll和ls -1		--作用相同&lt;br&gt;
ls *.txt		--查看所有的txt类型文档&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.2.3	目录操作&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mkdir		--创建目录&lt;br&gt;
mkdir a		--创建a目录&lt;br&gt;
mkdir -p a/b		--创建a目录，并在a目录里创建b目录&lt;br&gt;
mkdir -m 777 c 		--创建一个权限为777的目录&lt;br&gt;
rmdir		--删除目录（如果目录里有文件，则不能用此命令）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.2.4	Vi/vim创建/查看/编辑文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;命令行：Esc切换到命令行模式&lt;br&gt;
编辑模式：&lt;br&gt;
按i，在光标前开始编辑&lt;br&gt;
按a，在光标后开始编辑&lt;br&gt;
按o，在当前行的下一行开始编辑&lt;br&gt;
按u，撤销之前的操作&lt;br&gt;
底层模式： 按 shift+: 冒号&lt;br&gt;
:q!		--不保存退出&lt;br&gt;
:q 		--（未作任何修改）退出&lt;br&gt;
:wq		--保存退出&lt;br&gt;
:/word		--从当前光标处，向上查找world关键字&lt;br&gt;
:?word		--从当前光标处，向后查找world关键字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.2.5	删除文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;rm		--删除文件&lt;br&gt;
rm n.txt		--提示 y删除 n放弃&lt;br&gt;
rm -f n.txt		--不提示删除&lt;br&gt;
rm -rf dirname		--不提示递归删除目录下所有内容&lt;br&gt;
rm -rf *		--删除所有文件&lt;br&gt;
rm -rf /*		--删除所有子目录所有和文件（可以忽略！谨慎操作该指令！）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.2.6	复制和移动文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cp		--复制文件&lt;br&gt;
cp nginx.conf n.txt		--&lt;br&gt;
cp -R tomcat1 tomcat2		--复制整个目录&lt;br&gt;
mv		--修改文件名/移动文件&lt;br&gt;
mv n.txt m.txt		--修改文件名称&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.2.7	浏览文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cat		--输出文件所有的内容&lt;br&gt;
more		--输出文档所有的内容，分页输出，空格浏览下一屏，q退出&lt;br&gt;
less 		--用法和more相同，只是通过PgUp、PgOn键来控制&lt;br&gt;
tail 		--用于显示文件后几号，使用频繁&lt;br&gt;
tail -10 nginx.conf 		--查看nginx.conf的最后10行&lt;br&gt;
tail –f nginx.conf 		--动态查看日志，方便查看日志新增的信息&lt;br&gt;
ctrl+c 	--结束查看&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.2.8	打包命令&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;tar命令位于/bin目录下，它能够将用户所指定的文件或目录&lt;strong&gt;打包成一个文件，但不做压缩&lt;/strong&gt;。一般Linux上常用的压缩方式是选用&lt;strong&gt;tar&lt;/strong&gt;将许多文件打包成一个文件，再以&lt;strong&gt;gzip&lt;/strong&gt;压缩命令压缩成name.tar.gz的文件。&lt;br&gt;
-c 		--创建一个新的tar文件&lt;br&gt;
-v 		--显示运行过程的信息&lt;br&gt;
-f 		--指定文件名&lt;br&gt;
-z 		--调用gzip压缩命令进行压缩&lt;br&gt;
-t 		--查看压缩文件的内容&lt;br&gt;
-x 		--解开tar文件&lt;br&gt;
tar –cvf n.tar ./* 		--压缩当前目录下的所有文件和目录，文件名为n.tar&lt;br&gt;
tar –xvf n.tar		-- 解压压缩包中的文件到当前目录（如果长时间未解压&amp;gt;成功 Ctrl+C推出）&lt;br&gt;
tar –cvzf m.tar.gz ./* 		--压缩文件&lt;br&gt;
tar -zxvf m.tar.gz			--解压m.tar文件到当前目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.2.9	grep命令&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;grep root  /etc/passwd   		--在文件中查找关键字root&lt;br&gt;
grep root  /etc/passwd  –-color        		-- 高亮显示&lt;br&gt;
grep root  /etc/passwd  –A5 –B5         		--高亮显示，A后5行，B前5行&lt;br&gt;
grep -n root /etc/passwd 		-- 查找并显示行数&lt;br&gt;
grep -v root /etc/passwd   		--取反，查出不含root的数据&lt;/p&gt;
&lt;/blockquote&gt;
">Linux之命令集</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/shi-yong-gong-ju-jin-ji-ortools/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%94%A8%E6%88%B7%E8%84%9A%E6%9C%AC%E7%BD%91-greasy-fork&#34;&gt;用户脚本网: Greasy Fork&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E7%AB%99-423down&#34;&gt;软件下载站: 423down&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%97%A0%E7%94%A8%E8%B5%84%E6%BA%90%E7%BD%91-wuyongfun&#34;&gt;无用资源网: wuyongfun&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%87%E6%A1%A3%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2-alltoall&#34;&gt;文档格式转换: alltoall&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%80%83%E8%AF%95%E9%85%B7-examcoo&#34;&gt;考试酷: examcoo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B1%87%E8%81%9A%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-wikihow&#34;&gt;汇聚专业知识: wikihow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91-yt5s&#34;&gt;下载视频: yt5s&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%A7%91%E6%8A%80%E5%A4%A7%E5%B8%88-ayangcc&#34;&gt;科技大师: ayangcc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9E%81%E7%AE%80%E5%9C%A8%E7%BA%BF%E7%AE%80%E5%8E%86%E5%88%B6%E4%BD%9C-polebrief&#34;&gt;极简在线简历制作: polebrief&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BB%BA%E7%AB%99%E5%BC%80%E6%BA%90%E8%BD%AF-wordpress&#34;&gt;建站开源软: wordpress&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BB%BA%E7%AB%99%E5%BC%80%E6%BA%90%E8%BD%AF-typecho&#34;&gt;建站开源软: typecho&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9C%A8%E7%BA%BF%E7%A7%8D%E5%AD%90%E8%A7%A3%E6%9E%90-torrent&#34;&gt;在线种子解析: torrent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%A3%81%E5%8A%9B%E4%B8%8B%E8%BD%BD-webtor&#34;&gt;磁力下载: webtor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9C%A8%E7%BA%BFjson%E8%A7%A3%E6%9E%90-bejson&#34;&gt;在线json解析: bejson&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
( )&lt;/p&gt;
&lt;h3 id=&#34;用户脚本网-greasy-fork&#34;&gt;用户脚本网: &lt;a href=&#34;https://greasyfork.org/zh-CN&#34;&gt;Greasy Fork&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;软件下载站-423down&#34;&gt;软件下载站: &lt;a href=&#34;https://www.423down.com/&#34;&gt;423down&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;无用资源网-wuyongfun&#34;&gt;无用资源网: &lt;a href=&#34;https://wuyong.fun/&#34;&gt;wuyongfun&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;文档格式转换-alltoall&#34;&gt;文档格式转换: &lt;a href=&#34;https://www.alltoall.net/&#34;&gt;alltoall&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;考试酷-examcoo&#34;&gt;考试酷: &lt;a href=&#34;https://www.examcoo.com/&#34;&gt;examcoo&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;汇聚专业知识-wikihow&#34;&gt;汇聚专业知识: &lt;a href=&#34;https://zh.wikihow.com/&#34;&gt;wikihow&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;下载视频-yt5s&#34;&gt;下载视频: &lt;a href=&#34;https://yt5s.com/en89&#34;&gt;yt5s&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;科技大师-ayangcc&#34;&gt;科技大师: &lt;a href=&#34;https://www.ayangcc.com/&#34;&gt;ayangcc&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;极简在线简历制作-polebrief&#34;&gt;极简在线简历制作: &lt;a href=&#34;https://www.polebrief.com/index&#34;&gt;polebrief&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;建站开源软-wordpress&#34;&gt;建站开源软: &lt;a href=&#34;https://cn.wordpress.org/&#34;&gt;wordpress&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;建站开源软-typecho&#34;&gt;建站开源软: &lt;a href=&#34;http://typecho.org/&#34;&gt;typecho&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;在线种子解析-torrent&#34;&gt;在线种子解析: &lt;a href=&#34;http://www.ip33.com/torrent.html&#34;&gt;torrent&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;磁力下载-webtor&#34;&gt;磁力下载: &lt;a href=&#34;https://webtor.io/###/&#34;&gt;webtor&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;在线json解析-bejson&#34;&gt;在线json解析: &lt;a href=&#34;https://www.bejson.com/&#34;&gt;bejson&lt;/a&gt;&lt;/h3&gt;
">实用工具锦集|Tools</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog9527.github.io/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


    <script src="https://cdn.bootcdn.net/ajax/libs/smooth-scroll/16.1.2/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>



<script src="/media/js/mouse/peace.js"></script>


  <script src="/media/js/cool.js"></script>



  <div class="snow-container"></div>
  <script color="0,205,205" pointer-events="auto" zIndex="-1" opacity='0.7' count="99" src="/media/js/bg/canvas-nest.js"></script>


</html>