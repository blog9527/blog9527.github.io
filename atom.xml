<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog9527.github.io</id>
    <title>Stone的万事屋</title>
    <updated>2022-05-25T09:02:33.127Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog9527.github.io"/>
    <link rel="self" href="https://blog9527.github.io/atom.xml"/>
    <subtitle>记录与分享~</subtitle>
    <logo>https://blog9527.github.io/images/avatar.png</logo>
    <icon>https://blog9527.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Stone的万事屋</rights>
    <entry>
        <title type="html"><![CDATA[AOP的实现步骤]]></title>
        <id>https://blog9527.github.io/post/aop-de-shi-xian-bu-zou/</id>
        <link href="https://blog9527.github.io/post/aop-de-shi-xian-bu-zou/">
        </link>
        <updated>2022-05-21T02:08:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><em>AOP</em></p>
</blockquote>
<h3 id="1-aop">1 AOP</h3>
<p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：<strong>面向切面编程</strong>，通过预编译方式和运行期间<strong>动态代理</strong>实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，<strong>从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率</strong></p>
<h3 id="2-aop实现步骤">2 AOP实现步骤</h3>
<p><em><strong>公式: AOP(切面) = 通知方法(5种) + 切入点表达式(4种)</strong></em><br>
2.1 通知方法</p>
<blockquote>
<p>1.before通知 在执行目标方法之前执行<br>
2.afterReturning通知 在目标方法执行之后执行<br>
3.afterThrowing通知 在目标方法执行之后报错时执行<br>
4.after通知 无论什么时候程序执行完成都要执行的通知<br>
上述的4大通知类型,不能控制目标方法是否执行.一般用来记录程序的执行的状态.<br>
一般应用与监控的操作.<br>
5.around通知(功能最为强大的) 在目标方法执行前后执行.<br>
因为环绕通知可以控制目标方法是否执行.控制程序的执行的轨迹.</p>
</blockquote>
<p>2.2切入点表达式</p>
<blockquote>
<p>1.bean(“bean的ID”) 粒度: 粗粒度 按bean匹配 当前bean中的方法都会执行通知.<br>
2.within(“包名.类名”) 粒度: 粗粒度 可以匹配多个类<br>
3.execution(“返回值类型 包名.类名.方法名(参数列表)”) 粒度: 细粒度 方法参数级别<br>
4.@annotation(“包名.类名”) 粒度:细粒度 按照注解匹配</p>
</blockquote>
<pre><code class="language-java">//例：
package com.jt.aop;
import lombok.extern.apachecommons.CommonsLog;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Controller;
import org.springframework.stereotype.Service;

import java.util.Arrays;

@Aspect //标识我是一个切面
@Component  //交给Spring容器管理
public class CacheAOP {

    //切面 = 切入点表达式 + 通知方法
    //@Pointcut(&quot;bean(itemCatServiceImpl)&quot;)
    //@Pointcut(&quot;within(com.jt.service.ItemCatServiceImpl)&quot;)
    //@Pointcut(&quot;within(com.jt.service.*)&quot;)   // .* 一级包路径   ..* 所有子孙后代包
    //@Pointcut(&quot;execution(返回值类型 包名.类名.方法名(参数列表))&quot;)
    @Pointcut(&quot;execution(* com.jt.service..*.*(..))&quot;)
    //注释: 返回值类型任意类型   在com.jt.service下的所有子孙类   以add开头的方法,任意参数类型
    public void pointCut(){

    }

    /**
     * 需求:
     *      1.获取目标方法的路径
     *      2.获取目标方法的参数.
     *      3.获取目标方法的名称
     */
    @Before(&quot;pointCut()&quot;)
    public void before(JoinPoint joinPoint){
        String classNamePath = joinPoint.getSignature().getDeclaringTypeName();
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        System.out.println(&quot;方法路径:&quot;+classNamePath);
        System.out.println(&quot;方法参数:&quot;+ Arrays.toString(args));
        System.out.println(&quot;方法名称:&quot;+methodName);
    }

    @Around(&quot;pointCut()&quot;)
    public Object around(ProceedingJoinPoint joinPoint){
        try {
            System.out.println(&quot;环绕通知开始&quot;);
            Object obj = joinPoint.proceed();
            //如果有下一个通知,就执行下一个通知,如果没有就执行目标方法(业务方法)
            System.out.println(&quot;环绕通知结束&quot;);
            return null;
        } catch (Throwable throwable) {
            throwable.printStackTrace();
            throw new RuntimeException(throwable);
        }

    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重拾知识点]]></title>
        <id>https://blog9527.github.io/post/chong-shi-zhi-shi-dian/</id>
        <link href="https://blog9527.github.io/post/chong-shi-zhi-shi-dian/">
        </link>
        <updated>2022-05-21T02:08:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><em>合抱之木始于毫末,万丈高楼起于垒土</em></p>
</blockquote>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3554510"> <em>记录点点滴滴·持续更新<label class="task-list-item-label" for="task-item-3554510"> *记录点点滴滴·持续更新*</label></li>
</ul>
<h2 id="java中获取类对象的几种方式">Java中获取类对象的几种方式</h2>
<p>1.通过类名.class获取</p>
<pre><code class="language-java">Class class=Student.class;
</code></pre>
<p>2.通过具体对象获取</p>
<pre><code class="language-java">Student student=new Student();
Class class=student.getClass();
</code></pre>
<p>3.通过Class类的forName()方法获取，括号中的内容是类的全名；</p>
<pre><code class="language-java">Class class=Class.forName(&quot;com.demo.Student&quot;);
</code></pre>
<h2 id="同步与异步">同步与异步</h2>
<blockquote>
<p>同步：<br>
同一时刻，有钥匙的是独占资源，共享资源无人抢，没钥匙的等待；<br>
<s>一定要等任务执行完了，得到结果，才执行下一个任务；</s><br>
异步：<br>
同一时刻，无人排队，抢着占用共享资源；<br>
<s>不等任务执行完，直接执行下一个任务。</s></p>
</blockquote>
<h2 id="并行与并发">并行与并发</h2>
<blockquote>
<p>并行：<br>
多个CPU，每个CPU执行自己的任务，不抢占，慢慢干；<br>
<s>在同一时刻，有多条指令在多个处理器上同时执行；</s><br>
并发：<br>
单个CPU，被多个资源去抢占了，抢着干；<br>
<s>同一时刻，只能有一条指令执行，但多个进程指令被快熟轮换地执行，使得在宏观上具有多个进程同时执行的效果；</s></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java核心专题1-并发编程]]></title>
        <id>https://blog9527.github.io/post/java-he-xin-zhuan-ti-1-bing-fa-bian-cheng/</id>
        <link href="https://blog9527.github.io/post/java-he-xin-zhuan-ti-1-bing-fa-bian-cheng/">
        </link>
        <updated>2022-05-21T02:08:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><em>【面试篇·持续更新】多多阅读，吸取精华</em></p>
</blockquote>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3766306"> <em>持续更新</em><br>
<ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E5%9C%A8java-%E4%B8%AD%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%9C%AC%E5%9C%B0%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB">一、 在java 中守护线程和本地线程区别？</a></li>
<li><a href="#%E4%BA%8C-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">二、 线程与进程的区别？</a></li>
<li><a href="#%E4%B8%89-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2">三、 什么是多线程中的上下文切换？</a></li>
<li><a href="#%E5%9B%9B-%E6%AD%BB%E9%94%81%E4%B8%8E%E6%B4%BB%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%8C%BA%E5%88%AB">四、 死锁与活锁的区别，死锁与饥饿的区别？</a></li>
<li><a href="#%E4%BA%94-java-%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88">五、 Java 中用到的线程调度算法是什么？</a></li>
<li><a href="#%E5%85%AD-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E7%BB%84%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8java-%E4%B8%AD%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8">六、 什么是线程组，为什么在Java 中不推荐使用？</a></li>
<li><a href="#%E4%B8%83-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8executor-%E6%A1%86%E6%9E%B6">七、 为什么使用Executor 框架？</a></li>
</ul>
</li>
</ul>
<label class="task-list-item-label" for="task-item-3766306"> *持续更新*
@[TOC](并发)</label></li>
</ul>
<h2 id="一-在java-中守护线程和本地线程区别">一、 在java 中守护线程和本地线程区别？</h2>
<p>java 中的线程分为两种： <strong>守护线程</strong>（ Daemon） 和<strong>用户线程</strong>（ User）。<br>
任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(bool on)；true 则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon() 必须在 Thread.start()之前调用， 否则运行时会抛出异常。</p>
<p>两者的区别：<br>
唯一的区别是判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离， Daemon 没有可服务的线程， JVM 撤离。也可以理解为守护线程是 JVM 自动创建的线程（ 但不一定）， 用户线程是程序创建的线程； 比如 JVM 的垃圾回收线程是一个守护线程， 当所有线程已经撤离， 不再产生垃圾， 守护线程自然就没事可干了， 当垃圾回收线程是 Java 虚拟机上仅剩的线程时， Java 虚拟机会自动离开。</p>
<p>扩展： Thread Dump 打印出来的线程信息， 含有 daemon 字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break 的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。</p>
<h2 id="二-线程与进程的区别">二、 线程与进程的区别？</h2>
<p>进程是操作系统<strong>分配资源</strong>的最小单元，  线程是操作系统<strong>调度</strong>的最小单元。一个程序至少有一个进程,一个进程至少有一个线程。</p>
<h2 id="三-什么是多线程中的上下文切换">三、 什么是多线程中的上下文切换？</h2>
<p>多线程会共同使用一组计算机上的 CPU，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU。不同的线程切换使用 CPU 发生的切换数据等就是上下文切换。</p>
<h2 id="四-死锁与活锁的区别死锁与饥饿的区别">四、 死锁与活锁的区别，死锁与饥饿的区别？</h2>
<p>死锁： 是指两个或两个以上的进程（ 或线程） 在执行过程中， 因争夺资源而造成的一种互相等待的现象， 若无外力作用， 它们都将无法推进下去。<br>
产生死锁的<strong>必要条件</strong>：<br>
1、互斥条件： 所谓互斥就是进程在某一时间内独占资源。<br>
2、请求与保持条件： 一个进程因请求资源而阻塞时， 对已获得的资源保持不放。<br>
3、不剥夺条件:进程已获得资源， 在末使用完之前， 不能强行剥夺。<br>
4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<p>活锁： 任务或者执行者没有被阻塞， 由于某些条件没有满足， 导致一直重复尝试， 失败， 尝试， 失败。<br>
活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“ 活”，  而处于死锁的实体表现为等待； 活锁有可能自行解开， 死锁则不能。</p>
<p>饥饿： 一个或者多个线程因为种种原因无法获得所需要的资源， 导致一直无法执行的状态。<br>
Java 中导致饥饿的原因：<br>
1、高优先级线程吞噬所有的低优先级线程的 CPU 时间。<br>
2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前   持续地对该同步块进行访问。<br>
3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)， 因为其他线程总是被持续地获得唤醒。</p>
<h2 id="五-java-中用到的线程调度算法是什么">五、 Java 中用到的线程调度算法是什么？</h2>
<p>采用时间片轮转的方式。可以设置线程的优先级，   会映射到下层的系统上面的优先级上， 如非特别需要， 尽量不要用， 防止线程饥饿。</p>
<h2 id="六-什么是线程组为什么在java-中不推荐使用">六、 什么是线程组，为什么在Java 中不推荐使用？</h2>
<p>ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象， 也可以有线程组， 组中还可以有线程， 这样的组织结构有点类似于树的形式。<br>
为什么不推荐使用？ 因为使用有很多的安全隐患吧， 没有具体追究， 如果需要使用， 推荐使用线程池。</p>
<h2 id="七-为什么使用executor-框架">七、 为什么使用Executor 框架？</h2>
<p>每次执行任务创建线程 new Thread()比较消耗性能， 创建一个线程是比较耗时、耗资源的。<br>
调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建， 线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪， 还有线程之间的频繁交替也会消耗很多系统资源。<br>
接使用 new Thread() 启动的线程不利于扩展， 比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础题篇]]></title>
        <id>https://blog9527.github.io/post/java-ji-chu-ti-pian/</id>
        <link href="https://blog9527.github.io/post/java-ji-chu-ti-pian/">
        </link>
        <updated>2022-05-21T02:08:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><em>备战面试，收集整理一些问题</em></p>
</blockquote>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">1.面向对象和面向过程的区别</a></li>
<li><a href="#2java-%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9">2.Java 语言有哪些特点</a></li>
<li><a href="#3%E5%85%B3%E4%BA%8E-jvm-jdk-%E5%92%8C-jre-%E6%9C%80%E8%AF%A6%E7%BB%86%E9%80%9A%E4%BF%97%E7%9A%84%E8%A7%A3%E7%AD%94">3.关于 JVM JDK 和 JRE 最详细通俗的解答</a></li>
<li><a href="#4oracle-jdk-%E5%92%8C-openjdk-%E7%9A%84%E5%AF%B9%E6%AF%94">4.Oracle JDK 和 OpenJDK 的对比</a></li>
<li><a href="#5-java-%E5%92%8C-c%E7%9A%84%E5%8C%BA%E5%88%AB">5. Java 和 C++的区别</a></li>
<li><a href="#6-%E4%BB%80%E4%B9%88%E6%98%AF-java-%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%BB%E7%B1%BB-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%BB%E7%B1%BB%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C">6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同</a></li>
<li><a href="#7-java-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%97%B4%E6%9C%89%E9%82%A3%E4%BA%9B%E5%B7%AE%E5%88%AB">7. Java 应用程序与小程序之间有那些差别</a></li>
<li><a href="#8-%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB">8. 字符型常量和字符串常量的区别</a></li>
<li><a href="#9-%E6%9E%84%E9%80%A0%E5%99%A8-constructor-%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB-override">9. 构造器 Constructor 是否可被 override</a></li>
<li><a href="#10-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB">10. 重载和重写的区别</a></li>
<li><a href="#11-java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7-%E5%B0%81%E8%A3%85-%E7%BB%A7%E6%89%BF-%E5%A4%9A%E6%80%81">11. Java 面向对象编程三大特性: 封装 继承 多态</a></li>
<li><a href="#12-string-stringbuffer-%E5%92%8C-stringbuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88-string-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84">12. String StringBuffer 和 StringBuilder 的区别是什么 String 为什么是不可变的</a></li>
<li><a href="#13-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1">13. 自动装箱与拆箱</a></li>
<li><a href="#14-%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%86%85%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E6%B3%95%E7%9A%84">14. 在一个静态方法内调用一个非静态成员为什么是非法的</a></li>
<li><a href="#15-%E5%9C%A8-java-%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%81%9A%E4%BA%8B%E4%B8%94%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8">15. 在 Java 中定义一个不做事且没有参数的构造方法的作用</a></li>
<li><a href="#16-import-java-%E5%92%8C-javax-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">16. import java 和 javax 有什么区别</a></li>
<li><a href="#17-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">17. 接口和抽象类的区别是什么</a></li>
<li><a href="#18-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E9%82%A3%E4%BA%9B">18. 成员变量与局部变量的区别有那些</a></li>
<li><a href="#19-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BB%80%E4%B9%88%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C">19. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</a></li>
<li><a href="#20-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BF%94%E5%9B%9E%E5%80%BC%E5%9C%A8%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E9%87%8C%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">20. 什么是方法的返回值?返回值在类的方法里的作用是什么?</a></li>
<li><a href="#21-%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88-%E8%8B%A5%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97-%E4%B8%BA%E4%BB%80%E4%B9%88">21. 一个类的构造方法的作用是什么 若一个类没有声明构造方法,该程序能正确执行吗 ?为什么?</a></li>
<li><a href="#22-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7">22. 构造方法有哪些特性</a></li>
<li><a href="#23-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C">23. 静态方法和实例方法有何不同</a></li>
<li><a href="#24-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89%E4%B8%8E%E6%8C%87%E5%90%91%E4%BB%96%E4%BB%AC%E7%9A%84%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E4%B8%A4%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C">24. 对象的相等与指向他们的引用相等，两者有什么不同？</a></li>
<li><a href="#25-%E5%9C%A8%E8%B0%83%E7%94%A8%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E5%89%8D%E4%BC%9A%E5%85%88%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%85%B6%E7%9B%AE%E7%9A%84%E6%98%AF">25. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是?</a></li>
<li><a href="#26-%E4%B8%8E-equals%E9%87%8D%E8%A6%81">26. == 与 equals(重要)</a></li>
<li><a href="#27hashcode-%E4%B8%8E-equals%E9%87%8D%E8%A6%81">27.hashCode 与 equals（重要）</a></li>
<li><a href="#28-%E4%B8%BA%E4%BB%80%E4%B9%88-java-%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92">28. 为什么 Java 中只有值传递</a></li>
<li><a href="#29-%E7%AE%80%E8%BF%B0%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88">29. 简述线程，程序、进程的基本概念。以及他们之间关系是什么</a></li>
<li><a href="#30-%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81">30. 线程有哪些基本状态?</a></li>
<li><a href="#31-%E5%85%B3%E4%BA%8E-final-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93">31 关于 final 关键字的一些总结</a></li>
</ul>
</li>
</ul>
(目录)</p>
<h2 id="1面向对象和面向过程的区别">1.面向对象和面向过程的区别</h2>
<p>面向过程<br>
优点： 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发，性能是最重要的因素。 缺点： 没有面向对象易维护、易复用、易扩展<br>
面向对象<br>
优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的</p>
<h2 id="2java-语言有哪些特点">2.Java 语言有哪些特点</h2>
<ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存；</li>
</ol>
<h2 id="3关于-jvm-jdk-和-jre-最详细通俗的解答">3.关于 JVM JDK 和 JRE 最详细通俗的解答</h2>
<p><strong>JVM</strong><br>
Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。<br>
什么是字节码?采用字节码的好处是什么?<br>
在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同的计算机上运行。<br>
Java 程序从<strong>源代码到运行</strong>一般有下面 <strong>3 步</strong>：<br>
我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 jvm 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的，也就是所谓的热点代<br>
码，所以后面引进了 JIT 编译器，JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。<br>
HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分<br>
系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式<br>
AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就<br>
避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ， AOT 编译器的编译质量是肯定比不上 JIT 编译器的。 总结：Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。<br>
<strong>JDK 和 JRE</strong><br>
JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。<br>
JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。<br>
如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用<br>
程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译<br>
servlet。</p>
<h2 id="4oracle-jdk-和-openjdk-的对比">4.Oracle JDK 和 OpenJDK 的对比</h2>
<p>可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么<br>
Oracle 和 OpenJDK 之间是否存在重大差异？下面通过我通过我收集到一些资料对你解答这个被很多人忽视的问题。<br>
对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：<br>
问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？<br>
答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。 总结：</p>
<ol>
<li>Oracle JDK 版本将每三年发布一次，而 OpenJDK 版本每三个月发布一次；</li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是<br>
OpenJDK 的一个实现，并不是完全开源的；</li>
<li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎<br>
相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li>
<li>顶级公司正在使用 Oracle JDK，例如 Android Studio，Minecraft 和<br>
IntelliJ IDEA 开发工具，其中 Open JDK 不太受欢迎；</li>
<li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li>
<li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li>
</ol>
<h2 id="5-java-和-c的区别">5. Java 和 C++的区别</h2>
<p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！<br>
•	都是面向对象的语言，都支持封装、继承和多态<br>
•	Java 不提供指针来直接访问内存，程序内存更加安全<br>
•	Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。<br>
•	Java 有自动内存管理机制，不需要程序员手动释放无用内存</p>
<h2 id="6-什么是-java-程序的主类-应用程序和小程序的主类有何不同">6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同</h2>
<p>一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main（）方法的类。而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。</p>
<h2 id="7-java-应用程序与小程序之间有那些差别">7. Java 应用程序与小程序之间有那些差别</h2>
<p>简单说应用程序是从主线程启动(也就是 main() 方法)。applet 小程序没有 main 方法，主要是嵌在浏览器页面上运行(调用 init()线程或者 run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。</p>
<h2 id="8-字符型常量和字符串常量的区别">8. 字符型常量和字符串常量的区别</h2>
<ol>
<li>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li>
<li>含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)<br>
<img src="https://img-blog.csdnimg.cn/20201104132752132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></li>
<li>占内存大小 字符常量只占 2 个字节 字符串常量占若干个字节(至少一个字符结束标志) (注意： char 在 Java 中占两个字节) java 编程思想第四版：2.2.2 节</li>
</ol>
<h2 id="9-构造器-constructor-是否可被-override">9. 构造器 Constructor 是否可被 override</h2>
<p>在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以<br>
Constructor 也就不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h2 id="10-重载和重写的区别">10. 重载和重写的区别</h2>
<p>重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　<br>
重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类<br>
方法访问修饰符为 private 则子类就不能重写该方法。</p>
<h2 id="11-java-面向对象编程三大特性-封装-继承-多态">11. Java 面向对象编程三大特性: 封装 继承 多态</h2>
<p><strong>封装</strong><br>
封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。 继承<br>
继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。<br>
关于<strong>继承</strong>如下 3 点请记住：</p>
<ol>
<li>子类拥有父类非 private 的属性和方法。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。 多态<br>
所谓<strong>多态</strong>就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。<br>
在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</li>
</ol>
<h2 id="12-string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的">12. String StringBuffer 和 StringBuilder 的区别是什么 String 为什么是不可变的</h2>
<p><strong>可变性</strong> 　<br>
简单的来说：String 类中使用 final 关键字字符数组保存字符串，private　<br>
final　char　value[]，所以 String 对象是不可变的。而 StringBuilder 与<br>
StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中<br>
也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。<br>
StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是<br>
AbstractStringBuilder 实现的，大家可以自行查阅源码。</p>
<pre><code class="language-java">AbstractStringBuilder.java 
abstract class AbstractStringBuilder implements Appendable, CharSequence {char[] value;  int count; 
    AbstractStringBuilder() { 
    } 
    AbstractStringBuilder(int capacity) {
    value = new char[capacity]; 
    } 
</code></pre>
<p><strong>线程安全性</strong><br>
String 中的对象是不可变的，也就可以理解为常量，线程安全。<br>
AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。<br>
<strong>性能</strong><br>
每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将<br>
指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用<br>
StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，<br>
但却要冒多线程不安全的风险。 对于三者<strong>使用的总结</strong>：</p>
<ol>
<li>操作少量的数据 = String</li>
<li>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</li>
<li>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</li>
</ol>
<h2 id="13-自动装箱与拆箱">13. 自动装箱与拆箱</h2>
<p>装箱：将基本类型用它们对应的引用类型包装起来；  拆箱：将包装类型转换为基本数据类型；</p>
<h2 id="14-在一个静态方法内调用一个非静态成员为什么是非法的">14. 在一个静态方法内调用一个非静态成员为什么是非法的</h2>
<p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
<h2 id="15-在-java-中定义一个不做事且没有参数的构造方法的作用">15. 在 Java 中定义一个不做事且没有参数的构造方法的作用</h2>
<p>Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
<h2 id="16-import-java-和-javax-有什么区别">16. import java 和 javax 有什么区别</h2>
<p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。<br>
所以，实际上 java 和 javax 没有区别。这都是一个名字。</p>
<h2 id="17-接口和抽象类的区别是什么">17. 接口和抽象类的区别是什么</h2>
<ol>
<li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法</li>
<li>接口中的实例变量默认是 final 类型的，而抽象类中则不一定</li>
<li>一个类可以实现多个接口，但最多只能实现一个抽象类</li>
<li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</li>
<li>接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li>
</ol>
<h2 id="18-成员变量与局部变量的区别有那些">18. 成员变量与局部变量的区别有那些</h2>
<ol>
<li>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的<br>
变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰；</li>
<li>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</li>
<li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值）；而局部变量则不会自动赋值。</li>
</ol>
<h2 id="19-创建一个对象用什么运算符对象实体与对象引用有何不同">19. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h2>
<p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或   个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h2 id="20-什么是方法的返回值返回值在类的方法里的作用是什么">20. 什么是方法的返回值?返回值在类的方法里的作用是什么?</h2>
<p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p>
<h2 id="21-一个类的构造方法的作用是什么-若一个类没有声明构造方法该程序能正确执行吗-为什么">21. 一个类的构造方法的作用是什么 若一个类没有声明构造方法,该程序能正确执行吗 ?为什么?</h2>
<p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p>
<h2 id="22-构造方法有哪些特性">22. 构造方法有哪些特性</h2>
<ol start="2">
<li>没有返回值，但不能用 void 声明构造函数；</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<h2 id="23-静态方法和实例方法有何不同">23. 静态方法和实例方法有何不同</h2>
<ol>
<li>在外部调用静态方法时，可以使用&quot;类名.方法名&quot;的方式，也可以使用&quot;对象名.方法名&quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li>
<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无<br>
此限制.</li>
</ol>
<h2 id="24-对象的相等与指向他们的引用相等两者有什么不同">24. 对象的相等与指向他们的引用相等，两者有什么不同？</h2>
<p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
<h2 id="25-在调用子类构造方法之前会先调用父类没有参数的构造方法其目的是">25. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是?</h2>
<p>帮助子类做初始化工作。</p>
<h2 id="26-与-equals重要">26. == 与 equals(重要)</h2>
<p>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型<mark>比较的是值，引用数据类型</mark>比较的是内存地址)<br>
equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：<br>
•	情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。<br>
•	情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>
<pre><code class="language-java">//举个例子： 
public class test1 { 
    public static void main(String[] args) {         String a = new String(&quot;ab&quot;); // a 为一个引用 
        String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样 
        String aa = &quot;ab&quot;; // 放在常量池中         String bb = &quot;ab&quot;; // 从常量池中查找         if (aa == bb) // true 
            System.out.println(&quot;aa==bb&quot;);         if (a == b) // false，非同一对象             System.out.println(&quot;a==b&quot;);         if (a.equals(b)) // true             System.out.println(&quot;aEQb&quot;);         if (42 == 42.0) { // true             System.out.println(&quot;true&quot;); 
        } 
    } 
} 
说明： 
•	String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 
•	当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没
有就在常量池中重新创建一个 String 对象。
</code></pre>
<h2 id="27hashcode-与-equals重要">27.hashCode 与 equals（重要）</h2>
<p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？”<br>
<strong>hashCode（）介绍</strong><br>
hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义<br>
在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。<br>
散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）<br>
<strong>为什么要有 hashCode</strong><br>
我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：<br>
当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 hashCode（）与 equals（）的相关规定</p>
<ol>
<li>如果两个对象相等，则 hashcode 一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用 equals 方法都返回 true</li>
<li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li>
<li>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</li>
<li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<h2 id="28-为什么-java-中只有值传递">28. 为什么 Java 中只有值传递</h2>
<h2 id="29-简述线程程序-进程的基本概念-以及他们之间关系是什么">29. 简述线程，程序、进程的基本概念。以及他们之间关系是什么</h2>
<p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。<br>
<strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。<br>
<strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>
<h2 id="30-线程有哪些基本状态">30. 线程有哪些基本状态?</h2>
<h2 id="31-关于-final-关键字的一些总结">31 关于 final 关键字的一些总结</h2>
<p>final 关键字主要用在三个地方：变量、方法、类。</p>
<ol>
<li>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li>
<li>当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。</li>
<li>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JSON的一些知识]]></title>
        <id>https://blog9527.github.io/post/json-de-yi-xie-zhi-shi/</id>
        <link href="https://blog9527.github.io/post/json-de-yi-xie-zhi-shi/">
        </link>
        <updated>2022-05-21T02:08:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><em>合抱之木始于毫末,万丈高楼起于垒土</em></p>
</blockquote>
<h3 id="1什么是json">1.什么是JSON</h3>
<p>答:JSON(JavaScript Object Notation) 是一种<em>轻量级</em>的<strong>数据交换格式</strong></p>
<h3 id="2json基于两种结构">2.JSON基于两种结构：</h3>
<p>JSON[1] 结构有两种结构[2]<br>
json简单说就是<strong>javascript中的对象和数组</strong>，所以这两种结构就是<strong>对象</strong>和<strong>数组</strong>两种结构，通过这两种结构可以表示各种复杂的结构。</p>
<p>2.1 JSON格式之对象格式<br>
对象（object） 是一个无序的“‘名称/值’对”集合。一个<strong>对象</strong>以“<strong>{</strong>”（左括号）开始，“<strong>}</strong>”（右括号）结束。每个“<strong>名称</strong>”后跟一个“<strong>:</strong>”（冒号）；“‘<strong>名称/值</strong>’ 对”之间使用“<strong>,</strong>”（逗号）分隔。<br>
<img src="https://img-blog.csdnimg.cn/2020110221022048.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">//例
{“id”:&quot;1&quot;,&quot;name&quot;:&quot;周董&quot;}
</code></pre>
<p>2.2JSON格式之数组格式<br>
<img src="https://img-blog.csdnimg.cn/20201102210442981.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">//例
[&quot;1&quot;,&quot;周董&quot;,&quot;歌手&quot;]
</code></pre>
<p>2.3JSON格式之嵌套格式<br>
<img src="https://img-blog.csdnimg.cn/20201102210606783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">//例
[&quot;周董&quot;,&quot;唱歌&quot;,[1,2,3,4,5],{&quot;id&quot;:1,&quot;name&quot;:&quot;月半伦&quot;,&quot;hobby&quot;:[&quot;写歌&quot;,&quot;拍电影&quot;,&quot;喝奶茶&quot;]}]
</code></pre>
<p><a href="http://json.cn/">Json在线解析地址</a><br>
<img src="https://img-blog.csdnimg.cn/20201102220656655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试之Dubbo篇]]></title>
        <id>https://blog9527.github.io/post/mian-shi-zhi-dubbo-pian/</id>
        <link href="https://blog9527.github.io/post/mian-shi-zhi-dubbo-pian/">
        </link>
        <updated>2022-05-21T02:08:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-dubbo-是什么">1、Dubbo 是什么？</h3>
<blockquote>
<p>Dubbo（阿里巴巴公司开源分布式服务框架）是一个分布式、高性能、透明化的<strong>RPC服务框架</strong>，提供服务自动注册、自动发现等高效服务治理方案，可以和Spring框架无缝集成。</p>
</blockquote>
<h3 id="2-为什么要用-dubbo">2、为什么要用 Dubbo？</h3>
<blockquote>
<p>随着服务化的进一步发展，服务越来越多，服务之间的<strong>调用和依赖</strong>关系也越来越复杂，诞生了<strong>面向服务的架构体系（SOA）</strong>，<br>
因此也衍生了一系列相应的技术，如对服务提供、调用、发现、路由连接处理、通信协议、日志输出等行为进行<strong>封装的服务框架</strong>，<br>
为<strong>分布式系统的服务治理框架</strong>就出现了，Dubbo也就产生。</p>
</blockquote>
<h3 id="3-dubbo-和-spring-cloud-有什么区别">3、Dubbo 和 Spring Cloud 有什么区别？</h3>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20201121104323617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<blockquote>
<p>最大区别：Dubbo底层是使用<strong>Netty这样的NIO框架</strong>，是<strong>基于TCP协议</strong>传输的，<strong>配合以Hession序列化完成RPC</strong>通信。<br>
而SpringCloud是基于<strong>Http协议+Rest接口调用远程过程</strong>的通信，相对来说，Http请求会有更大的报文，占的带宽也会更多。但是Rest相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖。</p>
</blockquote>
<h3 id="4-dubbo-都支持什么协议推荐用哪种">4、dubbo 都支持什么协议，推荐用哪种？</h3>
<blockquote>
<ol>
<li>dubbo(<strong>推荐</strong>):单一长连接和NIO同步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议TCP 异步 Hessian序列化；</li>
<li>rmi:采用JDK标准的rmi协议实现，传输参数和返回参数对象需要实现Serializable接口，使用java标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议TCP。  多个短连接，TCP协议传输，同步传输，适用常规的远程服务调用和rmi互操作。在依赖版本的Common-Collections包，java序列化存在安全漏洞；</li>
<li>webservice:基于WebService的远程调用协议，继承CXF实现，提供和原生WebService的互操作。 多个短连接，基于HTTP传输 同步传输 适用于系统集成和跨语言调用；</li>
<li>http:基于Http表单提交的远程调用协议，使用Spring的HttpInvoke实现。多个短连接，传输协议HTTP，传入参数大小混合，提供者个数多余消费者，需要给应用程序和浏览器JS调用；</li>
<li>hessian:集成Hessian服务，基于HTTP通讯，采用Servlet暴露服务，Dubbo内嵌Jetty作为服务器时默认实现，提供与hession服务互操作。多个短连接，同步http传输，hessian序列化，传入参数较大，提供者大于消费者 提供者压力较大，可传文件；</li>
<li>mamcache:基于memcached实现的RPC协议</li>
<li>redis:基于redis实现的RPC协议</li>
</ol>
</blockquote>
<h3 id="5-dubbo-需要-web-容器吗">5、Dubbo 需要 Web 容器吗？</h3>
<blockquote>
<p>不需要。如果硬要用Web容器，只会增加复杂性，也浪费资源。</p>
</blockquote>
<h3 id="6-dubbo-内置了哪几种服务容器">6、Dubbo 内置了哪几种服务容器？</h3>
<blockquote>
<ol>
<li>Spring Container</li>
<li>Jetty Container</li>
<li>Log4j Container<br>
Doubble容器只是一个简单的Main方法，并加载一个简单的Spring容器，用于暴露服务。</li>
</ol>
</blockquote>
<h3 id="7-dubbo-里面有哪几种节点角色">7、Dubbo 里面有哪几种节点角色？</h3>
<blockquote>
<p>---------<strong>节点</strong>     ------------ <strong>角色说明</strong></p>
<ol>
<li>Provider------暴露服务的服务提供方</li>
<li>Consumer------调用远程服务的服务消费方</li>
<li>Register------服务注册与发现的注册中心</li>
<li>Monitor------统计服务的调用次数和调用时间的监控中心</li>
<li>Container------服务运行容器</li>
</ol>
</blockquote>
<h3 id="8-画一画服务注册与发现的流程图">8、画一画服务注册与发现的流程图</h3>
<blockquote>
<p><strong>来自 Dubbo 官网</strong><img src="https://img-blog.csdnimg.cn/20201121151212974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<h3 id="9-dubbo-默认使用什么注册中心还有别的选择吗">9、Dubbo 默认使用什么注册中心，还有别的选择吗？</h3>
<blockquote>
<p>采用<strong>Zookeeper</strong>作为注册中心，还有Redis、Multicast、Simple注册中心 但不推荐</p>
</blockquote>
<h3 id="10-dubbo-有哪几种配置方式">10、Dubbo 有哪几种配置方式？</h3>
<blockquote>
<p>1.Spring配置方式<br>
2.Java API配置方式</p>
</blockquote>
<h3 id="11-dubbo-核心的配置有哪些">11、Dubbo 核心的配置有哪些？</h3>
<blockquote>
<p>------ <strong>配置</strong>------ -------------<strong>配置说明</strong></p>
<ol>
<li>dubbo:service------服务配置</li>
<li>dubbo:reference------引用配置</li>
<li>dubbo:protocol------协议配置</li>
<li>dubbo:application------应用配置</li>
<li>dubbo:module------模块配置</li>
<li>dubbo:register------注册中心配置</li>
<li>dubbo:monitor------监控中心配置</li>
<li>dubbo:provider------提供方配置</li>
<li>dubbo:method------方法配置</li>
<li>dubbo:argument------参数配置</li>
</ol>
</blockquote>
<p><strong>配置间的关系</strong><br>
<img src="https://img-blog.csdnimg.cn/20201124191635515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="12-在-provider-上可以配置的-consumer-端的属性有哪些">12、在 Provider 上可以配置的 Consumer 端的属性有哪些？</h3>
<blockquote>
<ol>
<li>timeout------方法调用超时</li>
<li>retries------失败重试次数，默认重试2次</li>
<li>loadbalance------负载均衡算法，默认是随机</li>
<li>actives------消费者端，最大并发调用限制</li>
</ol>
</blockquote>
<h3 id="13-dubbo-启动时如果依赖的服务不可用会怎样">13、Dubbo 启动时如果依赖的服务不可用会怎样？</h3>
<blockquote>
<p>Dubbo缺省会在<strong>启动时</strong>检查依赖的服务是否可用，不可用时会抛出异常，阻止spring初始化完成，默认<strong>check=&quot;true&quot;</strong>,可以通过**check=&quot;false&quot;**关闭检查</p>
</blockquote>
<h3 id="14-dubbo-推荐使用什么序列化框架你知道的还有哪些">14、Dubbo 推荐使用什么序列化框架，你知道的还有哪些？</h3>
<blockquote>
<p>推荐使用<strong>Hessian序列化</strong>，还有Duddo、FastJson、Java自带序列化</p>
</blockquote>
<h3 id="15-dubbo-默认使用的是什么通信框架还有别的选择吗">15、Dubbo 默认使用的是什么通信框架，还有别的选择吗？</h3>
<blockquote>
<p>Dubbo<strong>默认使用Netty框架</strong>，也是推荐的选择，另外内容还有集成有Mina、Grizzly</p>
</blockquote>
<h3 id="16-dubbo-有哪几种集群容错方案默认是哪种">16、Dubbo 有哪几种集群容错方案，默认是哪种？</h3>
<blockquote>
<p><strong>默认是Failover Cluster集群容错方案；</strong><br>
.</p>
<ol>
<li><strong>Failover  Cluster</strong> 失败自动切换，当出现失败，重启其它服务器。通常用于<strong>读操作</strong>，但重试会带来更长延迟。</li>
<li><strong>Failfast Cluster</strong> 快熟失败，只发起一次调用，失败立即报错。通常用于<strong>非幂等性的写操作</strong>，比如新增记录。</li>
<li><strong>Failsafe Cluster</strong> 失败安全，出现异常时，直接忽略。通常用于<strong>写入审计日志</strong>等操作。</li>
<li><strong>Failback Cluster</strong> 失败自动恢复，后台记录失败请求，定时重发。通常用于<strong>消息通知</strong>操作。</li>
<li><strong>Forking Cluster</strong> 并行调用多个服务器，只要一个成功即返回。通常用于<strong>实时性要求较高的读操作</strong>，但需要浪费更多服务资源。可通过forks=&quot;2&quot;来设置最大并行数。</li>
<li><strong>Broadcast Cluster</strong> 广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者<strong>更新缓存或日志等本地资源</strong>信息。</li>
</ol>
</blockquote>
<h3 id="17-dubbo-有哪几种负载均衡策略默认是哪种">17、Dubbo 有哪几种负载均衡策略，默认是哪种？</h3>
<blockquote>
<ol>
<li>Random LoadBalance------随机，按权重设置随机概率（<strong>默认</strong>）</li>
<li>RoundRobin LoadBalance------轮询，按公约后的权重设置轮询比率</li>
<li>LeastActive LoadBalance------最少活跃调用数。相同活跃数的随机</li>
<li>ConsistentHash LoadBalance------一致性Hash,相同参数的请求总是发到同一提供者</li>
</ol>
</blockquote>
<h3 id="18-注册了多个同一样的服务如果测试指定的某一个服务呢">18、注册了多个同一样的服务，如果测试指定的某一个服务呢？</h3>
<blockquote>
<p>可以配置环境<strong>点对点直连</strong>，绕过注册中心，将<strong>以服务接口为单位</strong>，忽略注册中心的提供者列表。</p>
</blockquote>
<h3 id="19-dubbo-支持服务多协议吗">19、Dubbo 支持服务多协议吗？</h3>
<blockquote>
<p>允许配置多协议，在不同服上支持不同协议或者同一服务上同时支持多种协议。</p>
</blockquote>
<h3 id="20-当一个服务接口有多种实现时怎么做">20、当一个服务接口有多种实现时怎么做？</h3>
<blockquote>
<p>可以用<strong>group属性</strong>来分组，服务提供方和消费方都指定同一个group即可</p>
</blockquote>
<h3 id="21-服务上线怎么兼容旧版本">21、服务上线怎么兼容旧版本？</h3>
<blockquote>
<p>可以用<strong>版本号（version）过度</strong>。多个不同版本的服务注册到注册中心，版本号不同的服务相互不引用。这个和服务分组的概念有点类似。</p>
</blockquote>
<h3 id="22-dubbo-可以对结果进行缓存吗">22、Dubbo 可以对结果进行缓存吗？</h3>
<pre><code class="language-java">//为了提高数据访问速度。Dubbo提供了声明式缓存，以减少用户加缓存的工作量
&lt;dubbo:reference cache=&quot;true&quot;/&gt;
//其实比普通的配置文件多了一个标签cache=&quot;true&quot;
</code></pre>
<h3 id="23-dubbo-服务之间的调用是阻塞的吗">23、Dubbo 服务之间的调用是阻塞的吗？</h3>
<blockquote>
<p><strong>默认是同步等待结果阻塞，支持异步调用</strong>。<br>
Dubbo是基于<strong>NIO的非阻塞实现并行</strong>调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个<strong>Future对象</strong>。</p>
</blockquote>
<p><strong>异步调用流程图</strong><br>
<img src="https://img-blog.csdnimg.cn/20201124200559629.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="24-dubbo-支持分布式事务吗">24、Dubbo 支持分布式事务吗？</h3>
<blockquote>
<p><strong>目前暂时不支持，可与通过tcc-transaction框架实现</strong><br>
tcc-transaction是开源的TCC补偿性分布式事务框架， tcc-transaction通过Dubbo<strong>隐式传参</strong>的功能，避免自己对业务代码的入侵。</p>
</blockquote>
<h3 id="25-dubbo-telnet-命令能做什么">25、Dubbo telnet 命令能做什么？</h3>
<blockquote>
<p>dubbo通过telnet命令来进行服务治理，具体可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247483709&amp;idx=1&amp;sn=afe0688c184f00902529583a85d90089&amp;scene=21#wechat_redirect">dubbo服务调试管理实用命令</a></p>
</blockquote>
<pre><code class="language-java">telnet localhost 8090
</code></pre>
<h3 id="26-dubbo-支持服务降级吗">26、Dubbo 支持服务降级吗？</h3>
<blockquote>
<p>以通过dubbo:reference中设置 <strong>mock=&quot;return null&quot;</strong>。mock的值也可以修改为true，然后在跟接口同一个路径下实现一个Mock类， 命名规则是 “<strong>接口名称+Mock</strong>”后缀。然后在Mock类里实现自己的降级逻辑。<br>
<s>Dubbo 2.2.0 以上版本支持。</s></p>
</blockquote>
<h3 id="27-dubbo-如何优雅停机">27、Dubbo 如何优雅停机？</h3>
<blockquote>
<p>Dubbo是通过<strong>JDK的shutdownHook</strong>来完成优雅停机的，所以如果使用 kill -9 pid 等强制关闭指令，是不会执行优雅停机的，只有通过<strong>kill pid</strong> 时，才会执行。</p>
</blockquote>
<h3 id="28-服务提供者能实现失效踢出是什么原理">28、服务提供者能实现失效踢出是什么原理？</h3>
<blockquote>
<p>服务失效踢出基于<strong>Zookeeper的临时节点</strong>原理</p>
</blockquote>
<h3 id="29-如何解决服务调用链过长的问题">29、如何解决服务调用链过长的问题？</h3>
<blockquote>
<p>Dubbo可以使用**Pinpoint****和Apache Skywalking(Incubator)**实现分布式服务追踪，当然还有其他更多方案；</p>
</blockquote>
<h3 id="30-服务读写推荐的容错策略是怎样的">30、服务读写推荐的容错策略是怎样的？</h3>
<blockquote>
<ol>
<li>读操作建议使用Failover失败自动切换，默认重试两次其他服务器；</li>
<li>写操作建议使用Failfast快速失败，发一次调用失败就立即报错；</li>
</ol>
</blockquote>
<h3 id="31-dubbo-必须依赖的包有哪些">31、Dubbo 必须依赖的包有哪些？</h3>
<blockquote>
<p>Dubbo必须依赖<strong>JDK</strong>，其它为可选。</p>
</blockquote>
<h3 id="32-dubbo-的管理控制台能做什么">32、Dubbo 的管理控制台能做什么？</h3>
<blockquote>
<p>管理控制台主要包含：路由规则 动态配置 服务降级 访问控制 权重调整 负载均衡，等管理功能</p>
</blockquote>
<h3 id="33-说说-dubbo-服务暴露的过程">33、说说 Dubbo 服务暴露的过程。</h3>
<blockquote>
<p>Dubbo会在spring实例化完bean之后，再刷新容器最后一步发布ContextRefreshEvent事件的时候，通知实现了ApplicationListener的ServiceBean类进行回调onApplicationEvent事件方法，Dubbo会在这个方法调用中调用ServiceBean父类ServiceConfig的export方法，而该方法真正实现了服务的（异步或者非异步）发布。</p>
</blockquote>
<h3 id="34-dubbo-停止维护了吗">34、Dubbo 停止维护了吗？</h3>
<blockquote>
<p>2014年开始停止维护过几年，17年开始重新维护，并进入Apache项目</p>
</blockquote>
<h3 id="35-dubbo-和-dubbox-有什么区别">35、Dubbo 和 Dubbox 有什么区别？</h3>
<blockquote>
<p>Dubbox是继Dubbo停止维护后，当当网基于dubbo做的一个扩展项目，如加了<strong>服务可Restful调用</strong>，更新了开源组件等</p>
</blockquote>
<h3 id="36-你还了解别的分布式框架吗">36、你还了解别的分布式框架吗？</h3>
<p>Spring cloud 、Facebook的Thrift、Twitter的Finagle等</p>
<h3 id="37-dubbo-能集成-spring-boot-吗">37、Dubbo 能集成 Spring Boot 吗？</h3>
<blockquote>
<p>可以的，项目地址如下：<br>
<a href="https://github.com/apache/incubator-dubbo-spring-boot-project">地址</a></p>
</blockquote>
<h3 id="38-在使用过程中都遇到了些什么问题">38、在使用过程中都遇到了些什么问题？</h3>
<blockquote>
<p>在注册中心找不到对应的服务，检查service实现类是否添加了**@service注解<strong>无法连接到注册中心，检查</strong>配置文件**中的对应的测试ip是否正确。</p>
<p><s>Dubbo 的设计目的是为了满足高并发小数据量的 rpc 调用，在大数据量下的性能表现并不好，建议使用 rmi 或 http 协议。</s></p>
</blockquote>
<h3 id="39-你读过-dubbo-的源码吗">39、你读过 Dubbo 的源码吗？</h3>
<p><s>要了解 Dubbo 就必须看其源码，了解其原理，花点时间看下吧，网上也有很多教程</s></p>
<h3 id="40-你觉得用-dubbo-好还是-spring-cloud-好">40、你觉得用 Dubbo 好还是 Spring Cloud 好？</h3>
<blockquote>
<p><strong>扩展性的问题</strong>，没有好坏，只有适合不和适合；我更倾向于使用Dubbo，spring cloud版本<strong>升级</strong>太快，<strong>组件更新</strong>替换太频繁，<strong>配置</strong>太繁琐等等</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试之Nginx、Redis篇]]></title>
        <id>https://blog9527.github.io/post/mian-shi-zhi-nginxredis-pian/</id>
        <link href="https://blog9527.github.io/post/mian-shi-zhi-nginxredis-pian/">
        </link>
        <updated>2022-05-21T02:08:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-请解释一下什么是-nginx">1、请解释一下什么是 Nginx?</h3>
<blockquote>
<p>Nginx（<strong>C语言</strong>开发）是一个<strong>高性能的HTTP和反向代理服务器</strong>，也是【轻量级】web服务器，以及电子邮件（IMAP/POP3/SMTP）代理服务器。</p>
</blockquote>
<h3 id="2-请列举-nginx-的一些特性">2、请列举 Nginx 的一些特性。</h3>
<blockquote>
<ol>
<li><strong>反向代理</strong> 、L7负载均衡</li>
<li><strong>嵌入式</strong>Perl解释器；</li>
<li><strong>动态二进制</strong>升级；</li>
<li>可用于<strong>重新编写</strong>URL，具有非常好的PCRE支持；</li>
</ol>
</blockquote>
<h3 id="3-请列举-nginx-和-apache-之间的不同点">3、请列举 Nginx 和 Apache 之间的不同点。</h3>
<blockquote>
<p>1.最核心区别在于Apache是同步多进程模型，一个连接对应一个进程；   nginx是异步的，多个连接（万级别）可以对应一个进程；<br>
2.nginx的负载能力比Apache高很多。<br>
<img src="https://img-blog.csdnimg.cn/20201126131453788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<h3 id="4-使用反向代理服务器的优点是什么">4、使用“反向代理服务器”的优点是什么?</h3>
<blockquote>
<p>反向代理服务器可以<strong>隐藏源服务器的存在和特征</strong>。它充当<strong>互联网和web服务器</strong>之间的<strong>中间层</strong>。这对于安全方面来说是很好的，特别是当你使用web托管服务时；</p>
</blockquote>
<h3 id="5-请解释你如何通过不同于-80-的端口开启-nginx">5、请解释你如何通过不同于 80 的端口开启 Nginx?</h3>
<blockquote>
<p>为了通过一个不同的端口开启nginx,你必须进入 <strong>/etc/Nginx/sites-enables/</strong>  ，如果这是默认文件，那么你必须打开名为  <strong>default</strong> 的文件。编辑文件，并放置在你想要的端口：    <strong>Like server{listen 81;}</strong></p>
</blockquote>
<h3 id="6-负载均衡描述一下">6、负载均衡描述一下？</h3>
<blockquote>
<p>负载均衡即是代理服务器将接收的请求<strong>均衡的分发</strong>到各服务器中，<br>
负载均衡主要解决<strong>网络拥堵</strong>问题，提高服务器<strong>响应速度</strong>，服务<strong>就近提供</strong>，达到更好的访问质量，减少后台服务器大并发压力</p>
</blockquote>
<h3 id="7-解释一下正向代理和反向代理">7、解释一下正向代理和反向代理</h3>
<blockquote>
<ol>
<li>正向代理：<br>
一个位于<strong>客户端和原始服务器（<strong>origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。<br>
总结：  代理端代理的是</strong>客户端</strong></li>
<li>反向代理<br>
反向代理（reverse proxy）方式是指以<strong>代理服务器来接受internet上的连接请</strong>求，然后将请求发给内部网络上的服务器，<br>
并将服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器；<br>
总结：代理端代理的是<strong>服务端</strong></li>
</ol>
</blockquote>
<h3 id="8-为什么不使用多线程为什么-nginx-性能这么高">8、为什么不使用多线程？为什么 Nginx 性能这么高？</h3>
<blockquote>
<p>Apache：<br>
创建<strong>多个进程或线程</strong>，而每个进程或线程都会为其分配cpu和内存（<strong>线程要比进程小的多</strong>，所以worker支持比perfork高的并发），并发过大会榨干服务器资源；<br>
Nginx:<br>
采用<strong>单线程来异步非阻塞处理请求</strong>（管理员可以配置Nginx主进程的工作进程的数量）（epoll），<strong>不会为每个请求分配cpu和内存资源</strong>，节省了大量资源，同时也减少了大量的cpu的上下文切换。所以才使得nginx支持更高的并发；<br>
<strong>异步非阻塞事件处理机制</strong>：运用了<strong>epoll模型</strong>，提供了一个<strong>队列</strong>，排队解决</p>
</blockquote>
<h3 id="9-为什么要用-nginx">9、为什么要用 Nginx？</h3>
<blockquote>
<p>优点：</p>
<ol>
<li><strong>跨平台、配置简单</strong>；</li>
<li><strong>非阻塞、高并发连接</strong>：处理2-3万并发连接数，官方监测能支持5万并发；</li>
<li><strong>内存消耗小</strong>：开启10个nginx才占150M内存，nginx采取了分阶段资源分配技术</li>
<li>nginx处理<strong>静态文件</strong>好，耗费内存少；</li>
<li><strong>内置的健康检查</strong>功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其它的节点上。</li>
<li><strong>节省宽带</strong>： 支持GZIP压缩，可以添加浏览器本地缓存；</li>
<li><strong>稳定性高</strong>：宕机概率非常小</li>
<li>master/worker结构：一个<strong>master</strong>进程，生成一个或多个<strong>worker</strong>进程；</li>
<li>接受用户请求是<strong>异步的</strong>：浏览器将请求发送到nginx服务器，它先将用户请求<strong>全部接收</strong>下来，再<strong>一次性发给后端</strong>web服务器，极大减轻了web服务器的压力；</li>
<li>一边<strong>接收</strong>web服务器的返回数据，一边发送给浏览器客户端;</li>
<li><strong>网络依赖性</strong>比较低，只要ping同就可以负载均衡;</li>
<li>可以有多台<strong>nginx服务器</strong>;</li>
<li>事件驱动：通信机制采用<strong>epoll模型；</strong></li>
</ol>
</blockquote>
<h3 id="10-redis-支持的数据类型">10、Redis 支持的数据类型？</h3>
<blockquote>
<ol>
<li>String字符串：</li>
</ol>
</blockquote>
<h3 id="11-什么是-redis-持久化redis-有哪几种持久化方式优缺点是什么">11、什么是 Redis 持久化？Redis 有哪几种持久化方式？优缺点是什么？</h3>
<h3 id="12-使用过-redis-分布式锁么它是怎么实现的如果在-setnx-之后执行-expire-之前进程意外-crash-或者要重启维护了那会怎么样">12、使用过 Redis 分布式锁么，它是怎么实现的？如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？</h3>
<h3 id="13-什么是缓存穿透如何避免什么是缓存雪崩何如避免">13、什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</h3>
<h3 id="14-什么是-redis简述它的优缺点">14、什么是 Redis？简述它的优缺点？</h3>
<blockquote>
<p>redis(Remote Dictionary Server) 是一个使用<strong>C语言</strong>编写的，<strong>开源的</strong>（BSD许可）<strong>高性能****非关系型</strong>（NOSQL）的<strong>键值对数据库</strong>；<br>
redis可以存储键和5种不同类型的值之间的映射。键的类型只能为<strong>字符串</strong>，值支持5种数据类型：<strong>字符串--列表--散列表--集合--有序集合</strong>；<br>
<s>与传统数据库不同的是redis的数据时存在<strong>内存中</strong>的，所以读的写速度非常快，因此redis被广泛应用于<strong>缓存</strong>方向，每秒可以处理超过<strong>10万次读写</strong>操作，是已知性能最快的key-value DB。另外，redis也经常用来做<strong>分布式锁</strong>。除此之外，redi<strong>s支持事务、持久化、LUA脚本吗、LRU驱动事件、多种集群方案</strong>。</s></p>
</blockquote>
<blockquote>
<p>优点：</p>
<ol>
<li><strong>读写性能</strong>优异，redis能读的速度是110000次/S，写的速度是81000次/秒；</li>
<li>支持<strong>数据持久化</strong>，支持AOF和RDB良种持久化方式；</li>
<li>支持<strong>事务</strong>，redis的所有操作都是原子性的，同时redis还支持对几个操作合并后的原子性执行；</li>
<li><strong>数据结构</strong>丰富， 除了支持string（字符串）类型的value外还支持hash（散列表）、set（集合）、 zset（有序集合）、list（列表）等数据结构；</li>
<li>支持<strong>主从复制</strong>，主机会自动将数据同步到从机，可以进行<strong>读写分离</strong>。</li>
</ol>
</blockquote>
<blockquote>
<p>缺点:</p>
<ol>
<li>数据库容量受到<strong>物理内存的限制</strong>，不能用作海量数据的高性能读写，因此redis适合的场景主要局限在<strong>较小数据量的高性能操作和运算上</strong>；</li>
<li>redis<strong>不具备自动容错和恢复功能</strong>，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或手动切换前端的ip才能恢复；</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换ip还会引入<strong>数据不一致</strong>的问题，降低了系统可用性；</li>
<li>redis<strong>较难支持在线扩容</strong>，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ol>
</blockquote>
<h3 id="15-redis-相比-memcached-有哪些优势">15、Redis 相比 memcached 有哪些优势？</h3>
<blockquote>
<ol>
<li>memcached所有的值均是简单的<strong>字符串</strong>，redis作为替代者，支持更为<strong>丰富的数据类型</strong>；</li>
<li>redis的<strong>速度</strong>比memcached快很多</li>
<li>redis可以<strong>持久化</strong>其数据；</li>
</ol>
</blockquote>
<h3 id="16-redis-官方为什么不提供-windows-版本">16、Redis 官方为什么不提供 Windows 版本？</h3>
<blockquote>
<p>因为目前Linux版本已经相当<strong>稳定</strong>，而且<strong>用户量很大</strong>，无需开发windows版本，反而会带来兼容性等问题。</p>
</blockquote>
<h3 id="17-一个字符串类型的值能存储最大容量是多少">17、一个字符串类型的值能存储最大容量是多少？</h3>
<blockquote>
<p><strong>512M</strong></p>
</blockquote>
<h3 id="18-为什么-redis-需要把所有数据放到内存中">18、为什么 Redis 需要把所有数据放到内存中？</h3>
<blockquote>
<p>为了达到最快的<strong>读写速度</strong>将数据都读到内存中，并通过<strong>异步的方式</strong>将数据写入磁盘。所以redis<strong>具有快速和数据持久化</strong>的特性。<br>
<s>如果不将数据放到内存中，磁盘的I/O速度会严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。如果设置里<strong>最大使用的内存</strong>，则数据已有记录数达到内存限值后将不能继续插入新值；</s></p>
</blockquote>
<h3 id="19-redis-有哪些适合的场景">19、Redis 有哪些适合的场景？</h3>
<blockquote>
<ol>
<li>会话缓存（session cache）用redis缓存会话比其他存储（如memcached）的优势在于：redis提供<strong>持久化</strong>。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都不会高兴。</li>
<li>全页缓存（<strong>FPC</strong>）：除基本的会话token之外，redis还提供很简便的FPC平台；</li>
<li>队列：redis在<strong>内存存储引擎领域</strong>的一大优点是提供<strong>list和set操作</strong>，这使得redis能作为一个很好<strong>的消息队列平台使用</strong>。redis作为队列使用的操作，就类似于本地程序语言对list的push/pop操作；</li>
<li>排行榜/计数器：redis在内存中对数据进行<strong>递增递减</strong>的操作实现的非常好。**集合（set）和有序集合（sorted Set）**也使得我们在执行这些操作的时候变得非常简单，redis只是正好提供了这两种数据结构</li>
<li>订阅/发布</li>
</ol>
</blockquote>
<h3 id="20-redis-如何做内存优化">20、Redis 如何做内存优化？</h3>
<blockquote>
<p>可以好好利用Hash，list,sorted,set等集合类型数据，因为通常情况下很多小的key-value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以应尽可能的将数据模型抽象到散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称 姓氏 邮箱 密码设置单独的key，而是应该 把这个用户的所有信息<strong>存储到一张散列表里面</strong>；</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试中常见问题汇集：]]></title>
        <id>https://blog9527.github.io/post/mian-shi-zhong-chang-jian-wen-ti-hui-ji/</id>
        <link href="https://blog9527.github.io/post/mian-shi-zhong-chang-jian-wen-ti-hui-ji/">
        </link>
        <updated>2022-05-21T02:08:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><em>大家好，我是Java初学者，来CSDN主要也是为了学习知识。在个人博客中主要记录一些个人笔记、总结、学习心得等，如有不足之处请纠正，欢迎补充。——来自 菜鸟的蜕变</em></p>
</blockquote>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8759343"> <em>持续更新...</em><br>
<ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-mysql%E4%B8%8Eoracle%E7%9A%84%E5%8C%BA%E5%88%AB">一、MySql与Oracle的区别</a></li>
<li><a href="#%E4%BA%8C-list%E4%B8%8Ehashmap%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0">二、List与HashMap底层的实现</a></li>
<li><a href="#%E4%B8%89-%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81">三、乐观锁与悲观锁</a></li>
<li><a href="#%E5%9B%9B-synchronized%E4%B8%8Elock%E5%8C%BA%E5%88%AB">四、synchronized与lock区别</a></li>
<li><a href="#%E4%BA%94-ioniobioaio%E5%8C%BA%E5%88%AB">五、IO,NIO,BIO,AIO区别</a></li>
<li><a href="#%E5%85%AD-jsp%E5%92%8Cservlet%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8">六、jsp和servlet的过滤器和拦截器</a></li>
<li><a href="#%E4%B8%83-spring%E6%A1%86%E6%9E%B6%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1">七、Spring框架里如何实现事务</a></li>
<li><a href="#%E5%85%AB-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81sql">八、如何实现动态sql</a></li>
<li><a href="#%E4%B9%9D-mybatis%E4%B8%8Ejdbc%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">九、Mybatis与JDBC底层工作原理</a></li>
<li><a href="#%E5%8D%81-springboot2x%E4%B8%8E1x%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB">十、SpringBoot2.x与1.x的一些区别？</a></li>
<li><a href="#%E5%8D%81%E4%B8%80-springboot%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">十一、SpringBoot常见的注解及其底层实现</a></li>
<li><a href="#%E5%8D%81%E4%BA%8C-spring%E4%B8%ADdi%E4%B8%8Eioc%E5%8E%9F%E7%90%86">十二、Spring中DI与IOC原理</a></li>
<li><a href="#%E5%8D%81%E4%B8%89-jdk18%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7">十三、JDK1.8的新特性</a></li>
<li><a href="#%E5%8D%81%E5%9B%9B-js%E5%BC%95%E5%85%A5%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BA%8B%E4%BB%B6">十四、JS引入以及常见事件</a></li>
<li><a href="#%E5%8D%81%E4%BA%94-vue%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E4%BA%8B%E4%BB%B6">十五、VUE的理解及其事件</a></li>
<li><a href="#%E5%8D%81%E5%85%AD-sql%E8%AF%AD%E5%8F%A5%E6%9C%AC%E8%BA%AB%E7%9A%84%E4%BC%98%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">十六、sql语句本身的优化以及创建表的注意事项</a></li>
<li><a href="#%E5%8D%81%E4%B8%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%B4%A2%E5%BC%95">十七、数据库的索引</a></li>
<li><a href="#%E5%8D%81%E5%85%AB-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">十八、数据库的事务与隔离级别</a></li>
<li><a href="#%E5%8D%81%E4%B9%9D-%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%BD%AC%E5%8F%91%E5%8C%BA%E5%88%AB%E6%A1%86%E6%9E%B6%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0">十九、重定向与转发区别（框架里如何实现）</a></li>
<li><a href="#%E4%BA%8C%E5%8D%81-%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E6%8A%80%E6%9C%AFcookie-session">二十、会话跟踪技术（cookie  session...）</a></li>
<li><a href="#%E4%BA%8C%E5%8D%81%E4%B8%80-%E6%89%80%E4%BA%86%E8%A7%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86iso%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B">二十一、所了解的网络知识（ISO七层模型...）</a></li>
<li><a href="#%E4%BA%8C%E5%8D%81%E4%BA%8C-tcp%E4%B8%8Eudp%E7%9A%84%E5%8C%BA%E5%88%AB">二十二、TCP与UDP的区别</a></li>
<li><a href="#%E4%BA%8C%E5%8D%81%E4%B8%89-http%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%90%86%E8%A7%A3">二十三、HTTP协议的理解</a></li>
</ul>
</li>
</ul>
<label class="task-list-item-label" for="task-item-8759343"> *持续更新...*
@[TOC](目录： )</label></li>
</ul>
<h2 id="一-mysql与oracle的区别">一、MySql与Oracle的区别</h2>
<ol>
<li>
<p>并发性<br>
MySQL:<br>
MySQL以表级锁为主，对资源锁定的粒度很大，如果一个session对一个表加锁时间过长，会让其他session无法更新此表中的数据。<br>
虽然InnoDB引擎的表可以用行级锁，但这个行级锁的机制依赖于表的索引，如果表没有索引或sql语句未使用索引，仍然会使用表级锁。<br>
Oracle:<br>
Oracle使用行级锁，对资源锁定的粒度要小很多，只是锁定sql需要的资源，并且加锁是在数据中心的数据行上，不依赖于索引。所以Oracle对并发性的支持要好很多。</p>
</li>
<li>
<p>事务的提交<br>
MySQL默认自动提交，而Oracle默认不自动提交--需用户手动提交，需要在写commit，指令或点击commit按钮。</p>
</li>
<li>
<p>事务隔离级别<br>
MySQL是read commited的隔离级别，而Oracle是repeatable read的隔离级别，二者都支持serializable串行化事务隔离级别，可以实现最高级别的读一致。<br>
每个session提交后其他session才能看到提交的更改。<br>
Oracle通过在undo表空间中构造多版本数据来实现读一致，每个session查询时，如对应数据块发生变化，Oracle会在undo表空间中为这个session构造它查询时的旧的数据块；<br>
MySQL没有雷士Oracle的构造多版本数据块的机制，只支持read commited的隔离级别。一个session读取数据时，其他session不能更改数据，但可以在表最后插入数据。session更新数据时要加上排它锁，其他session无法访问数据。</p>
</li>
<li>
<p>分页查询<br>
MySQL是直接在SQL语句中写  &quot;select xxx from xxx where xxx limit x,y&quot;  ，有limit就可以实现分页；而Oracle则是需要用伪列ROWNUM和嵌套查询。</p>
</li>
<li>
<p>事务支持<br>
MySQL在innodb存储引擎的行级锁的情况下才可支持事务，而Oracle则完全支持事务。</p>
</li>
<li>
<p>持久性<br>
MySQL在数据库更新或重启，会丢失数据，而Oracle会把提交的SQL操作线写入在线联机日志文件中，保存到磁盘上 可随时恢复。</p>
</li>
<li>
<p>逻辑备份<br>
MySQL（逻辑）备份时要锁定数据才能保证备份的数据是一致的，影响业务正常的DML使用，而Oracle备份时不需锁定数据且备份的数据是一致的。</p>
</li>
<li>
<p>管理工具<br>
MySQL管理工具较少，在linux下的管理工具的安装有时还需装额外的包（phpmyadmin ...），有些复杂；<br>
Oracle有多种成熟命令行、图形界面、web管理工具，还有其他第三方管理工具，管理方便且高效。</p>
</li>
<li>
<p>权限与安全<br>
MySQL的用户与主机有关，容易被仿冒主机及IP有可乘之机；<br>
Oracle则较为传统，中规中矩。</p>
</li>
<li>
<p>分区表与分区索引<br>
MySQL不太成熟稳定，Oracle则很成熟，可提高用户访问DB的体验。</p>
</li>
<li>
<p>性能诊断<br>
MySQL诊断调优方法较少，主要有慢查询日志；<br>
Oracle则有各种陈述的诊断调优工具，能实现多自动分析、诊断功能。如：awr、<br>
addm、sqltrace、tkproof等。</p>
</li>
<li>
<p>复制<br>
MySQL复制服务器配置简单，但主库出现问题时 从库有可能丢失一定数据，且需要手动切换从库到主库；<br>
Oracle既有推和拉式的传统数据复制，也有dataguard的双机或多级容灾机制，主库出现问题时 可自动切换备库到主库，但配置管理复杂。</p>
</li>
<li>
<p>其他<br>
MySQL是轻量级数据库-免费，没有服务恢复数据；<br>
Oracle重量型数据库-收费，Oracle公司对Oracle数据库有任何服务。</p>
</li>
</ol>
<h2 id="二-list与hashmap底层的实现">二、List与HashMap底层的实现</h2>
<ol>
<li>List</li>
</ol>
<p>List实现Collection接口，它的数据结构是有序可以重复的结合，该结合的体系有索引；它有三个实现类：ArrayList、LinkList、Vector三个实现类；<br>
三个实现类的区别：<br>
ArrayList:底层数据结构使数组结构，查询速度快，增删改慢，<br>
LinkList:底层使用链表结构，增删速度快，查询稍慢；<br>
Vector：底层是数组结构，线程同步ArrayList是线程不同步；<br>
可变长度数组不断new数组：<br>
ArrayList当初始化容量超过10时，会new一个50%de ,把原来的东西放入这150%中；<br>
Vector：当容量超过10时，会new一个100%的浪费内存；</p>
<p>List接口对Collection进行了简单的扩充，它的具体实现类常用的有ArrayList和LinkedList。你可以将任何东西放到一个List容器中，并在需要时从中取出。ArrayList从其命名中可以看出它是一种类似数组的形式进行存储，因此它的随机访问速度极快，而LinkedList的内部实现是链表，它适合于在链表中间需要频繁进行插入和删除操作。在具体应用时可以根据需要自由选择。前面说的Iterator只能对容器进行向前遍历，而ListIterator则继承了Iterator的思想，并提供了对List进行双向遍历的方法。</p>
<ol start="2">
<li>HashMap底层实现</li>
</ol>
<p>HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许重复的键。Map接口有两个基本的实现，HashMap和TreeMap。TreeMap保存了对象的排列次序，而HashMap则不能。HashMap允许键和值为null。HashMap是非synchronized的，但collection框架提供方法能保证HashMap synchronized，这样多个线程同时访问HashMap时，能保证只有一个线程更改Map。<br>
构造方法:<br>
HashMap提供了四个构造方法，构造方法中，依靠第三个方法来执行的，但是前三个方法都没有进行数组的初始化操作，即使调用了构造方法此时存放HaspMap中数组元素的table表长度依旧为0 。在第四个构造方法中调用了inflateTable()方法完成了table的初始化操作，并将m中的元素添加到HashMap中。<br>
HashMap的工作原理 ：HashMap是基于散列法（又称哈希法hashing）的原理，使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。<br>
当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket（桶）位置来储存Entry对象。”HashMap是在bucket中储存键对象和值对象，作为Map.Entry。并不是仅仅只在bucket中存储值</p>
<h2 id="三-乐观锁与悲观锁">三、乐观锁与悲观锁</h2>
<ol>
<li>
<p>概念<br>
·悲观锁（Pessimistic Lock）：每次拿数据的时候都会担心会被别人修改（疑心重很悲观），所以每次在拿数据的时候都会<strong>上锁</strong>。确保自己使用的过程中不会被别人访问，自己使用完后再解锁。<br>
期间需要访问该数据的都会等待。<s>（传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。）</s></p>
<p>·乐观锁（Optimistic Lock）：每次拿数据的时候都完全不担心会被别人修改（心态好很乐观），所以每次在拿数据的时候都<strong>不会上锁</strong>。但是在更新数据的时候去判断该期间是否被别人修改过（使用版本号、CAS算法实现等机制），期间该数据可以随便被其他人读取。<s>（乐观锁<strong>适用于多读</strong>的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。）</s></p>
</li>
<li>
<p>使用场景<br>
乐观锁适用于多读场景，即冲突很少发生的时候，这样可以省去锁的开销，加大系统的吞吐量；<br>
悲观锁适用于多写场景下，多写情况 一般会产生冲突，这就会导致上层应用汇不断进行retry，反而降低了性能。</p>
</li>
<li>
<p>乐观锁常见的两种实现方式</p>
</li>
</ol>
<blockquote>
<p><strong>乐观锁一般会使用版本号机制或CAS算法实现。</strong></p>
</blockquote>
<p>版本号机制：<br>
在数据表中加上一个数据版本号version字段，表示数据	被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。<br>
<em>例：<br>
假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。<br>
操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。<br>
在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。<br>
操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。<br>
操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。<br>
这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</em></p>
<p>CAS算法(compare and swap——比较与交换)</p>
<p>有名的无所算法，无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。涉及三个操作数：<br>
需要读写的内存值 V<br>
进行比较的值 A<br>
拟写入的新值 B<br>
当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>
<ol start="4">
<li>
<p>乐观锁的缺点<br>
ABA 问题（<strong>乐观锁常见问题</strong>）<br>
如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 &quot;ABA&quot;问题。<br>
JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。<br>
循环时间长开销大<br>
自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。<br>
只能保证一个共享变量的原子操作<br>
CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p>
</li>
<li>
<p>CAS与synchronized的使用情景<br>
<em><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></em><br>
对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。<br>
对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。<br>
<s>其它：Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</s></p>
</li>
</ol>
<h2 id="四-synchronized与lock区别">四、synchronized与lock区别</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20201030090249716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<ol>
<li>
<p>实现层<br>
synchronized是Java关键字，JVM层面实现加锁和释放锁；Lock是一个接口，在代码层面实现加锁和释放锁。</p>
</li>
<li>
<p>用法<br>
sychronized用在代码块和方法上；lock只能写在代码里，不能直接修改方法。</p>
</li>
<li>
<p>释放锁<br>
sychronized在线程代码执行完或出现异常自动释放锁；Lock不自动释放，需要在finally{}代码块显示地中释放锁。</p>
</li>
<li>
<p>等待<br>
sychronized会导致线程拿不到锁一直等待；Lock可以设置尝试获取锁或获取锁失败一定超时。</p>
</li>
<li>
<p>通知<br>
sychronized无法得知是否获取锁成功；Lock可以通过tryLock获得锁是否成功。</p>
</li>
<li>
<p>功能复杂性<br>
sychronized加锁可重入、不可中断、非公平；<br>
Lock可重入、可判断、可公平和不公平、细分读写锁提高效率。</p>
</li>
</ol>
<h2 id="五-ioniobioaio区别">五、IO,NIO,BIO,AIO区别</h2>
<p>简单来说就是input和output流，IO流主要是用来处理设备之间的数据传输，Java IO对于数据的操作都是通过流实现的，而java用于操作流的对象都在IO包中。<br>
BIO：同步阻塞,服务器实现模式为一个连接一个线程, 适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中, ，JDK1.4以前的唯一选择，但程序直观简单易理解。<br>
NIO：同步非阻塞,服务器实现模式为一个请求一个线程, 适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。<br>
AIO：异步非阻塞,服务器实现模式为一个有效请求一个线程, 适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p>
<h2 id="六-jsp和servlet的过滤器和拦截器">六、jsp和servlet的过滤器和拦截器</h2>
<p>Jsp：JSP(Java Server Pages)是Sun 公司指定的一种服务器端动态页面技术的组件规范，Jsp是以“.jsp”为后缀的文件，在该文件中主要是html 和少量的java 代码。jsp 文件在容器中会转换成Servlet中执行。<br>
Servlet：Servlet (Server Applet)是Sun公司指定的一种用来扩展Web服务器功能的组件规范，属于服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。<br>
jsp就是在html里面写java代码，servlet就是在java里面写html<br>
过滤器和拦截器的区别：<br>
①拦截器是基于java的反射机制的，而过滤器是基于函数回调。<br>
②拦截器不依赖与servlet容器，过滤器依赖与servlet容器。<br>
③拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。<br>
④拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。<br>
⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。<br>
⑥拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</p>
<h2 id="七-spring框架里如何实现事务">七、Spring框架里如何实现事务</h2>
<p>实现方式共有两种：<strong>声明式和编程式(事务操作的地方很少的时候)</strong>；<strong>声明式事务管理</strong>方式。<br>
基于AOP技术实现的声明式事务管理，实质就是：在方法执行前后进行拦截，然后在目标方法开始之前创建并加入事务，执行完目标方法后根据执行情况提交或回滚事务。<br>
声明式事务管理又有两种方式：基于XML配置文件的方式；另一个是在业务方法上进行@Transactional注解，将事务规则应用到业务逻辑中。</p>
<h2 id="八-如何实现动态sql">八、如何实现动态sql</h2>
<p>Mybatis动态sql可以在Xml映射文件内，以标签的形式编写动态sql<br>
Mybatis提供了9种动态sql标签：<br>
trim | where | set | foreach | if | choose | when | otherwise | bind。<br>
执行原理是根据表达式的值 完成逻辑判断并动态拼接sql的功能。</p>
<h2 id="九-mybatis与jdbc底层工作原理">九、Mybatis与JDBC底层工作原理</h2>
<p><em><strong>mybatis的工作原理：</strong></em><br>
MyBatis是支持普通SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。<br>
MyBatis使用简单的XML或注解用于配置和原始映射，将接口和Java的POJOs（Plain Ordinary Java Objects，普通的 Java对象）映射成数据库中的记录。<br>
每个MyBatis应用程序主要都是使用SqlSessionFactory实例的，一个SqlSessionFactory实例可以通过SqlSessionFactoryBuilder获得。用xml文件构建SqlSessionFactory实例是非常简单的事情。<br>
推荐在这个配置中使用类路径资源，但可以使用任何Reader实例，包括用文件路径或file://开头的url创建的实例。MyBatis有一个实用类----Resources，它有很多方法，可以方便地从类路径及其它位置加载资源。<br>
<em><strong>JDBC原理</strong></em><br>
Java数据库连接技术的简称。<br>
是一种用于执行SQL语句的JavaAPI，提供连接各种常用数据库的能力。<br>
1&gt;加载驱动——-2&gt;获取连接对象—–3&gt;创建命令—–4&gt;执行sql语句，并且返回结果集——5&gt;处理结果集—–6&gt;关闭连接</p>
<h2 id="十-springboot2x与1x的一些区别">十、SpringBoot2.x与1.x的一些区别？</h2>
<p>1.<em>配置变更</em><br>
2.<em>JDK版本</em>升级：2.x至少需要JDK1.8的支持，2.x里面的许多方法应用了JDK8的许多高级新特性。<br>
3.<em>第三方库</em>升级：响应式spring编程支持<br>
2.x通过启动器和自动配置全面支持Spring的相应编程，响应式编程是完全异步和非阻塞的，它是基于时间驱动模型，而不是传统的线程模型。就连Spring Boot内部叶对一些功能点进行了很必要的响应式升级，最值得注意的是对内嵌式容器的支持。<br>
4.<em>HTTP/2支持</em><br>
提供对HTTP/2的支持，如：Tomcat，undertow,jetty,这个得依赖具体选择得应用服务器和应用环境。<br>
5.<em>配置属性绑定</em><br>
在2.x中，配置绑定功能有一些改造，在调整了1.x中许多不一致地方外，还提供了独立注解之外得API来装配配置属性，并且增加了属性得来源。<br>
6.更多<em>改进和加强</em><br>
Gradle插件提供了一些重要得特性提升。<br>
Kotlin 2.x开始提供了runApplication函数来运行Spring Boot应用<br>
Actuator加强所有得HTTP执行端点现在都暴露在/actuator路径下，并对JSON结果集也做了改善<br>
Data支持上面有说到对响应式</p>
<h2 id="十一-springboot常见的注解及其底层实现">十一、SpringBoot常见的注解及其底层实现</h2>
<p><strong>@SpringBootApplication</strong>包含了@springBootConfiguration,(继承了@Configuration注解主要用于加载配置文件，二者的功能也一样，标志这个类是配置类，并会将当前类内申明的一个或多个以@Bean标志的方法的实例纳入到spring容器中，并且实列名就是方法名。)；</p>
<p><strong>@EnableAutoConfiguration</strong>可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，@EnableAutoConfiguration可以智能的自动配置功效才得以大功告成；</p>
<p><strong>@componentScan</strong>（@ComponentScan的功能其实就是自动扫描并加载符合条件的组件或bean定义，最终将这些bean定义加载到容器中。我们可以通过basePackages等属性指定@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现从声明@ComponentScan所在类的package进行扫描，默认情况下是不指定的，所以SpringBoot的启动类最好放在root package下。）；</p>
<p><strong>@Controller</strong>——控制器，处理http请求。</p>
<p><strong>@RestController</strong>—— 复合注解，从源码我们知道,@RestController注解相当于@ResponseBody+@Controller合在一起的作用,RestController使用的效果是将方法返回的对象直接在浏览器上展示成json格式；</p>
<p><strong>@RequestBody</strong>通过HttpMessageConverter读取Request Body并反序列化为Object（泛指）对象；</p>
<p><strong>@RequestMapping</strong><br>
@RequestMapping 是 Spring Web 应用程序中最常被用到的注解之一。这个注解会将 HTTP 请求映射到 MVC 和 REST 控制器的处理方法上；</p>
<p><strong>@GetMapping</strong>用于将HTTP get请求映射到特定处理程序的方法注解<br>
注解简写：@RequestMapping(value = &quot;/say&quot;,method = RequestMethod.GET)等价于：@GetMapping(value = &quot;/say&quot;)<br>
GetMapping源码是@RequestMapping(method = RequestMethod.GET)的缩写；</p>
<p><strong>@PostMapping</strong>用于将HTTP post请求映射到特定处理程序的方法注解<br>
是@RequestMapping(method = RequestMethod.POST)的缩写</p>
<p><strong>@PathVariable</strong>:获取url中的数据</p>
<pre><code class="language-java">//请求示例：
http://localhost:8080/User/getUser/123
</code></pre>
<p><strong>@RequestParam</strong>:获取请求参数的值</p>
<h2 id="十二-spring中di与ioc原理">十二、Spring中DI与IOC原理</h2>
<p><strong>控制反转</strong>IoC(Inversion of Control)即<strong>创建对象的控制权进行转移</strong>，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IoC容器，它就是一个专门用来<strong>创建对象的工厂</strong>，你要什么对象，它就给你什么对象，有了IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。<br>
<strong>DI</strong>（Dependency Injection），即“依赖注入”：<strong>组件之间依赖关系</strong>由容器在<strong>运行期</strong>决定。</p>
<p>IOC：<br>
DispatcherServlet在初始化init()的时候，会去创建ApplicationContext，在其构造实例化时加载配置文件，并解析文件封装成一个个BeanDefinition，然后将BeanDefinition一个个以key-value的形式缓存到一个集合Map中。之后在调用getBean()时，会根据全类名去刚刚缓存的集合里拿到对应的BeanDefinition，之后根据BeanDefinition创建真正的实例对象。之后spring进一步把创建好的实例对象封装成BeanWapper，在把BeanWapper保存到IOC容器中。<br>
DI:<br>
在调用 <strong>getBean</strong> ( )时，才会执行依赖注入，利用 <strong>反射以及注解</strong>对其进行依赖注入。</p>
<h2 id="十三-jdk18的新特性">十三、JDK1.8的新特性</h2>
<p>1.<strong>Lambda表达式</strong>：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。<br>
2.<strong>方法引用</strong>：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>
3.<strong>默认方法</strong>：默认方法就是一个在接口里面有了一个实现的方法。<br>
4.<strong>新工具</strong>：新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。<br>
5.<strong>Stream API</strong>：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。<br>
6.<strong>Date Time API</strong>：加强对日期与时间的处理。<br>
7.<strong>Optional类</strong>：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。<br>
8.<strong>Nashorn，JavaScript引擎</strong>：JDK1.8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</p>
<h2 id="十四-js引入以及常见事件">十四、JS引入以及常见事件</h2>
<p>①外部引用</p>
<pre><code class="language-java">//用script标签，链接外部的js文件
&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>②内部引用</p>
<pre><code class="language-java">//写在HTML文件内，用script标签包括
&lt;head&gt;
  &lt;script&gt;
    alert('Hello World!');
  &lt;/script&gt;
&lt;/head&gt;
</code></pre>
<p>③行内引用</p>
<pre><code class="language-java">//写在HTML元素内部
&lt;input type=&quot;button&quot; value=&quot;按钮&quot; onclick=&quot;alert('Hello World')&quot; /&gt;
</code></pre>
<p><strong>常见事件：</strong><br>
点击事件（onclick）<br>
页面加载事件（onload）<br>
内容改变事件（onchange）：事件内容发生变化时<br>
聚焦事件（onfocus）<br>
失去焦点事件（onblur）<br>
窗口滚动事件（onscroll）<br>
表单提交事件（onsubmit）<br>
鼠标移动到某对象上方（Onmousemove）、鼠标离开某一对象	 （onmouseout）、鼠标移动到某个区域（onmouseover）<br>
鼠标按下事件（onmousedown）、鼠标松开事件（onmouseup）</p>
<h2 id="十五-vue的理解及其事件">十五、VUE的理解及其事件</h2>
<p>Vue是一套构建用户界面的渐进式框架,也可以理解为是一个视图模板引擎,强调的是状态到界面的映射。<s>开发人员将js代码分为了三个板块,数据(Model),逻辑控制(*),视图(View),数据板块只负责数据部分,视图板块负责更改样式,逻辑控制负责联系视图板块和数据板块,这样子有很大的好处,当需求发生变动时,只需要修改对应的板块就好</s></p>
<pre><code class="language-java">//常见事件
   &lt;!-- 方法处理器 --&gt;
 &lt;button v-on:click=&quot;doThis&quot;&gt;&lt;/button&gt;
 &lt;!-- 缩写 --&gt;
&lt;button @click=&quot;doThis&quot;&gt;&lt;/button&gt;

 &lt;!-- 内联语句 --&gt;
&lt;button v-on:click=&quot;doThat('HelloWord', $event)&quot;&gt;&lt;/button&gt;
 &lt;!-- stop停止冒泡 --&gt;
 &lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;
</code></pre>
<h2 id="十六-sql语句本身的优化以及创建表的注意事项">十六、sql语句本身的优化以及创建表的注意事项</h2>
<p><strong>Sql语句优化：</strong><br>
（1）a. ORDER BY + LIMIT组合的索引优化;<br>
b. WHERE + ORDER BY + LIMIT组合的索引优化;<br>
c. WHERE+ORDER BY多个栏位+LIMIT<br>
(2）如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引<br>
(3)like语句优化<br>
(4)where子句使用 ！= 或 &lt;&gt; 操作符优化<br>
(5)where子句中使用 IS NULL 或 IS NOT NULL 的优化<br>
(6)where子句使用or的优化<br>
(7)where子句使用IN 或 NOT IN的优化(between替换in、exist替换in、left join替换in)<br>
(8)where子句中对字段进行表达式操作的优化<br>
（9）任何地方都不要用 select * from table，用具体的字段列表替换&quot;*&quot;，不要返回用不到的字段<br>
（10）使用“临时表”暂存中间结果<br>
（11）limit分页优化<br>
（12）批量插入优化<br>
（13）利用limit 1 、top 1 取得一行<br>
（14）尽量不要使用 BY RAND()命令<br>
（15）尽量用 union all 替换 union<br>
（16）避免类型转换：where子句中出现column字段的类型和传入的参数类型不一致的时候发生的类型转换<br>
（17）尽可能使用更小的字段<br>
（18）Inner join 和 left join、right join、子查询<br>
<strong>建表注意事项：</strong><br>
使用三大范式去设计表；<br>
树形结构的数据，通常采用自连接的方式；<br>
字典表设计结构参考，通常采用结构表来进行设计</p>
<h2 id="十七-数据库的索引">十七、数据库的索引</h2>
<p>索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都	以B-树的形式保存。mysql中主要有FULLTEXT(全文索引),HASH,BTREE,RTREE四种<br>
HASH：在in和“=”条件下可一次定位，效率高，但对于范围查询和排序及组合索引效率任然不高。<br>
BTREE:按一定算法将值存入属性结构中（二叉树），查询时依次遍历；<br>
RTREE：仅支持geometry数据类型<br>
<strong>索引类型:</strong><br>
普通索引：加速查询，允许插入重复值和空置<br>
唯一索引：加速查询，列值唯一<br>
主键索引:加速查询，列值唯一，且表中只有一个<br>
全文索引：在MyISAM引擎上使用只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，解决了模糊查询效率低的问题。<br>
组合索引：用于组合搜索，其效率大于索引合并。</p>
<h2 id="十八-数据库的事务与隔离级别">十八、数据库的事务与隔离级别</h2>
<p>数据库事务的四大<strong>特性</strong>：<br>
原子性：要么全部成功，要么全部失败回滚；<br>
一致性：使数据库从一个一致性状态变换到另一个一致性状态；<br>
隔离性：两个用户操作同一张表时，互不干扰；<br>
持久性：事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。<br>
<img src="https://img-blog.csdnimg.cn/20201104005843861.png#pic_center" alt="在这里插入图片描述" loading="lazy"><br>
脏读：一个事务处理过程中读取到另一个未提交的事务中的数据；<br>
不可重复度：一个事务读取了另一个已提交的事务中的数据；<br>
幻读：一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p>
<h2 id="十九-重定向与转发区别框架里如何实现">十九、重定向与转发区别（框架里如何实现）</h2>
<p><strong>区别：</strong><br>
1.请求重定向和请求转发都是web开发中资源跳转的方式。<br>
2.请求转发是服务器内部的跳转<br>
地址栏发生变化<br>
只有一个请求相应<br>
可以通过request域跳转目标的请求<br>
3.请求重定向是浏览器自动发起对跳转目标的请求<br>
地址栏会发生变化<br>
两次请求相应<br>
无法通过request域传递对象<br>
4.转发是服务器行为，重定向是客户端行为<br>
<strong>如何在框架里实现：</strong><br>
在SpringMVC框架中，控制处理器中处理方法的return语句默认就是转发实现，只不过实现的是转发到视图；<br>
在视图名称之前加上forward：完成转发<br>
return &quot;forward:/index/isLogin&quot;;<br>
在视图名称之前加上redirect: 完成重定向<br>
return &quot;redirect:/index/isRegister&quot;;</p>
<h2 id="二十-会话跟踪技术cookie-session">二十、会话跟踪技术（cookie  session...）</h2>
<p>1.客户端会话技术cookie：cookie是将数据保存在浏览器客户端的；<br>
<strong>Cookie：</strong><br>
cookie的数据存在浏览器<br>
浏览器客户端第一次请求服务器时，服务器端创建cookie，绑定数据后通过响应发送cookie到浏览器客户端，浏览器收到cookie后存储在本地，下次请求时将cookie又带回服务器<br>
浏览器对单个cookie的大小有限制，一般为4kb（不同浏览器存在差异），并对同一个域名下cookie的数量也有限制（一般20个以内）<br>
2.服务端会话技术session：session是将数据保存在服务器的；<br>
<strong>Session：</strong><br>
Session创建后服务器将Session ID 通过Cookie发送到客服端浏览器，而浏览器则将该Session ID 保存在会话Cookie中。当浏览器再次向服务器发送HTTP请求时，会将Session ID 信息一起发送给服务器。服务器根据该Session ID 在服务器内存找到对应的Session对象，即可取出共享数据<br>
session不是一打开网站就会立刻建立，创建session需要满足以下两个条件中的任意一个条件：<br>
（1）后台服务器端调用HttpSession session = request.getSession()进行创建<br>
（2）用户第一次访问jsp页面就会创建session，因为jsp默认会调用session = pageContext.getSession();<br>
session是依赖cookie的，JSessionId通过cookie传递到浏览器，并在浏览器通过cookie的形式存在<br>
3.Session和Cookie的<strong>区别</strong><br>
（1） Session存储在服务器端，Cookie存储在浏览器端<br>
（2）Session存储无大小限制，Cookie存储数据有大小限制<br>
（3）Session相对Cookie更安全</p>
<h2 id="二十一-所了解的网络知识iso七层模型">二十一、所了解的网络知识（ISO七层模型...）</h2>
<p><img src="https://img-blog.csdnimg.cn/20201104010033983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"><br>
七大层：<strong>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</strong><br>
应用层：为网络用户或应用程序提供各种服务，如文件传输、电子邮件、网络管理和远程登录等（协议代表：HTTP、Telnet、FTP、SNMP、RTSP）；<br>
表示层：用于处理在多个通信系统之间交换信息的表示方式，包括数据格式的转换、数据加密与解密、数据压缩与恢复等（ASCII、ASN.1、JPEG、MPEG）；<br>
会话层：针对远程访问进行管理（比如断点续传），包括会话管理、传输同步以及数据交换管理等（NetBIOS、ASP）;<br>
传输层：传输层从会话层接收数据，形成报文（Message），并且在必要时将其分成若干个分组，然后交给网络层进行传输。为上一层进行通信的两个进程之间提供一个可靠的端到端服务，使传输层以上的各层不再关心信息传输的问题；（端到端：进行相互通信的两个节点不是直接通过传输介质连接起来，相互之间有很多交换设备，如路由器），TCP、UDP、SPX；<br>
网络层：进行路由选择，以确保数据分组（Packet）从发送端到达接收端，并在子网发生阻塞时进行拥塞控制。网络层还要解决异构网络（比如网络协议不同）的互连问题，以实现数据分组在不同类型的网络中传输（IP、IPX、RIP、OSPF）。<br>
数据链路层：在两个相邻节点间的线路上无差错地传送以帧为单位的数据，并要产生和识别帧边界。数据链路层还提供了差错控制与流量控制的方法，保证在物理线路上传送的数据无差错（SDLC、HDLC、PPP、STP、帧中继）。<br>
物理层：透明地传送二进制比特流，但物理层并不关心比特流的实际意义和结构，只是负责接收和传送比特流。定义网络硬件的特性，包括使用什么样的传输介质以及与传输介质连接的接头等物理特性，所典型规范代表有（EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45）。</p>
<h2 id="二十二-tcp与udp的区别">二十二、TCP与UDP的区别</h2>
<p>1.连接方面区别<br>
TCP是面向连接；<br>
UDP是无连接的，即发送数据之前不需要建立连接；<br>
2.安全方面的区别<br>
TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；<br>
UDP尽最大努力交付，即不保证可靠交付；<br>
3.传输效率的区别<br>
TCP传输效率相对较低；<br>
UDP传输效率高，适用于对高速传输和实时性有较高的通信或广播通信；<br>
4.连接对象数量的区别<br>
TCP连接只能是点到点，一对一的；<br>
UDP支持一对一，一对多，多对一和多对多的交互通信</p>
<h2 id="二十三-http协议的理解">二十三、HTTP协议的理解</h2>
<p>超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。<br>
HTTP请求内容：请求行、请求头、空行、请求体组成<br>
请求行：请求方式+url+协议版本</p>
<ol>
<li>常见的请求方法有GET、POST、PUT、DELETE、HEAD;</li>
<li>客户端获取的资源路径（所谓的URL）；</li>
<li>客户端使用的HTTP协议版本号<br>
请求头：客户端向服务器发送请求的补充说明<br>
请求体：一般携带的请求参数<br>
HTTP响应内容：响应行、响应头、空行、响应体组成</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20201104010446849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20201104010446837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx服务器+（正、反向代理）]]></title>
        <id>https://blog9527.github.io/post/nginx-fu-wu-qi-zheng-fan-xiang-dai-li/</id>
        <link href="https://blog9527.github.io/post/nginx-fu-wu-qi-zheng-fan-xiang-dai-li/">
        </link>
        <updated>2022-05-21T02:08:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><em>本章主要简单介绍正向代理与反向代理，以及Nginx服务器</em></p>
</blockquote>
<h3 id="一-反向代理reverse-proxy">一、反向代理（reverse proxy）</h3>
<p>反向代理服务器位于<strong>用户与目标服务器</strong>之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为<strong>Web加速</strong>，即使用反向代理作为Web服务器的前置机来<strong>降低网络和服务器的负载</strong>，提高访问效率。</p>
<p>特点：</p>
<ol>
<li>反向代理服务器位于用户与目标服务器之间</li>
<li>对于用户而言，以为代理服务器就是真实的服务器</li>
<li>反向代理机制保护了真实的服务器信息</li>
<li>反向代理一般称之为<strong>服务端代理</strong>。<br>
<img src="https://img-blog.csdnimg.cn/20201107130911921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"><br>
步骤:<br>
1.当用户发起请求时,该请求被代理服务器<strong>拦截</strong>.<br>
2.代理服务器查询自己的配置文件,根据url地址获取<strong>真实</strong>的服务器信息.<br>
3.由代理服务器根据真实的服务器信息,<strong>获取</strong>数据.<br>
4.真实的服务器接收请求之后,将数据<strong>返回</strong>给代理服务器.<br>
5.代理服务器接收到服务器数据之后,将数据回<strong>传给</strong>用户,本次代理结束.</li>
</ol>
<h3 id="二-正向代理forward-proxy">二、正向代理(Forward Proxy)</h3>
<p>正向代理，是一个位于**客户端和原始服务器（origin server）**之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。<strong>客户端才使用正向代理</strong>。</p>
<p>特点:<br>
1.代理服务器位于<strong>用户与真实服务器</strong>之间的<br>
2.客户非常清楚自己访问的服务到底是谁?<br>
3.服务器不清楚访问自己的服务器到底是谁,以为只是代理服务器访问.<br>
4.正向代理称之为<strong>客户端代理</strong>.保护了客户的信息<br>
<img src="https://img-blog.csdnimg.cn/20201107131628222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="三-nginx服务器">三、Nginx服务器</h3>
<p>1.Nginx服务器介绍<br>
Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。<br>
其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。</p>
<p><strong>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器</strong>，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p>
<p>特点:<br>
①.占用<strong>内存</strong>少 不超过2M<br>
②.<strong>并发</strong>能力强 5万/秒 tomcat 150-220个/秒<br>
③.开发<strong>语言</strong> C语言</p>
<p>2.Nginx下载<br>
<a href="http://nginx.org/en/download.html">官网地址</a><br>
<img src="https://img-blog.csdnimg.cn/20201107132424136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"><br>
3.Nginx安装<br>
启动: 首先右键以管理员身份运行,之后程序闪退表示服务器启动正常.<br>
<img src="https://img-blog.csdnimg.cn/20201107132628740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<p>4.检查Nginx服务启动项<br>
nginx启动时,会启动2个进程项,其中一个<br>
①.主进程 主要为用户提供反向代理服务 占用内存大<br>
②.守护进程 防止主进程意外关闭的. 占用内存小的<br>
<img src="https://img-blog.csdnimg.cn/20201107132718244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"><br>
5.启动正常测试</p>
<blockquote>
<p><em>浏览器地址栏输入：localhost<br>
默认端口号 80</em></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201107132934373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"><br>
6. Nginx命令<br>
目录: 在Nginx的根目录中执行<br>
<img src="https://img-blog.csdnimg.cn/20201107133142333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTMzMzQ2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"><br>
命令：</p>
<pre><code class="language-java">//①启动命令      start  nginx*
//②重启命令      nginx  -s  reload*
//③停止命令      nginx   -s  stop*
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[restful风格一些认识]]></title>
        <id>https://blog9527.github.io/post/restful-feng-ge-yi-xie-ren-shi/</id>
        <link href="https://blog9527.github.io/post/restful-feng-ge-yi-xie-ren-shi/">
        </link>
        <updated>2022-05-21T02:08:01.000Z</updated>
        <content type="html"><![CDATA[<p><strong>什么是rest?</strong><br>
REST(英文：Representational State Transfer，简称REST，意思：表述性状态转换，描述了一个架构样式的网络系统，比如web应用)。</p>
<p>它是一种软件架构风格、设计风格，而<strong>不是标准</strong>，只是提供了一组设计原则和约束条件，它主要用于客户端和服务端<em>交互类的软件</em>。基于这个风格设计的软件可以更简介，更有层次，更易于实现缓存等机制。</p>
<p><strong>什么是RESTful？</strong><br>
REST：指的是一组<strong>架构约束条件和原则</strong>。满足这些约束条件和原则的应用程序或设计就是RESTful。</p>
<p><strong>restful风格实现1<br>
restful风格实现2：</strong></p>
<pre><code class="language-java">/** 
	 * restful风格实现1：
	 *  作用：可以动态的接受url中的参数
	 *  语法：
	 *  	1.url中的地址如果是参数，则需要使用 / 分割
	 *  	2.controller方法接受参数时，要使用 {} 号方式获取
	 *  	3.如果需要获取参数信息，则使用特定的注解标识
	 *  restful风格实现2：需要指定访问的请求类型，并且根据特定的类型执行业务
	 *    请求类型：
	 *    	1.get--执行查询操作
	 *    	2.post--执行入库操作
	 *    	3. put--执行更新操作
	 *    	4.delete--执行删除操作
	 * */
//	例子：
	 //@RequestMapping(value=&quot;page/{moduleName}&quot;,method=RequestMethod.GET)
	@GetMapping(&quot;/page/{moduleName}&quot;)
	public String module(@PathVariable String moduleName) {
		return moduleName;
	}
</code></pre>
]]></content>
    </entry>
</feed>